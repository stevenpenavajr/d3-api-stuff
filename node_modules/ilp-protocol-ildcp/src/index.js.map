{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":[],"mappings":";;;;;;;;;;AAAA,wCAAuC;AACvC,yCAA0C;AAC1C,MAAM,KAAK,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC,oBAAoB,CAAC,CAAA;AAEpD,MAAM,iBAAiB,GAAG,aAAa,CAAA;AACvC,MAAM,yBAAyB,GAAG,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,CAAA;AAClD,MAAM,uBAAuB,GAAG,MAAM,CAAC,IAAI,CAAC,8CAA8C,EAAE,QAAQ,CAAC,CAAA;AACrG,MAAM,6BAA6B,GAAG,KAAK,CAAA;AAY3C,MAAM,uBAAuB,GAAG,CAAC,OAAe,EAAgB,EAAE;IAChE,MAAM,GAAG,GAAG,SAAS,CAAC,qBAAqB,CAAC,OAAO,CAAC,CAAA;IAEpD,IAAI,GAAG,CAAC,WAAW,KAAK,iBAAiB,EAAE;QACzC,MAAM,IAAI,SAAS,CAAC,kCAAkC,CAAC,CAAA;KACxD;IAED,IAAI,CAAC,uBAAuB,CAAC,MAAM,CAAC,GAAG,CAAC,kBAAkB,CAAC,EAAE;QAC3D,MAAM,IAAI,KAAK,CAAC,wEAAwE,CAAC,CAAA;KAC1F;IAED,IAAI,IAAI,CAAC,GAAG,EAAE,GAAG,MAAM,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE;QACtC,MAAM,IAAI,KAAK,CAAC,mCAAmC,CAAC,CAAA;KACrD;IAED,OAAO,EAAE,CAAA;AACX,CAAC,CAAA;AAgGC,0DAAuB;AA9FzB,MAAM,qBAAqB,GAAG,CAAC,OAAqB,EAAU,EAAE;IAC9D,OAAO,SAAS,CAAC,mBAAmB,CAAC;QACnC,MAAM,EAAE,GAAG;QACX,WAAW,EAAE,iBAAiB;QAC9B,kBAAkB,EAAE,uBAAuB;QAC3C,SAAS,EAAE,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,6BAA6B,CAAC;QAC/D,IAAI,EAAE,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;KACtB,CAAC,CAAA;AACJ,CAAC,CAAA;AAuFC,sDAAqB;AArFvB,MAAM,wBAAwB,GAAG,CAAC,QAAgB,EAAiB,EAAE;IACnE,MAAM,EAAE,WAAW,EAAE,IAAI,EAAE,GAAG,SAAS,CAAC,qBAAqB,CAAC,QAAQ,CAAC,CAAA;IAEvE,IAAI,CAAC,yBAAyB,CAAC,MAAM,CAAC,WAAW,CAAC,EAAE;QAClD,MAAM,IAAI,KAAK,CAAC,4DAA4D,CAAC,CAAA;KAC9E;IAED,MAAM,MAAM,GAAG,kBAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;IAEhC,MAAM,aAAa,GAAG,MAAM,CAAC,kBAAkB,EAAE,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAA;IAEnE,MAAM,UAAU,GAAG,MAAM,CAAC,eAAe,EAAE,CAAC,QAAQ,EAAE,CAAA;IACtD,MAAM,SAAS,GAAG,MAAM,CAAC,kBAAkB,EAAE,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAA;IAE9D,OAAO,EAAE,aAAa,EAAE,UAAU,EAAE,SAAS,EAAE,CAAA;AACjD,CAAC,CAAA;AAuEC,4DAAwB;AArE1B,MAAM,sBAAsB,GAAG,CAAC,QAAuB,EAAU,EAAE;IACjE,MAAM,MAAM,GAAG,IAAI,kBAAM,EAAE,CAAA;IAC3B,MAAM,CAAC,mBAAmB,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,aAAa,EAAE,OAAO,CAAC,CAAC,CAAA;IACxE,MAAM,CAAC,UAAU,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAA;IACtC,MAAM,CAAC,mBAAmB,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC,CAAA;IACnE,OAAO,SAAS,CAAC,mBAAmB,CAAC;QACnC,WAAW,EAAE,yBAAyB;QACtC,IAAI,EAAE,MAAM,CAAC,SAAS,EAAE;KACzB,CAAC,CAAA;AACJ,CAAC,CAAA;AA6DC,wDAAsB;AA3DxB,MAAM,KAAK,GAAG,CAAO,QAA2C,EAA0B,EAAE;IAC1F,MAAM,IAAI,GAAG,MAAM,QAAQ,CAAC,SAAS,CAAC,mBAAmB,CAAC;QACxD,MAAM,EAAE,GAAG;QACX,kBAAkB,EAAE,uBAAuB;QAC3C,SAAS,EAAE,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,6BAA6B,CAAC;QAC/D,WAAW,EAAE,aAAa;QAC1B,IAAI,EAAE,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;KACtB,CAAC,CAAC,CAAA;IAEH,IAAI,IAAI,CAAC,CAAC,CAAC,KAAK,SAAS,CAAC,IAAI,CAAC,eAAe,EAAE;QAC9C,MAAM,EAAE,WAAW,EAAE,OAAO,EAAE,GAAG,SAAS,CAAC,oBAAoB,CAAC,IAAI,CAAC,CAAA;QACrE,KAAK,CAAC,yDAAyD,EAAE,WAAW,EAAE,OAAO,CAAC,CAAA;QACtF,MAAM,IAAI,KAAK,CAAC,iBAAiB,GAAG,OAAO,CAAC,CAAA;KAC7C;SAAM,IAAI,IAAI,CAAC,CAAC,CAAC,KAAK,SAAS,CAAC,IAAI,CAAC,gBAAgB,EAAE;QACtD,KAAK,CAAC,gCAAgC,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,CAAA;QAChD,MAAM,IAAI,KAAK,CAAC,wDAAwD,CAAC,CAAA;KAC1E;IAED,MAAM,EAAE,aAAa,EAAE,UAAU,EAAE,SAAS,EAAE,GAAG,wBAAwB,CAAC,IAAI,CAAC,CAAA;IAE/E,KAAK,CAAC,mEAAmE,EAAE,aAAa,EAAE,UAAU,EAAE,SAAS,CAAC,CAAA;IAEhH,OAAO,EAAE,aAAa,EAAE,UAAU,EAAE,SAAS,EAAE,CAAA;AACjD,CAAC,CAAA,CAAA;AAqCC,sBAAK;AA7BP,MAAM,KAAK,GAAG,CAAO,EAAE,aAAa,EAAE,OAAO,EAAE,aAAa,EAAiB,EAAmB,EAAE;IAChG,IAAI;QAEF,uBAAuB,CAAC,aAAa,CAAC,CAAA;QAKtC,MAAM,IAAI,GAAG,MAAM,OAAO,CAAC,EAAE,CAAC,CAAA;QAE9B,OAAO,sBAAsB,CAAC,IAAI,CAAC,CAAA;KACpC;IAAC,OAAO,GAAG,EAAE;QACZ,MAAM,OAAO,GAAG,CAAC,GAAG,IAAI,OAAO,GAAG,KAAK,QAAQ,IAAI,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,CAAA;QAC/E,KAAK,CAAC,8CAA8C,EAAE,OAAO,CAAC,CAAA;QAE9D,OAAO,SAAS,CAAC,kBAAkB,CAAC;YAClC,IAAI,EAAE,KAAK;YACX,OAAO,EAAE,CAAC,GAAG,IAAI,OAAO,GAAG,KAAK,QAAQ,IAAI,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,mBAAmB;YAC5F,WAAW,EAAE,aAAa;YAC1B,IAAI,EAAE,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;SACtB,CAAC,CAAA;KACH;AACH,CAAC,CAAA,CAAA;AAQC,sBAAK","sourcesContent":["import * as IlpPacket from 'ilp-packet'\nimport { Reader, Writer } from 'oer-utils'\nconst debug = require('debug')('ilp-protocol-ildcp')\n\nconst ILDCP_DESTINATION = 'peer.config'\nconst PEER_PROTOCOL_FULFILLMENT = Buffer.alloc(32)\nconst PEER_PROTOCOL_CONDITION = Buffer.from('Zmh6rfhivXdsj8GLjp+OIAiXFIVu4jOzkCpZHQ1fKSU=', 'base64')\nconst PEER_PROTOCOL_EXPIRY_DURATION = 60000\n\nexport interface IldcpRequest {\n  // empty for now\n}\n\nexport interface IldcpResponse {\n  clientAddress: string,\n  assetScale: number,\n  assetCode: string\n}\n\nconst deserializeIldcpRequest = (request: Buffer): IldcpRequest => {\n  const ilp = IlpPacket.deserializeIlpPrepare(request)\n\n  if (ilp.destination !== ILDCP_DESTINATION) {\n    throw new TypeError('packet is not an IL-DCP request.')\n  }\n\n  if (!PEER_PROTOCOL_CONDITION.equals(ilp.executionCondition)) {\n    throw new Error('packet does not contain correct condition for a peer protocol request.')\n  }\n\n  if (Date.now() > Number(ilp.expiresAt)) {\n    throw new Error('IL-DCP request packet is expired.')\n  }\n\n  return {}\n}\n\nconst serializeIldcpRequest = (request: IldcpRequest): Buffer => {\n  return IlpPacket.serializeIlpPrepare({\n    amount: '0',\n    destination: ILDCP_DESTINATION,\n    executionCondition: PEER_PROTOCOL_CONDITION,\n    expiresAt: new Date(Date.now() + PEER_PROTOCOL_EXPIRY_DURATION),\n    data: Buffer.alloc(0)\n  })\n}\n\nconst deserializeIldcpResponse = (response: Buffer): IldcpResponse => {\n  const { fulfillment, data } = IlpPacket.deserializeIlpFulfill(response)\n\n  if (!PEER_PROTOCOL_FULFILLMENT.equals(fulfillment)) {\n    throw new Error('IL-DCP response does not contain the expected fulfillment.')\n  }\n\n  const reader = Reader.from(data)\n\n  const clientAddress = reader.readVarOctetString().toString('ascii')\n\n  const assetScale = reader.readUInt8BigNum().toNumber()\n  const assetCode = reader.readVarOctetString().toString('utf8')\n\n  return { clientAddress, assetScale, assetCode }\n}\n\nconst serializeIldcpResponse = (response: IldcpResponse): Buffer => {\n  const writer = new Writer()\n  writer.writeVarOctetString(Buffer.from(response.clientAddress, 'ascii'))\n  writer.writeUInt8(response.assetScale)\n  writer.writeVarOctetString(Buffer.from(response.assetCode, 'utf8'))\n  return IlpPacket.serializeIlpFulfill({\n    fulfillment: PEER_PROTOCOL_FULFILLMENT,\n    data: writer.getBuffer()\n  })\n}\n\nconst fetch = async (sendData: (data: Buffer) => Promise<Buffer>): Promise<IldcpResponse> => {\n  const data = await sendData(IlpPacket.serializeIlpPrepare({\n    amount: '0',\n    executionCondition: PEER_PROTOCOL_CONDITION,\n    expiresAt: new Date(Date.now() + PEER_PROTOCOL_EXPIRY_DURATION),\n    destination: 'peer.config',\n    data: Buffer.alloc(0)\n  }))\n\n  if (data[0] === IlpPacket.Type.TYPE_ILP_REJECT) {\n    const { triggeredBy, message } = IlpPacket.deserializeIlpReject(data)\n    debug('IL-DCP request rejected. triggeredBy=%s errorMessage=%s', triggeredBy, message)\n    throw new Error('IL-DCP failed: ' + message)\n  } else if (data[0] !== IlpPacket.Type.TYPE_ILP_FULFILL) {\n    debug('invalid response type. type=%s', data[0])\n    throw new Error('IL-DCP error, unable to retrieve client configuration.')\n  }\n\n  const { clientAddress, assetScale, assetCode } = deserializeIldcpResponse(data)\n\n  debug('received client info. clientAddress=%s assetScale=%s assetCode=%s', clientAddress, assetScale, assetCode)\n\n  return { clientAddress, assetScale, assetCode }\n}\n\nexport interface ServeSettings {\n  requestPacket: Buffer,\n  handler: (request: IldcpRequest) => Promise<IldcpResponse>,\n  serverAddress: string\n}\n\nconst serve = async ({ requestPacket, handler, serverAddress }: ServeSettings): Promise<Buffer> => {\n  try {\n    // Parse the request packet just to make sure it's valid\n    deserializeIldcpRequest(requestPacket)\n\n    // In the future, the request packet may contain some parameters. We will pass\n    // these to the handler as an object, the handler will then return the\n    // response as a JavaScript object.\n    const info = await handler({})\n\n    return serializeIldcpResponse(info)\n  } catch (err) {\n    const errInfo = (err && typeof err === 'object' && err.stack) ? err.stack : err\n    debug('error while handling ildcp request. error=%s', errInfo)\n\n    return IlpPacket.serializeIlpReject({\n      code: 'F00',\n      message: (err && typeof err === 'object' && err.message) ? err.message : 'unexpected error.',\n      triggeredBy: serverAddress,\n      data: Buffer.alloc(0)\n    })\n  }\n}\n\nexport {\n  deserializeIldcpRequest,\n  serializeIldcpRequest,\n  deserializeIldcpResponse,\n  serializeIldcpResponse,\n  fetch,\n  serve\n}\n"]}