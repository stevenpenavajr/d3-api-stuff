"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const oer_utils_1 = require("oer-utils");
const date_1 = require("./src/utils/date");
const Long = require("long");
const assert = require("assert");
const errors = require("./src/errors");
exports.Errors = errors;
var Type;
(function (Type) {
    Type[Type["TYPE_ILP_PREPARE"] = 12] = "TYPE_ILP_PREPARE";
    Type[Type["TYPE_ILP_FULFILL"] = 13] = "TYPE_ILP_FULFILL";
    Type[Type["TYPE_ILP_REJECT"] = 14] = "TYPE_ILP_REJECT";
})(Type = exports.Type || (exports.Type = {}));
exports.errorToReject = (address, error) => {
    return exports.serializeIlpReject({
        code: error.ilpErrorCode || 'F00',
        triggeredBy: address,
        message: error.message || '',
        data: error.ilpErrorData || Buffer.alloc(0)
    });
};
exports.serializeEnvelope = (type, contents) => {
    const writer = new oer_utils_1.Writer();
    writer.writeUInt8(type);
    writer.writeVarOctetString(contents);
    return writer.getBuffer();
};
exports.deserializeEnvelope = (binary) => {
    const envelopeReader = oer_utils_1.Reader.from(binary);
    const type = envelopeReader.readUInt8();
    const contents = envelopeReader.readVarOctetString();
    return { type, contents };
};
exports.serializeIlpPrepare = (json) => {
    assert(json.amount && typeof json.amount === 'string', 'amount must be a string');
    assert(Buffer.isBuffer(json.executionCondition) &&
        json.executionCondition.length === 32, 'executionCondition must be a 32-byte buffer');
    assert(json.expiresAt && json.expiresAt instanceof Date, 'expiresAt must be a Date');
    assert(typeof json.destination === 'string', 'destination is required');
    assert(!json.data || Buffer.isBuffer(json.data), 'data must be a buffer');
    const writer = new oer_utils_1.Writer();
    const amount = Long.fromString(json.amount, true);
    writer.writeUInt32(amount.getHighBitsUnsigned());
    writer.writeUInt32(amount.getLowBitsUnsigned());
    writer.write(Buffer.from(date_1.dateToInterledgerTime(json.expiresAt), 'ascii'));
    writer.write(json.executionCondition);
    writer.writeVarOctetString(Buffer.from(json.destination, 'ascii'));
    writer.writeVarOctetString(json.data);
    return exports.serializeEnvelope(Type.TYPE_ILP_PREPARE, writer.getBuffer());
};
exports.deserializeIlpPrepare = (binary) => {
    const { type, contents } = exports.deserializeEnvelope(binary);
    if (+type !== Type.TYPE_ILP_PREPARE) {
        throw new Error('Packet has incorrect type');
    }
    const reader = oer_utils_1.Reader.from(contents);
    const highBits = reader.readUInt32();
    const lowBits = reader.readUInt32();
    const amount = Long.fromBits(+lowBits, +highBits, true).toString();
    const expiresAt = date_1.interledgerTimeToDate(reader.read(date_1.INTERLEDGER_TIME_LENGTH).toString('ascii'));
    const executionCondition = reader.read(32);
    const destination = reader.readVarOctetString().toString('ascii');
    const data = reader.readVarOctetString();
    return {
        amount,
        executionCondition,
        expiresAt,
        destination,
        data
    };
};
exports.serializeIlpFulfill = (json) => {
    assert(Buffer.isBuffer(json.fulfillment) &&
        json.fulfillment.length === 32, 'fulfillment must be a 32-byte buffer');
    assert(!json.data || Buffer.isBuffer(json.data), 'data must be a buffer');
    const writer = new oer_utils_1.Writer();
    writer.write(json.fulfillment);
    writer.writeVarOctetString(json.data);
    return exports.serializeEnvelope(Type.TYPE_ILP_FULFILL, writer.getBuffer());
};
exports.deserializeIlpFulfill = (binary) => {
    const { type, contents } = exports.deserializeEnvelope(binary);
    if (+type !== Type.TYPE_ILP_FULFILL) {
        throw new Error('Packet has incorrect type');
    }
    const reader = oer_utils_1.Reader.from(contents);
    const fulfillment = reader.read(32);
    const data = reader.readVarOctetString();
    return {
        fulfillment,
        data
    };
};
const ILP_ERROR_CODE_LENGTH = 3;
exports.serializeIlpReject = (json) => {
    assert(json.code && typeof json.code === 'string', 'code must be a string');
    assert(typeof json.triggeredBy === 'string', 'triggeredBy must be a string');
    assert(typeof json.message === 'string', 'message must be a string');
    assert(!json.data || Buffer.isBuffer(json.data), 'data must be a buffer');
    const writer = new oer_utils_1.Writer();
    const codeBuffer = Buffer.from(json.code, 'ascii');
    if (codeBuffer.length !== ILP_ERROR_CODE_LENGTH) {
        throw new Error('ILP error codes must be three bytes long, received: ' + json.code);
    }
    writer.write(codeBuffer);
    writer.writeVarOctetString(Buffer.from(json.triggeredBy, 'ascii'));
    writer.writeVarOctetString(Buffer.from(json.message, 'utf8'));
    writer.writeVarOctetString(json.data || Buffer.alloc(0));
    return exports.serializeEnvelope(Type.TYPE_ILP_REJECT, writer.getBuffer());
};
exports.deserializeIlpReject = (binary) => {
    const { type, contents } = exports.deserializeEnvelope(binary);
    if (+type !== Type.TYPE_ILP_REJECT) {
        throw new Error('Packet has incorrect type');
    }
    const reader = oer_utils_1.Reader.from(contents);
    const code = reader.read(ILP_ERROR_CODE_LENGTH).toString('ascii');
    const triggeredBy = reader.readVarOctetString().toString('ascii');
    const message = reader.readVarOctetString().toString('utf8');
    const data = reader.readVarOctetString();
    return {
        code,
        triggeredBy,
        message,
        data
    };
};
exports.serializeIlpPacket = (obj) => {
    switch (obj.type) {
        case Type.TYPE_ILP_PREPARE: return exports.serializeIlpPrepare(obj.data);
        case Type.TYPE_ILP_FULFILL: return exports.serializeIlpFulfill(obj.data);
        case Type.TYPE_ILP_REJECT: return exports.serializeIlpReject(obj.data);
        default: throw new Error('Object has invalid type');
    }
};
exports.deserializeIlpPacket = (binary) => {
    let packet;
    let typeString;
    switch (binary[0]) {
        case Type.TYPE_ILP_PREPARE:
            packet = exports.deserializeIlpPrepare(binary);
            typeString = 'ilp_prepare';
            break;
        case Type.TYPE_ILP_FULFILL:
            packet = exports.deserializeIlpFulfill(binary);
            typeString = 'ilp_fulfill';
            break;
        case Type.TYPE_ILP_REJECT:
            packet = exports.deserializeIlpReject(binary);
            typeString = 'ilp_reject';
            break;
        default:
            throw new Error('Packet has invalid type');
    }
    return {
        type: binary[0],
        typeString,
        data: packet
    };
};
//# sourceMappingURL=index.js.map