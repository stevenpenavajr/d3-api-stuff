{"version":3,"file":"index.js","sourceRoot":"","sources":["../index.ts"],"names":[],"mappings":"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","sourcesContent":["import { Reader, Writer } from 'oer-utils'\nimport {\n  dateToInterledgerTime,\n  interledgerTimeToDate,\n  INTERLEDGER_TIME_LENGTH\n} from './src/utils/date'\nimport Long = require('long')\nimport * as assert from 'assert'\n\nimport * as errors from './src/errors'\nexport const Errors = errors\n\nexport enum Type {\n  TYPE_ILP_PREPARE = 12,\n  TYPE_ILP_FULFILL = 13,\n  TYPE_ILP_REJECT = 14\n}\n\nexport interface IlpErrorClass {\n  message: string,\n  ilpErrorCode?: string,\n  ilpErrorData?: Buffer\n}\n\nexport const errorToReject = (address: string, error: IlpErrorClass) => {\n  return serializeIlpReject({\n    code: error.ilpErrorCode || 'F00',\n    triggeredBy: address,\n    message: error.message || '',\n    data: error.ilpErrorData || Buffer.alloc(0)\n  })\n}\n\nexport const serializeEnvelope = (type: number, contents: Buffer) => {\n  const writer = new Writer()\n  writer.writeUInt8(type)\n  writer.writeVarOctetString(contents)\n  return writer.getBuffer()\n}\n\nexport const deserializeEnvelope = (binary: Buffer) => {\n  const envelopeReader = Reader.from(binary)\n  const type = envelopeReader.readUInt8()\n  const contents = envelopeReader.readVarOctetString()\n\n  return { type, contents }\n}\n\nexport interface IlpPacket {\n  type: Type,\n  data: any\n}\n\nexport interface IlpPrepare {\n  amount: string,\n  executionCondition: Buffer,\n  expiresAt: Date,\n  destination: string,\n  data: Buffer\n}\n\nexport const serializeIlpPrepare = (json: IlpPrepare) => {\n  assert(json.amount && typeof json.amount === 'string', 'amount must be a string')\n  assert(Buffer.isBuffer(json.executionCondition) &&\n    json.executionCondition.length === 32, 'executionCondition must be a 32-byte buffer')\n  assert(json.expiresAt && json.expiresAt instanceof Date, 'expiresAt must be a Date')\n  assert(typeof json.destination === 'string', 'destination is required')\n  assert(!json.data || Buffer.isBuffer(json.data), 'data must be a buffer')\n\n  const writer = new Writer()\n\n  const amount = Long.fromString(json.amount, true)\n  writer.writeUInt32(amount.getHighBitsUnsigned())\n  writer.writeUInt32(amount.getLowBitsUnsigned())\n  writer.write(Buffer.from(dateToInterledgerTime(json.expiresAt), 'ascii'))\n  writer.write(json.executionCondition)\n  writer.writeVarOctetString(Buffer.from(json.destination, 'ascii'))\n  writer.writeVarOctetString(json.data)\n\n  return serializeEnvelope(Type.TYPE_ILP_PREPARE, writer.getBuffer())\n}\n\nexport const deserializeIlpPrepare = (binary: Buffer): IlpPrepare => {\n  const { type, contents } = deserializeEnvelope(binary)\n\n  if (+type !== Type.TYPE_ILP_PREPARE) {\n    throw new Error('Packet has incorrect type')\n  }\n\n  const reader = Reader.from(contents)\n  const highBits = reader.readUInt32()\n  const lowBits = reader.readUInt32()\n  const amount = Long.fromBits(+lowBits, +highBits, true).toString()\n  const expiresAt = interledgerTimeToDate(reader.read(INTERLEDGER_TIME_LENGTH).toString('ascii'))\n  const executionCondition = reader.read(32)\n  const destination = reader.readVarOctetString().toString('ascii')\n  const data = reader.readVarOctetString()\n\n  return {\n    amount,\n    executionCondition,\n    expiresAt,\n    destination,\n    data\n  }\n}\n\nexport interface IlpFulfill {\n  fulfillment: Buffer,\n  data: Buffer\n}\n\nexport const serializeIlpFulfill = (json: IlpFulfill) => {\n  assert(Buffer.isBuffer(json.fulfillment) &&\n    json.fulfillment.length === 32, 'fulfillment must be a 32-byte buffer')\n  assert(!json.data || Buffer.isBuffer(json.data), 'data must be a buffer')\n\n  const writer = new Writer()\n  writer.write(json.fulfillment)\n  writer.writeVarOctetString(json.data)\n\n  return serializeEnvelope(Type.TYPE_ILP_FULFILL, writer.getBuffer())\n}\n\nexport const deserializeIlpFulfill = (binary: Buffer): IlpFulfill => {\n  const { type, contents } = deserializeEnvelope(binary)\n\n  if (+type !== Type.TYPE_ILP_FULFILL) {\n    throw new Error('Packet has incorrect type')\n  }\n\n  const reader = Reader.from(contents)\n  const fulfillment = reader.read(32)\n  const data = reader.readVarOctetString()\n\n  return {\n    fulfillment,\n    data\n  }\n}\n\nconst ILP_ERROR_CODE_LENGTH = 3\n\nexport interface IlpReject {\n  code: string,\n  triggeredBy: string,\n  message: string,\n  data: Buffer\n}\n\nexport const serializeIlpReject = (json: IlpReject) => {\n  assert(json.code && typeof json.code === 'string', 'code must be a string')\n  assert(typeof json.triggeredBy === 'string', 'triggeredBy must be a string')\n  assert(typeof json.message === 'string', 'message must be a string')\n  assert(!json.data || Buffer.isBuffer(json.data), 'data must be a buffer')\n\n  const writer = new Writer()\n\n  // Convert code to buffer to ensure we are counting bytes, not UTF8 characters\n  const codeBuffer = Buffer.from(json.code, 'ascii')\n  if (codeBuffer.length !== ILP_ERROR_CODE_LENGTH) {\n    throw new Error('ILP error codes must be three bytes long, received: ' + json.code)\n  }\n\n  writer.write(codeBuffer)\n  writer.writeVarOctetString(Buffer.from(json.triggeredBy, 'ascii'))\n  writer.writeVarOctetString(Buffer.from(json.message, 'utf8'))\n  writer.writeVarOctetString(json.data || Buffer.alloc(0))\n\n  return serializeEnvelope(Type.TYPE_ILP_REJECT, writer.getBuffer())\n}\n\nexport const deserializeIlpReject = (binary: Buffer): IlpReject => {\n  const { type, contents } = deserializeEnvelope(binary)\n\n  if (+type !== Type.TYPE_ILP_REJECT) {\n    throw new Error('Packet has incorrect type')\n  }\n\n  const reader = Reader.from(contents)\n  const code = reader.read(ILP_ERROR_CODE_LENGTH).toString('ascii')\n  const triggeredBy = reader.readVarOctetString().toString('ascii')\n  const message = reader.readVarOctetString().toString('utf8')\n  const data = reader.readVarOctetString()\n\n  return {\n    code,\n    triggeredBy,\n    message,\n    data\n  }\n}\n\nexport const serializeIlpPacket = (obj: IlpPacket) => {\n  switch (obj.type) {\n    case Type.TYPE_ILP_PREPARE: return serializeIlpPrepare(obj.data)\n    case Type.TYPE_ILP_FULFILL: return serializeIlpFulfill(obj.data)\n    case Type.TYPE_ILP_REJECT: return serializeIlpReject(obj.data)\n    default: throw new Error('Object has invalid type')\n  }\n}\n\nexport const deserializeIlpPacket = (binary: Buffer) => {\n  let packet\n  let typeString\n  switch (binary[0]) {\n    case Type.TYPE_ILP_PREPARE:\n      packet = deserializeIlpPrepare(binary)\n      typeString = 'ilp_prepare'\n      break\n    case Type.TYPE_ILP_FULFILL:\n      packet = deserializeIlpFulfill(binary)\n      typeString = 'ilp_fulfill'\n      break\n    case Type.TYPE_ILP_REJECT:\n      packet = deserializeIlpReject(binary)\n      typeString = 'ilp_reject'\n      break\n    default:\n      throw new Error('Packet has invalid type')\n  }\n  return {\n    type: binary[0],\n    typeString,\n    data: packet\n  }\n}\n"]}