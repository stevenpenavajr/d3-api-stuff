{"version":3,"file":"protocol-data-converter.js","sourceRoot":"","sources":["protocol-data-converter.ts"],"names":[],"mappings":";;AACA,MAAM,GAAG,GAAG,OAAO,CAAC,YAAY,CAAC,CAAA;AAOjC,SAAgB,0BAA0B,CAAE,IAA6C;IACvF,MAAM,WAAW,GAAG,EAAE,CAAA;IACtB,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,CAAA;IAE7B,KAAK,MAAM,QAAQ,IAAI,YAAY,EAAE;QACnC,MAAM,IAAI,GAAG,QAAQ,CAAC,YAAY,CAAA;QAElC,IAAI,QAAQ,CAAC,WAAW,KAAK,GAAG,CAAC,oBAAoB,EAAE;YACrD,WAAW,CAAC,IAAI,CAAC,GAAG,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAA;SACnD;aAAM,IAAI,QAAQ,CAAC,WAAW,KAAK,GAAG,CAAC,qBAAqB,EAAE;YAC7D,WAAW,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAA;SAC/D;aAAM;YACL,WAAW,CAAC,IAAI,CAAC,GAAG,QAAQ,CAAC,IAAI,CAAA;SAClC;KACF;IAED,OAAO;QACL,WAAW;QACX,GAAG,EAAE,WAAW,CAAC,KAAK,CAAC;QACvB,MAAM,EAAE,WAAW,CAAC,QAAQ,CAAC;KAC9B,CAAA;AACH,CAAC;AArBD,gEAqBC;AAOD,SAAgB,0BAA0B,CAAE,IAA6F;IACvI,MAAM,YAAY,GAAG,EAAE,CAAA;IACvB,MAAM,EAAE,GAAG,EAAE,MAAM,EAAE,WAAW,EAAE,GAAG,IAAI,CAAA;IAGzC,IAAI,GAAG,EAAE;QACP,YAAY,CAAC,IAAI,CAAC;YAChB,YAAY,EAAE,KAAK;YACnB,WAAW,EAAE,GAAG,CAAC,6BAA6B;YAE9C,IAAI,EAAE,GAAG;SACV,CAAC,CAAA;KACH;IAGD,IAAI,WAAW,EAAE;QACf,MAAM,aAAa,GAAG,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,CAAA;QAC9C,KAAK,MAAM,QAAQ,IAAI,aAAa,EAAE;YACpC,IAAI,MAAM,CAAC,QAAQ,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC,EAAE;gBAC1C,YAAY,CAAC,IAAI,CAAC;oBAChB,YAAY,EAAE,QAAQ;oBACtB,WAAW,EAAE,GAAG,CAAC,6BAA6B;oBAC9C,IAAI,EAAE,WAAW,CAAC,QAAQ,CAAC;iBAC5B,CAAC,CAAA;aACH;iBAAM,IAAI,OAAO,WAAW,CAAC,QAAQ,CAAC,KAAK,QAAQ,EAAE;gBACpD,YAAY,CAAC,IAAI,CAAC;oBAChB,YAAY,EAAE,QAAQ;oBACtB,WAAW,EAAE,GAAG,CAAC,oBAAoB;oBACrC,IAAI,EAAE,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;iBACzC,CAAC,CAAA;aACH;iBAAM;gBACL,YAAY,CAAC,IAAI,CAAC;oBAChB,YAAY,EAAE,QAAQ;oBACtB,WAAW,EAAE,GAAG,CAAC,qBAAqB;oBACtC,IAAI,EAAE,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC,CAAC;iBACzD,CAAC,CAAA;aACH;SACF;KACF;IAID,IAAI,MAAM,EAAE;QACV,YAAY,CAAC,IAAI,CAAC;YAChB,YAAY,EAAE,QAAQ;YACtB,WAAW,EAAE,GAAG,CAAC,qBAAqB;YACtC,IAAI,EAAE,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;SAC1C,CAAC,CAAA;KACH;IAED,OAAO,YAAY,CAAA;AACrB,CAAC;AAnDD,gEAmDC","sourcesContent":["import { BtpSubProtocol } from '.'\nconst Btp = require('btp-packet')\n\n/**\n * Convert BTP protocol array to a protocol map of all the protocols inside the\n * BTP sub protocol array. Also specifically extract the `ilp` and `custom` protocols\n * from the map.\n */\nexport function protocolDataToIlpAndCustom (data: { protocolData: Array<BtpSubProtocol> }) {\n  const protocolMap = {}\n  const { protocolData } = data\n\n  for (const protocol of protocolData) {\n    const name = protocol.protocolName\n\n    if (protocol.contentType === Btp.MIME_TEXT_PLAIN_UTF8) {\n      protocolMap[name] = protocol.data.toString('utf8')\n    } else if (protocol.contentType === Btp.MIME_APPLICATION_JSON) {\n      protocolMap[name] = JSON.parse(protocol.data.toString('utf8'))\n    } else {\n      protocolMap[name] = protocol.data\n    }\n  }\n\n  return {\n    protocolMap,\n    ilp: protocolMap['ilp'],\n    custom: protocolMap['custom']\n  }\n}\n\n/** Convert `ilp` and `custom` protocol data, along with a protocol map, into\n * an array of BTP sub protocols. Order of precedence in the BTP sub protocol\n * array is: `ilp`, any explicitly defined sub protocols (the ones in the\n * protocol map), and finally `custom`.\n */\nexport function ilpAndCustomToProtocolData (data: { ilp?: Buffer, custom?: Object , protocolMap?: Map<string, Buffer | string | Object> }): Array<BtpSubProtocol> {\n  const protocolData = []\n  const { ilp, custom, protocolMap } = data\n\n  // ILP is always the primary protocol when it's specified\n  if (ilp) {\n    protocolData.push({\n      protocolName: 'ilp',\n      contentType: Btp.MIME_APPLICATION_OCTET_STREAM,\n      // TODO JS originally had a Buffer.from(ilp, 'base64')?\n      data: ilp\n    })\n  }\n\n  // explicitly specified sub-protocols come next\n  if (protocolMap) {\n    const sideProtocols = Object.keys(protocolMap)\n    for (const protocol of sideProtocols) {\n      if (Buffer.isBuffer(protocolMap[protocol])) {\n        protocolData.push({\n          protocolName: protocol,\n          contentType: Btp.MIME_APPLICATION_OCTET_STREAM,\n          data: protocolMap[protocol]\n        })\n      } else if (typeof protocolMap[protocol] === 'string') {\n        protocolData.push({\n          protocolName: protocol,\n          contentType: Btp.MIME_TEXT_PLAIN_UTF8,\n          data: Buffer.from(protocolMap[protocol])\n        })\n      } else {\n        protocolData.push({\n          protocolName: protocol,\n          contentType: Btp.MIME_APPLICATION_JSON,\n          data: Buffer.from(JSON.stringify(protocolMap[protocol]))\n        })\n      }\n    }\n  }\n\n  // the \"custom\" side protocol is always secondary unless its the only sub\n  // protocol.\n  if (custom) {\n    protocolData.push({\n      protocolName: 'custom',\n      contentType: Btp.MIME_APPLICATION_JSON,\n      data: Buffer.from(JSON.stringify(custom))\n    })\n  }\n\n  return protocolData\n}\n"]}