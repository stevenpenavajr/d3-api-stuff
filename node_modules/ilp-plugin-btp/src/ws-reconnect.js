"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const createLogger = require('ilp-logger');
const eventemitter2_1 = require("eventemitter2");
const debug = createLogger('ilp-ws-reconnect');
const DEFAULT_TRY_CLEAR_TIMEOUT = 10000;
const DEFAULT_RECONNECT_INTERVALS = [
    0,
    100,
    500,
    1000,
    2000,
    5000
];
class WebSocketReconnector extends eventemitter2_1.EventEmitter2 {
    constructor(options) {
        super();
        this.WebSocket = options.WebSocket;
        this._clearTryTimeout = options.clearTryTimeout ||
            DEFAULT_TRY_CLEAR_TIMEOUT;
        this._tries = 0;
        this._intervals = options.intervals ||
            (options.interval && [options.interval]) ||
            DEFAULT_RECONNECT_INTERVALS;
    }
    open(url) {
        this._url = url;
        this._instance = new (this.WebSocket)(this._url);
        this._instance.on('open', () => void this.emit('open'));
        this._instance.on('close', (code, reason) => this._reconnect(code));
        this._instance.on('error', (err) => this._reconnect(err));
        this._instance.on('message', (data) => void this.emit('message', data));
        return new Promise((resolve) => void this.once('open', resolve));
    }
    send(data, cb) {
        return this._instance.send(data, cb);
    }
    close() {
        this._instance.removeAllListeners();
        this.emit('close');
        this._instance.close();
        if (this._openTimer)
            clearTimeout(this._openTimer);
        if (this._clearTryTimer)
            clearTimeout(this._clearTryTimer);
    }
    _reconnect(codeOrError) {
        debug.debug(`websocket disconnected with ${codeOrError}; reconnect in ${this._intervals[this._tries]}}`);
        this._connected = false;
        this._instance.removeAllListeners();
        this._openTimer = setTimeout(() => {
            void this.open(this._url);
        }, this._intervals[this._tries]);
        this._tries = Math.min(this._tries + 1, this._intervals.length - 1);
        if (this._clearTryTimer) {
            clearTimeout(this._clearTryTimer);
        }
        this._clearTryTimer = setTimeout(() => {
            delete this._clearTryTimer;
            this._tries = 0;
        }, this._clearTryTimeout);
        if (typeof this._clearTryTimer.unref === 'function') {
            this._clearTryTimer.unref();
        }
        this.emit('close');
    }
}
exports.WebSocketReconnector = WebSocketReconnector;
//# sourceMappingURL=ws-reconnect.js.map