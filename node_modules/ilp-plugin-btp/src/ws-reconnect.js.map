{"version":3,"file":"ws-reconnect.js","sourceRoot":"","sources":["ws-reconnect.ts"],"names":[],"mappings":";;AACA,MAAM,YAAY,GAAG,OAAO,CAAC,YAAY,CAAC,CAAA;AAC1C,iDAA6C;AAC7C,MAAM,KAAK,GAAG,YAAY,CAAC,kBAAkB,CAAC,CAAA;AAE9C,MAAM,yBAAyB,GAAG,KAAK,CAAA;AACvC,MAAM,2BAA2B,GAAG;IAClC,CAAC;IACD,GAAG;IACH,GAAG;IACH,IAAI;IACJ,IAAI;IACJ,IAAI;CACL,CAAA;AAuBD,MAAa,oBAAqB,SAAQ,6BAAa;IAgCrD,YAAa,OAA+C;QAC1D,KAAK,EAAE,CAAA;QACP,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,SAAS,CAAA;QAElC,IAAI,CAAC,gBAAgB,GAAG,OAAO,CAAC,eAAe;YAC7C,yBAAyB,CAAA;QAE3B,IAAI,CAAC,MAAM,GAAG,CAAC,CAAA;QACf,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC,SAAS;YACjC,CAAC,OAAO,CAAC,QAAQ,IAAI,CAAE,OAAO,CAAC,QAAQ,CAAE,CAAC;YAC1C,2BAA2B,CAAA;IAC/B,CAAC;IAQD,IAAI,CAAE,GAAW;QACf,IAAI,CAAC,IAAI,GAAG,GAAG,CAAA;QACf,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;QAChD,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC,MAAM,EAAE,GAAG,EAAE,CAAC,KAAK,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAA;QACvD,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC,IAAY,EAAE,MAAc,EAAE,EAAE,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAA;QACnF,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC,GAAU,EAAE,EAAE,CAAC,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,CAAA;QAChE,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC,SAAS,EAAE,CAAC,IAAoB,EAAE,EAAE,CAAC,KAAK,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC,CAAA;QACvF,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,KAAK,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC,CAAA;IAClE,CAAC;IAKD,IAAI,CAAE,IAAS,EAAE,EAA0B;QACzC,OAAO,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,CAAC,CAAA;IACtC,CAAC;IAOD,KAAK;QACH,IAAI,CAAC,SAAS,CAAC,kBAAkB,EAAE,CAAA;QACnC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAA;QAClB,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,CAAA;QAEtB,IAAI,IAAI,CAAC,UAAU;YAAE,YAAY,CAAC,IAAI,CAAC,UAAU,CAAC,CAAA;QAClD,IAAI,IAAI,CAAC,cAAc;YAAE,YAAY,CAAC,IAAI,CAAC,cAAc,CAAC,CAAA;IAC5D,CAAC;IAQO,UAAU,CAAE,WAA2B;QAC7C,KAAK,CAAC,KAAK,CAAC,+BAA+B,WAAW,kBAAkB,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAA;QACxG,IAAI,CAAC,UAAU,GAAG,KAAK,CAAA;QACvB,IAAI,CAAC,SAAS,CAAC,kBAAkB,EAAE,CAAA;QACnC,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC,GAAG,EAAE;YAChC,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;QAC3B,CAAC,EAAE,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAA;QAChC,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE,IAAI,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC,CAAA;QAEnE,IAAI,IAAI,CAAC,cAAc,EAAE;YACvB,YAAY,CAAC,IAAI,CAAC,cAAc,CAAC,CAAA;SAClC;QAED,IAAI,CAAC,cAAc,GAAG,UAAU,CAAC,GAAG,EAAE;YACpC,OAAO,IAAI,CAAC,cAAc,CAAA;YAC1B,IAAI,CAAC,MAAM,GAAG,CAAC,CAAA;QACjB,CAAC,EAAE,IAAI,CAAC,gBAAgB,CAAC,CAAA;QAIzB,IAAI,OAAO,IAAI,CAAC,cAAc,CAAC,KAAK,KAAK,UAAU,EAAE;YACnD,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE,CAAA;SAC5B;QAED,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAA;IACpB,CAAC;CACF;AAlHD,oDAkHC","sourcesContent":["import * as WebSocket from 'ws'\nconst createLogger = require('ilp-logger')\nimport { EventEmitter2 } from 'eventemitter2'\nconst debug = createLogger('ilp-ws-reconnect')\n\nconst DEFAULT_TRY_CLEAR_TIMEOUT = 10000\nconst DEFAULT_RECONNECT_INTERVALS = [\n  0,\n  100,\n  500,\n  1000,\n  2000,\n  5000\n]\n\n/**\n * Accepts URL string pointing to connection endpoint.\n */\nexport interface WebSocketConstructor {\n  new (url: string): WebSocket\n}\n\n/**\n * Reconnect interval specifies how long to wait before trying to connect to the\n * websocket endpoint if a connection is not established successfully.\n */\nexport interface WebSocketReconnectorConstructorOptions {\n  intervals?: Array<number>,\n  interval?: number,\n  clearTryTimeout?: number,\n  WebSocket: WebSocketConstructor\n}\n\n/**\n * Websocket clients with reconnect capability.\n */\nexport class WebSocketReconnector extends EventEmitter2 {\n  /**\n   * Reconnect information. Intervals is a list of timeouts for\n   * successive reconnect attempts. `clearTryTimeout` ms after\n   * the last reconnect attempt, the number of tries will reset.\n   */\n  private _intervals: Array<number>\n  private _clearTryTimeout: number\n  private _clearTryTimer?: NodeJS.Timer\n  private _openTimer?: NodeJS.Timer\n  private _tries: number\n\n  /**\n   * URL endpoint of websocket server.\n   */\n  private _url: string\n\n  /**\n   * Websocket connection.\n   */\n  private _instance: WebSocket\n\n  /**\n   * Is websocket connection connected to endpoint?\n   */\n  private _connected: boolean\n\n  /**\n   * Websocket constructor.\n   */\n  private WebSocket: WebSocketConstructor\n\n  constructor (options: WebSocketReconnectorConstructorOptions) {\n    super()\n    this.WebSocket = options.WebSocket\n\n    this._clearTryTimeout = options.clearTryTimeout ||\n      DEFAULT_TRY_CLEAR_TIMEOUT\n\n    this._tries = 0\n    this._intervals = options.intervals ||\n      (options.interval && [ options.interval ]) ||\n      DEFAULT_RECONNECT_INTERVALS\n  }\n\n  /**\n   * Define a number of listeners. On open: emit an open event. On close or\n   * error: try to reconnect. On message, emit a message event with the data.\n   * Return a promise which resolves when the connection is successfully\n   * established (successfully established connection emits `open` event).\n   */\n  open (url: string) {\n    this._url = url\n    this._instance = new (this.WebSocket)(this._url)\n    this._instance.on('open', () => void this.emit('open'))\n    this._instance.on('close', (code: number, reason: string) => this._reconnect(code))\n    this._instance.on('error', (err: Error) => this._reconnect(err))\n    this._instance.on('message', (data: WebSocket.Data) => void this.emit('message', data))\n    return new Promise((resolve) => void this.once('open', resolve))\n  }\n\n  /**\n   * Wrapper for regular websocket send function.\n   */\n  send (data: any, cb?: (err?: Error) => void): void {\n    return this._instance.send(data, cb)\n  }\n\n  /**\n   * Remove all listeners from the websocket instance prior to emitting `close` and\n   * closing the websocket. The listeners were removed so that calling this\n   * `close ()` would not trigger a reconnect.\n   */\n  close () {\n    this._instance.removeAllListeners()\n    this.emit('close')\n    this._instance.close()\n\n    if (this._openTimer) clearTimeout(this._openTimer)\n    if (this._clearTryTimer) clearTimeout(this._clearTryTimer)\n  }\n\n  /**\n   * Triggered on `close` or `error` event from `open ()`. If triggered, all\n   * listeners are removed, reconnect happens. The process continues to try to\n   * reconnect on the interval by calling the `open()' function and cycling\n   * between reconnect to clean up old listeners.\n   */\n  private _reconnect (codeOrError: number | Error) {\n    debug.debug(`websocket disconnected with ${codeOrError}; reconnect in ${this._intervals[this._tries]}}`)\n    this._connected = false\n    this._instance.removeAllListeners()\n    this._openTimer = setTimeout(() => {\n      void this.open(this._url)\n    }, this._intervals[this._tries])\n    this._tries = Math.min(this._tries + 1, this._intervals.length - 1)\n\n    if (this._clearTryTimer) {\n      clearTimeout(this._clearTryTimer)\n    }\n\n    this._clearTryTimer = setTimeout(() => {\n      delete this._clearTryTimer\n      this._tries = 0\n    }, this._clearTryTimeout)\n\n    // browser timers don't support unref\n    /* tslint:disable-next-line:strict-type-predicates */\n    if (typeof this._clearTryTimer.unref === 'function') {\n      this._clearTryTimer.unref()\n    }\n\n    this.emit('close')\n  }\n}\n"]}