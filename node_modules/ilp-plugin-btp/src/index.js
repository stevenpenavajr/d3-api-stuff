"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const crypto = require("crypto");
const Debug = require("debug");
const WebSocket = require("ws");
const ws_reconnect_1 = require("./ws-reconnect");
const eventemitter2_1 = require("eventemitter2");
const url_1 = require("url");
const protocol_data_converter_1 = require("./protocol-data-converter");
const BtpPacket = require('btp-packet');
const debug = require('ilp-logger')('ilp-plugin-btp');
var ReadyState;
(function (ReadyState) {
    ReadyState[ReadyState["INITIAL"] = 0] = "INITIAL";
    ReadyState[ReadyState["CONNECTING"] = 1] = "CONNECTING";
    ReadyState[ReadyState["CONNECTED"] = 2] = "CONNECTED";
    ReadyState[ReadyState["DISCONNECTED"] = 3] = "DISCONNECTED";
    ReadyState[ReadyState["READY_TO_EMIT"] = 4] = "READY_TO_EMIT";
})(ReadyState || (ReadyState = {}));
const DEFAULT_TIMEOUT = 35000;
const namesToCodes = {
    'UnreachableError': 'T00',
    'NotAcceptedError': 'F00',
    'InvalidFieldsError': 'F01',
    'TransferNotFoundError': 'F03',
    'InvalidFulfillmentError': 'F04',
    'DuplicateIdError': 'F05',
    'AlreadyRolledBackError': 'F06',
    'AlreadyFulfilledError': 'F07',
    'InsufficientBalanceError': 'F08'
};
function jsErrorToBtpError(e) {
    const name = e.name || 'NotAcceptedError';
    const code = namesToCodes[name] || 'F00';
    return {
        code,
        name,
        triggeredAt: new Date(),
        data: JSON.stringify({ message: e.message })
    };
}
const ILP_PACKET_TYPES = {
    12: 'ilp-prepare',
    13: 'ilp-fulfill',
    14: 'ilp-reject'
};
function subProtocolToString(data) {
    let stringData;
    switch (data.contentType) {
        case BtpPacket.MIME_APPLICATION_OCTET_STREAM:
            stringData = data.data.toString('base64');
            break;
        case BtpPacket.MIME_APPLICATION_JSON:
        case BtpPacket.MIME_TEXT_PLAIN_UTF8:
            stringData = data.data.toString('utf8');
            break;
    }
    return `${data.protocolName}=${stringData}`;
}
function generatePacketDataTracer(packetData) {
    return {
        toString: () => {
            try {
                return packetData.protocolData.map(data => {
                    switch (data.protocolName) {
                        case 'ilp':
                            return ILP_PACKET_TYPES[data.data[0]] || ('ilp-' + data.data[0]);
                        default:
                            return subProtocolToString(data);
                    }
                }).join(';');
            }
            catch (err) {
                return 'serialization error. err=' + err.stack;
            }
        }
    };
}
class AbstractBtpPlugin extends eventemitter2_1.EventEmitter2 {
    constructor(options, modules) {
        super();
        this._readyState = ReadyState.INITIAL;
        this._wss = null;
        this._reconnectInterval = options.reconnectInterval;
        this._reconnectIntervals = options.reconnectIntervals;
        this._reconnectClearTryTimeout = options.reconnectClearTryTimeout;
        this._responseTimeout = options.responseTimeout || DEFAULT_TIMEOUT;
        this._listener = options.listener;
        this._server = options.server;
        if (this._server) {
            const parsedBtpUri = new url_1.URL(this._server);
            const parsedAccount = parsedBtpUri.username;
            const parsedToken = parsedBtpUri.password;
            if (!parsedBtpUri.protocol.startsWith('btp+')) {
                throw new Error('server must start with "btp+". server=' + this._server);
            }
            if ((parsedAccount || parsedToken) && (options.btpAccount || options.btpToken)) {
                throw new Error('account/token must be passed in via constructor or uri, but not both');
            }
            this._btpToken = parsedToken || options.btpToken || '';
            this._btpAccount = parsedAccount || options.btpAccount || '';
        }
        modules = modules || {};
        this._log = modules.log || debug;
        this._log.trace = this._log.trace || Debug(this._log.debug.namespace + ':trace');
        this.WebSocket = modules.WebSocket || WebSocket;
        this.WebSocketServer = modules.WebSocketServer || WebSocket.Server;
    }
    _connect(...opts) {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    _disconnect() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._readyState > ReadyState.INITIAL) {
                return;
            }
            this._readyState = ReadyState.CONNECTING;
            if (this._listener) {
                const wss = this._wss = new (this.WebSocketServer)({ port: this._listener.port });
                this._incomingWs = undefined;
                wss.on('connection', (socket) => {
                    this._log.info('got connection');
                    let authPacket;
                    socket.on('close', (code) => {
                        this._log.info('incoming websocket closed. code=' + code);
                        this._emitDisconnect();
                    });
                    socket.on('error', (err) => {
                        this._log.debug('incoming websocket error. error=', err);
                        this._emitDisconnect();
                    });
                    socket.once('message', (binaryAuthMessage) => __awaiter(this, void 0, void 0, function* () {
                        try {
                            authPacket = BtpPacket.deserialize(binaryAuthMessage);
                            this._log.trace('got auth packet. packet=%j', authPacket);
                            this._validateAuthPacket(authPacket);
                            if (this._incomingWs) {
                                this._closeIncomingSocket(this._incomingWs, authPacket);
                            }
                            this._incomingWs = socket;
                            socket.send(BtpPacket.serializeResponse(authPacket.requestId, []));
                        }
                        catch (err) {
                            this._incomingWs = undefined;
                            if (authPacket) {
                                const errorResponse = BtpPacket.serializeError({
                                    code: 'F00',
                                    name: 'NotAcceptedError',
                                    data: err.message,
                                    triggeredAt: new Date().toISOString()
                                }, authPacket.requestId, []);
                                socket.send(errorResponse);
                            }
                            socket.close();
                            return;
                        }
                        this._log.trace('connection authenticated');
                        socket.on('message', this._handleIncomingWsMessage.bind(this, socket));
                        this._emitConnect();
                    }));
                });
                this._log.info(`listening for BTP connections on ${this._listener.port}`);
            }
            if (this._server) {
                const parsedBtpUri = new url_1.URL(this._server);
                const account = this._btpAccount || '';
                const token = this._btpToken || '';
                this._ws = new ws_reconnect_1.WebSocketReconnector({
                    WebSocket: this.WebSocket,
                    intervals: this._reconnectIntervals,
                    interval: this._reconnectInterval,
                    clearTryTimeout: this._reconnectClearTryTimeout
                });
                const protocolData = [{
                        protocolName: 'auth',
                        contentType: BtpPacket.MIME_APPLICATION_OCTET_STREAM,
                        data: Buffer.from([])
                    }, {
                        protocolName: 'auth_username',
                        contentType: BtpPacket.MIME_TEXT_PLAIN_UTF8,
                        data: Buffer.from(account, 'utf8')
                    }, {
                        protocolName: 'auth_token',
                        contentType: BtpPacket.MIME_TEXT_PLAIN_UTF8,
                        data: Buffer.from(token, 'utf8')
                    }];
                this._ws.on('open', () => __awaiter(this, void 0, void 0, function* () {
                    this._log.trace('connected to server');
                    this._call('', {
                        type: BtpPacket.TYPE_MESSAGE,
                        requestId: yield _requestId(),
                        data: { protocolData }
                    }).then(() => {
                        this._emitConnect();
                    }).catch((err) => {
                        this._log.error('error authenticating btp connection', err.message);
                    });
                }));
                parsedBtpUri.username = '';
                parsedBtpUri.password = '';
                const wsUri = parsedBtpUri.toString().substring('btp+'.length);
                yield this._ws.open(wsUri);
                this._ws.on('close', () => this._emitDisconnect());
                this._ws.on('message', this._handleIncomingWsMessage.bind(this, this._ws));
            }
            yield new Promise((resolve, reject) => {
                const onDisconnect = () => {
                    if (this._ws)
                        this._ws.close();
                    reject(new Error('connection aborted'));
                };
                this.once('disconnect', onDisconnect);
                this.once('_first_time_connect', () => {
                    this.removeListener('disconnect', onDisconnect);
                    resolve();
                });
            });
            yield this._connect();
            this._readyState = ReadyState.READY_TO_EMIT;
            this._emitConnect();
        });
    }
    _closeIncomingSocket(socket, authPacket) {
        socket.removeAllListeners();
        socket.once('message', (data) => __awaiter(this, void 0, void 0, function* () {
            try {
                socket.send(BtpPacket.serializeError({
                    code: 'F00',
                    name: 'NotAcceptedError',
                    data: 'This connection has been ended because the user has opened a new connection',
                    triggeredAt: new Date().toISOString()
                }, authPacket.requestId, []));
            }
            catch (e) {
                this._log.error('error responding on closed socket', e);
            }
            socket.close();
        }));
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            this._emitDisconnect();
            yield this._disconnect();
            if (this._ws)
                this._ws.close();
            if (this._incomingWs) {
                this._incomingWs.close();
                this._incomingWs = undefined;
            }
            if (this._wss)
                this._wss.close();
        });
    }
    isConnected() {
        return this._readyState === ReadyState.CONNECTED;
    }
    _handleIncomingWsMessage(ws, binaryMessage) {
        return __awaiter(this, void 0, void 0, function* () {
            let btpPacket;
            try {
                btpPacket = BtpPacket.deserialize(binaryMessage);
            }
            catch (err) {
                this._log.error('deserialization error:', err);
                ws.close();
                return;
            }
            try {
                yield this._handleIncomingBtpPacket('', btpPacket);
            }
            catch (err) {
                this._log.debug(`Error processing BTP packet of type ${btpPacket.type}: `, err);
                const error = jsErrorToBtpError(err);
                const requestId = btpPacket.requestId;
                const { code, name, triggeredAt, data } = error;
                yield this._handleOutgoingBtpPacket('', {
                    type: BtpPacket.TYPE_ERROR,
                    requestId,
                    data: {
                        code,
                        name,
                        triggeredAt,
                        data,
                        protocolData: []
                    }
                });
            }
        });
    }
    sendData(buffer) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this._call('', {
                type: BtpPacket.TYPE_MESSAGE,
                requestId: yield _requestId(),
                data: { protocolData: [{
                            protocolName: 'ilp',
                            contentType: BtpPacket.MIME_APPLICATION_OCTET_STREAM,
                            data: buffer
                        }] }
            });
            const ilpResponse = response.protocolData
                .filter(p => p.protocolName === 'ilp')[0];
            return ilpResponse
                ? ilpResponse.data
                : Buffer.alloc(0);
        });
    }
    sendMoney(amount) {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    _safeEmit() {
        try {
            this.emit.apply(this, arguments);
        }
        catch (err) {
            const errInfo = (typeof err === 'object' && err.stack) ? err.stack : String(err);
            this._log.error('error in handler for event', arguments, errInfo);
        }
    }
    registerDataHandler(handler) {
        if (this._dataHandler) {
            throw new Error('requestHandler is already registered');
        }
        if (typeof handler !== 'function') {
            throw new Error('requestHandler must be a function');
        }
        this._log.trace('registering data handler');
        this._dataHandler = handler;
    }
    deregisterDataHandler() {
        this._dataHandler = undefined;
    }
    registerMoneyHandler(handler) {
        if (this._moneyHandler) {
            throw new Error('requestHandler is already registered');
        }
        if (typeof handler !== 'function') {
            throw new Error('requestHandler must be a function');
        }
        this._log.trace('registering money handler');
        this._moneyHandler = handler;
    }
    deregisterMoneyHandler() {
        this._moneyHandler = undefined;
    }
    protocolDataToIlpAndCustom(packet) {
        return protocol_data_converter_1.protocolDataToIlpAndCustom(packet);
    }
    ilpAndCustomToProtocolData(obj) {
        return protocol_data_converter_1.ilpAndCustomToProtocolData(obj);
    }
    _call(to, btpPacket) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestId = btpPacket.requestId;
            let callback;
            let timer;
            const response = new Promise((resolve, reject) => {
                callback = (type, data) => {
                    switch (type) {
                        case BtpPacket.TYPE_RESPONSE:
                            resolve(data);
                            clearTimeout(timer);
                            break;
                        case BtpPacket.TYPE_ERROR:
                            reject(new Error(JSON.stringify(data)));
                            clearTimeout(timer);
                            break;
                        default:
                            throw new Error('Unknown BTP packet type: ' + type);
                    }
                };
                this.once('__callback_' + requestId, callback);
            });
            yield this._handleOutgoingBtpPacket(to, btpPacket);
            const timeout = new Promise((resolve, reject) => {
                timer = setTimeout(() => {
                    this.removeListener('__callback_' + requestId, callback);
                    reject(new Error(requestId + ' timed out'));
                }, this._responseTimeout);
            });
            return Promise.race([
                response,
                timeout
            ]);
        });
    }
    _handleIncomingBtpPacket(from, btpPacket) {
        return __awaiter(this, void 0, void 0, function* () {
            const { type, requestId, data } = btpPacket;
            const typeString = BtpPacket.typeToString(type);
            this._log.trace(`received btp packet. type=${typeString} requestId=${requestId} info=${generatePacketDataTracer(data)}`);
            let result;
            switch (type) {
                case BtpPacket.TYPE_RESPONSE:
                case BtpPacket.TYPE_ERROR:
                    this.emit('__callback_' + requestId, type, data);
                    return;
                case BtpPacket.TYPE_PREPARE:
                case BtpPacket.TYPE_FULFILL:
                case BtpPacket.TYPE_REJECT:
                    throw new Error('Unsupported BTP packet');
                case BtpPacket.TYPE_TRANSFER:
                    result = yield this._handleMoney(from, btpPacket);
                    break;
                case BtpPacket.TYPE_MESSAGE:
                    result = yield this._handleData(from, btpPacket);
                    break;
                default:
                    throw new Error('Unknown BTP packet type');
            }
            yield this._handleOutgoingBtpPacket(from, {
                type: BtpPacket.TYPE_RESPONSE,
                requestId,
                data: { protocolData: result || [] }
            });
        });
    }
    _handleData(from, btpPacket) {
        return __awaiter(this, void 0, void 0, function* () {
            const { data } = btpPacket;
            const { ilp } = protocol_data_converter_1.protocolDataToIlpAndCustom(data);
            if (!this._dataHandler) {
                throw new Error('no request handler registered');
            }
            const response = yield this._dataHandler(ilp);
            return protocol_data_converter_1.ilpAndCustomToProtocolData({ ilp: response });
        });
    }
    _handleMoney(from, btpPacket) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('No sendMoney functionality is included in this module');
        });
    }
    _handleOutgoingBtpPacket(to, btpPacket) {
        return __awaiter(this, void 0, void 0, function* () {
            const ws = this._ws || this._incomingWs;
            const { type, requestId, data } = btpPacket;
            const typeString = BtpPacket.typeToString(type);
            this._log.trace(`sending btp packet. type=${typeString} requestId=${requestId} info=${generatePacketDataTracer(data)}`);
            try {
                yield new Promise((resolve) => ws.send(BtpPacket.serialize(btpPacket), resolve));
            }
            catch (e) {
                this._log.error('unable to send btp message to client: ' + e.message, 'btp packet:', JSON.stringify(btpPacket));
            }
        });
    }
    _emitDisconnect() {
        if (this._readyState !== ReadyState.DISCONNECTED) {
            this._readyState = ReadyState.DISCONNECTED;
            this.emit('disconnect');
        }
    }
    _emitConnect() {
        if (this._readyState === ReadyState.CONNECTING) {
            this.emit('_first_time_connect');
        }
        else if (this._readyState === ReadyState.READY_TO_EMIT || this._readyState === ReadyState.DISCONNECTED) {
            this._readyState = ReadyState.CONNECTED;
            this.emit('connect');
        }
    }
    _validateAuthPacket(authPacket) {
        assert.strictEqual(authPacket.type, BtpPacket.TYPE_MESSAGE, 'First message sent over BTP connection must be auth packet');
        assert(authPacket.data.protocolData.length >= 2, 'Auth packet must have auth and auth_token subprotocols');
        assert.strictEqual(authPacket.data.protocolData[0].protocolName, 'auth', 'First subprotocol must be auth');
        const tokenProto = authPacket.data.protocolData.find((subProtocol) => subProtocol.protocolName === 'auth_token');
        assert(tokenProto, 'auth_token subprotocol is required');
        const token = tokenProto.data.toString();
        if (token !== this._listener.secret) {
            this._log.debug('received token %s, but expected %s', JSON.stringify(token), JSON.stringify(this._listener.secret));
            throw new Error('invalid auth_token');
        }
    }
}
AbstractBtpPlugin.version = 2;
exports.default = AbstractBtpPlugin;
function _requestId() {
    return new Promise((resolve, reject) => {
        crypto.randomBytes(4, (err, buf) => {
            if (err)
                return reject(err);
            resolve(buf.readUInt32BE(0));
        });
    });
}
//# sourceMappingURL=index.js.map