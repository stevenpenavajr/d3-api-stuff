{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":[],"mappings":"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","sourcesContent":["import * as assert from 'assert'\nimport * as crypto from 'crypto'\nimport * as Debug from 'debug'\nimport * as WebSocket from 'ws'\nimport { WebSocketReconnector, WebSocketConstructor } from './ws-reconnect'\nimport { EventEmitter2, Listener } from 'eventemitter2'\nimport { URL } from 'url'\nimport { protocolDataToIlpAndCustom, ilpAndCustomToProtocolData } from './protocol-data-converter'\n\nconst BtpPacket = require('btp-packet')\n\nconst debug = require('ilp-logger')('ilp-plugin-btp')\n\ntype DataHandler = (data: Buffer) => Promise<Buffer>\ntype MoneyHandler = (amount: string) => Promise<void>\n\nenum ReadyState {\n  INITIAL = 0,\n  CONNECTING = 1,\n  CONNECTED = 2,\n  DISCONNECTED = 3,\n  READY_TO_EMIT = 4\n}\n\nconst DEFAULT_TIMEOUT = 35000\nconst namesToCodes = {\n  'UnreachableError': 'T00',\n  'NotAcceptedError': 'F00',\n  'InvalidFieldsError': 'F01',\n  'TransferNotFoundError': 'F03',\n  'InvalidFulfillmentError': 'F04',\n  'DuplicateIdError': 'F05',\n  'AlreadyRolledBackError': 'F06',\n  'AlreadyFulfilledError': 'F07',\n  'InsufficientBalanceError': 'F08'\n}\n\n/**\n * Returns BTP error code as defined by the BTP ASN.1 spec.\n */\nfunction jsErrorToBtpError (e: Error) {\n  const name: string = e.name || 'NotAcceptedError'\n  const code: string = namesToCodes[name] || 'F00'\n\n  return {\n    code,\n    name,\n    triggeredAt: new Date(),\n    data: JSON.stringify({ message: e.message })\n  }\n}\n\nconst ILP_PACKET_TYPES = {\n  12: 'ilp-prepare',\n  13: 'ilp-fulfill',\n  14: 'ilp-reject'\n}\n\n/**\n * Converts BTP sub protocol data from json/plain text/octet stream to string.\n */\nfunction subProtocolToString (data: BtpSubProtocol): string {\n  let stringData\n\n  switch (data.contentType) {\n    case BtpPacket.MIME_APPLICATION_OCTET_STREAM:\n      stringData = data.data.toString('base64')\n      break\n    case BtpPacket.MIME_APPLICATION_JSON:\n    case BtpPacket.MIME_TEXT_PLAIN_UTF8:\n      stringData = data.data.toString('utf8')\n      break\n  }\n\n  return `${data.protocolName}=${stringData}`\n}\n\n/**\n * Goes through all the sub protocols in the packet data of a BTP packet and\n * returns a protocol map of each sub protocol with the key as the protocol\n * name and value as a string-form protocol object. Calls\n * `subProtocolToString(data)` to convert the value to a string.\n */\nfunction generatePacketDataTracer (packetData: BtpPacketData) {\n  return {\n    toString: () => {\n      try {\n        return packetData.protocolData.map(data => {\n          switch (data.protocolName) {\n            case 'ilp':\n              return ILP_PACKET_TYPES[data.data[0]] || ('ilp-' + data.data[0])\n            default:\n              return subProtocolToString(data)\n          }\n        }).join(';')\n      } catch (err) {\n        return 'serialization error. err=' + err.stack\n      }\n    }\n  }\n}\n\nexport interface BtpPacket {\n  requestId: number\n  type: number\n  data: BtpPacketData\n}\n\nexport interface BtpPacketData {\n  protocolData: Array<BtpSubProtocol>\n  amount?: string\n  code?: string\n  name?: string\n  triggeredAt?: Date\n  data?: string\n}\n\nexport interface BtpSubProtocol {\n  protocolName: string\n  contentType: number\n  data: Buffer\n}\n\n/**\n * Constructor options for a BTP plugin. The 'Instance Management' section of\n * the RFC-24 indicates that every ledger plugin accepts an opts object, and\n * an optional api denoted as 'PluginServices.' This is the opts object.\n */\nexport interface IlpPluginBtpConstructorOptions {\n  server?: string,\n  listener?: {\n    port: number,\n    secret: string\n  },\n  reconnectInterval?: number\n  reconnectIntervals?: Array<number>\n  reconnectClearTryTimeout?: number\n  responseTimeout?: number\n  btpAccount?: string\n  btpToken?: string\n}\n\nexport interface WebSocketServerConstructor {\n  new (opts: WebSocket.ServerOptions): WebSocket.Server\n}\n\n/**\n * This is the optional api, or 'PluginServices' interface, that is passed\n * into the ledger plugin constructor as defined in RFC-24. In this case\n * the api exposes 3 modules.\n */\nexport interface IlpPluginBtpConstructorModules {\n  log?: any\n  WebSocket?: WebSocketConstructor\n  WebSocketServer?: WebSocketServerConstructor\n}\n\n/**\n * Abstract base class for building BTP-based ledger plugins.\n *\n * This class takes care of most of the work translating between BTP and the\n * ledger plugin interface (LPI).\n *\n * You need to implement:\n *\n * `sendMoney (amount)`, handleMoney `(from, btpPacket)`\n *\n * The `from` field is set to null in all the methods here. It is present in\n * order to make it possible to write multi account plugins (plugins with an\n * internal connector which understand ILP).\n *\n * If any work must be done on disconnect, implement _disconnect instead of\n * overriding this.disconnect. This will ensure that the connection is cleaned\n * up properly.\n *\n * If any work must be done on connect, implement _connect. You can also\n * rewrite connect, but then disconnect and handleOutgoingBtpPacket should also\n * be overridden.\n *\n * Instead, you need to implement _handleOutgoingBtpPacket(to, btpPacket) which\n * returns a Promise. `to` is the ILP address of the destination peer and\n * `btpPacket` is the BTP packet as a JavaScript object.\n *\n * You can call _handleIncomingBtpPacket(from, btpPacket) to trigger all the\n * necessary LPI events in response to an incoming BTP packet. `from` is the\n * ILP address of the peer and `btpPacket` is the parsed BTP packet.\n */\nexport default class AbstractBtpPlugin extends EventEmitter2 {\n  public static version = 2\n\n  private _reconnectInterval?: number\n  private _reconnectIntervals?: Array<number>\n  private _reconnectClearTryTimeout?: number\n  private _responseTimeout: number\n\n  protected _dataHandler?: DataHandler\n  protected _moneyHandler?: MoneyHandler\n  private _readyState: ReadyState = ReadyState.INITIAL\n  protected _log: any\n  private WebSocket: WebSocketConstructor\n  private WebSocketServer: WebSocketServerConstructor\n\n  /**\n   * Specify for a BTP instance that is acting as a server.\n   */\n  private _listener?: {\n    port: number,\n    secret: string\n  }\n  protected _wss: WebSocket.Server | null = null\n  private _incomingWs?: WebSocket\n\n  /**\n   * Specify for a BTP instance that is acting as a client.\n   */\n  private _server?: string\n  private _btpToken?: string\n  private _btpAccount?: string\n\n  /**\n   * Refer to `ws-reconnect` module.\n   */\n  private _ws?: WebSocketReconnector\n\n  constructor (options: IlpPluginBtpConstructorOptions, modules?: IlpPluginBtpConstructorModules) {\n    super()\n\n    this._reconnectInterval = options.reconnectInterval // optional\n    this._reconnectIntervals = options.reconnectIntervals // optional\n    this._reconnectClearTryTimeout = options.reconnectClearTryTimeout // optional\n    this._responseTimeout = options.responseTimeout || DEFAULT_TIMEOUT\n    this._listener = options.listener\n    this._server = options.server\n\n    if (this._server) {\n      const parsedBtpUri = new URL(this._server)\n      const parsedAccount = parsedBtpUri.username\n      const parsedToken = parsedBtpUri.password\n\n      if (!parsedBtpUri.protocol.startsWith('btp+')) {\n        throw new Error('server must start with \"btp+\". server=' + this._server)\n      }\n\n      if ((parsedAccount || parsedToken) && (options.btpAccount || options.btpToken)) {\n        throw new Error('account/token must be passed in via constructor or uri, but not both')\n      }\n\n      this._btpToken = parsedToken || options.btpToken || ''\n      this._btpAccount = parsedAccount || options.btpAccount || ''\n    }\n\n    modules = modules || {}\n    this._log = modules.log || debug\n    this._log.trace = this._log.trace || Debug(this._log.debug.namespace + ':trace')\n    this.WebSocket = modules.WebSocket || WebSocket\n    this.WebSocketServer = modules.WebSocketServer || WebSocket.Server\n  }\n\n  // Required for different _connect signature in mini-accounts and its subclasses\n  /* tslint:disable-next-line:no-empty */\n  protected async _connect (...opts: any[]): Promise<void> {}\n  /* tslint:disable-next-line:no-empty */\n  protected async _disconnect (): Promise<void> {}\n\n  /**\n   * Connect to another BTP-based ledger plugin if the instance is not already\n   * connected/connecting to another plugin.\n   *\n   * **If the BTP instance is acting as a server:**\n   *\n   * It creates a new server on the specified `port` from `this.listener`.\n   * It creates an event listener for `connection`. When a connection\n   * is established, listeners for `close`, `error`, and `message` are\n   * added. The listeners for close and error call `emitDisconnect()`.\n   *\n   * There are two listeners for `message` events. First:\n   * Uses socket.once to add a one time listener for the event. The\n   * listener is only invoked the first time and then removed. This is\n   * because the auth message only needs to occur once. We do not want\n   * this event to be triggered on subsequent messages.\n   *\n   * Call `validateAuthPacket()`, and close any other incoming\n   * websocket connections (if present) by calling `closeIncomingSocket`. Return a\n   * response containing the request id if the auth packet is valid.\n   *\n   * Otherwise, if an auth packet fails validation, return a BTP error\n   * response over the connection and close.\n   *\n   * Finally, add a listener to accept subsequent incoming websocket\n   * messages and handle them accordingly. Calls\n   * `handleIncomingWsMessage(socket)`.\n   *\n   * **If the BTP instance is acting as a client:**\n   *\n   * Generate the BTP URL with username, token, and the server uri.\n   * Register listener for opening connection, first time connect, and\n   * incoming messages. Need to register the on open listener before actually\n   * opening a connection. The reason this is not a 'once' listener is\n   * because the client might have to reconnect if the connection fails (as\n   * specified in ws-reconnect) and thus the listener must be active. The `open`\n   * listener sends the BTP auth packet to the server using the `call` function\n   * (sends request, sets a timeout to wait for response).\n   *\n   * Open the connection, and register listeners for `close`, `message`. If the\n   * connection is successfully established, resolve. Otherwise if\n   * closed/disconnected error.\n   *\n   * **Important:** now call `this._connect()` which will be overriden in\n   * subsequent plugins to add ledger functionality after the connection has\n   * been established.\n   */\n  async connect () {\n    if (this._readyState > ReadyState.INITIAL) {\n      return\n    }\n\n    this._readyState = ReadyState.CONNECTING\n\n    /* Server logic. */\n    if (this._listener) {\n      const wss = this._wss = new (this.WebSocketServer)({ port: this._listener.port })\n      this._incomingWs = undefined\n\n      wss.on('connection', (socket: WebSocket) => {\n        this._log.info('got connection')\n        let authPacket: BtpPacket\n\n        socket.on('close', (code: number) => {\n          this._log.info('incoming websocket closed. code=' + code)\n          this._emitDisconnect()\n        })\n\n        socket.on('error', (err: Error) => {\n          this._log.debug('incoming websocket error. error=', err)\n          this._emitDisconnect()\n        })\n\n        socket.once('message', async (binaryAuthMessage: WebSocket.Data) => {\n          try {\n            authPacket = BtpPacket.deserialize(binaryAuthMessage)\n            this._log.trace('got auth packet. packet=%j', authPacket)\n            this._validateAuthPacket(authPacket)\n            if (this._incomingWs) {\n              this._closeIncomingSocket(this._incomingWs, authPacket)\n            }\n            this._incomingWs = socket\n            socket.send(BtpPacket.serializeResponse(authPacket.requestId, []))\n          } catch (err) {\n            this._incomingWs = undefined\n            if (authPacket) {\n              const errorResponse = BtpPacket.serializeError({\n                code: 'F00',\n                name: 'NotAcceptedError',\n                data: err.message,\n                triggeredAt: new Date().toISOString()\n              }, authPacket.requestId, [])\n              socket.send(errorResponse)\n            }\n            socket.close()\n            return\n          }\n\n          this._log.trace('connection authenticated')\n          socket.on('message', this._handleIncomingWsMessage.bind(this, socket))\n          this._emitConnect()\n        })\n      })\n      this._log.info(`listening for BTP connections on ${this._listener.port}`)\n    }\n\n    /* Client logic. */\n    if (this._server) {\n      const parsedBtpUri = new URL(this._server)\n      const account = this._btpAccount || ''\n      const token = this._btpToken || ''\n\n      this._ws = new WebSocketReconnector({\n        WebSocket: this.WebSocket,\n        intervals: this._reconnectIntervals,\n        interval: this._reconnectInterval,\n        clearTryTimeout: this._reconnectClearTryTimeout\n      })\n\n      const protocolData = [{\n        protocolName: 'auth',\n        contentType: BtpPacket.MIME_APPLICATION_OCTET_STREAM,\n        data: Buffer.from([])\n      }, {\n        protocolName: 'auth_username',\n        contentType: BtpPacket.MIME_TEXT_PLAIN_UTF8,\n        data: Buffer.from(account, 'utf8')\n      }, {\n        protocolName: 'auth_token',\n        contentType: BtpPacket.MIME_TEXT_PLAIN_UTF8,\n        data: Buffer.from(token, 'utf8')\n      }]\n\n      this._ws.on('open', async () => {\n        this._log.trace('connected to server')\n        this._call('', {\n          type: BtpPacket.TYPE_MESSAGE,\n          requestId: await _requestId(),\n          data: { protocolData }\n        }).then(() => {\n          this._emitConnect()\n        }).catch((err) => {\n          this._log.error('error authenticating btp connection', err.message)\n        })\n      })\n\n      // CAUTION: Do not delete the following two lines, they have the side-effect\n      // of removing the 'user@pass:' part from parsedBtpUri.toString()!\n      parsedBtpUri.username = ''\n      parsedBtpUri.password = ''\n      const wsUri = parsedBtpUri.toString().substring('btp+'.length)\n\n      await this._ws.open(wsUri)\n\n      this._ws.on('close', () => this._emitDisconnect())\n      this._ws.on('message', this._handleIncomingWsMessage.bind(this, this._ws))\n    }\n\n    await new Promise((resolve, reject) => {\n      const onDisconnect = () => {\n        if (this._ws) this._ws.close()\n        reject(new Error('connection aborted'))\n      }\n      this.once('disconnect', onDisconnect)\n      this.once('_first_time_connect', () => {\n        this.removeListener('disconnect', onDisconnect)\n        resolve()\n      })\n    })\n\n    /* To be overriden. */\n    await this._connect()\n\n    this._readyState = ReadyState.READY_TO_EMIT\n    this._emitConnect()\n  }\n\n  /**\n   * For when there is an existing websocket connection and a new\n   * connection is opened. Removes all listeners from previous connection and\n   * sends an error to the user on the old socket (with the new request ID).\n   */\n  _closeIncomingSocket (socket: WebSocket, authPacket: BtpPacket) {\n    socket.removeAllListeners()\n    socket.once('message', async (data: WebSocket.Data) => {\n      try {\n        socket.send(BtpPacket.serializeError({\n          code: 'F00',\n          name: 'NotAcceptedError',\n          data: 'This connection has been ended because the user has opened a new connection',\n          triggeredAt: new Date().toISOString()\n        }, authPacket.requestId, []))\n      } catch (e) {\n        this._log.error('error responding on closed socket', e)\n      }\n      socket.close()\n    })\n  }\n\n  /**\n   * Close client/server and emit disconnect.\n   *\n   * **Important**: calls `this_disconnect` which is meant to be overriden by\n   * plugins that extend BTP to add additional (e.g. ledger) functionality on\n   * disconnect.\n   */\n  async disconnect () {\n    this._emitDisconnect()\n\n    /* To be overriden. */\n    await this._disconnect()\n\n    if (this._ws) this._ws.close()\n    if (this._incomingWs) {\n      this._incomingWs.close()\n      this._incomingWs = undefined\n    }\n    if (this._wss) this._wss.close()\n  }\n\n  isConnected () {\n    return this._readyState === ReadyState.CONNECTED\n  }\n\n  /**\n   * Deserialize incoming websocket message and call `handleIncomingBtpPacket`.\n   * If error in handling btp packet, call `handleOutgoingBtpPacket` and send\n   * the error through the socket.\n   */\n  async _handleIncomingWsMessage (ws: WebSocket, binaryMessage: WebSocket.Data) {\n    let btpPacket: BtpPacket\n    try {\n      btpPacket = BtpPacket.deserialize(binaryMessage)\n    } catch (err) {\n      this._log.error('deserialization error:', err)\n      ws.close()\n      return\n    }\n\n    try {\n      await this._handleIncomingBtpPacket('', btpPacket)\n    } catch (err) {\n      this._log.debug(`Error processing BTP packet of type ${btpPacket.type}: `, err)\n      const error = jsErrorToBtpError(err)\n      const requestId = btpPacket.requestId\n      const { code, name, triggeredAt, data } = error\n\n      await this._handleOutgoingBtpPacket('', {\n        type: BtpPacket.TYPE_ERROR,\n        requestId,\n        data: {\n          code,\n          name,\n          triggeredAt,\n          data,\n          protocolData: []\n        }\n      })\n    }\n  }\n\n  /**\n   * Send Btp data to counterparty. Uses `_call` which sets the proper timer for\n   * expiry on response packets.\n   */\n  async sendData (buffer: Buffer): Promise<Buffer> {\n    const response = await this._call('', {\n      type: BtpPacket.TYPE_MESSAGE,\n      requestId: await _requestId(),\n      data: { protocolData: [{\n        protocolName: 'ilp',\n        contentType: BtpPacket.MIME_APPLICATION_OCTET_STREAM,\n        data: buffer\n      }] }\n    })\n\n    const ilpResponse = response.protocolData\n      .filter(p => p.protocolName === 'ilp')[0]\n\n    return ilpResponse\n      ? ilpResponse.data\n      : Buffer.alloc(0)\n  }\n\n  /**\n   * With no underlying ledger, sendMoney is a no-op.\n   */\n  async sendMoney (amount: string): Promise<void> {\n    /* NO OP */\n  }\n\n  /**\n   * Don't throw errors even if the event handler throws\n   * this is especially important in plugins because\n   * errors can prevent the balance from being updated correctly.\n   */\n  _safeEmit () {\n    try {\n      this.emit.apply(this, arguments)\n    } catch (err) {\n      const errInfo = (typeof err === 'object' && err.stack) ? err.stack : String(err)\n      this._log.error('error in handler for event', arguments, errInfo)\n    }\n  }\n\n  registerDataHandler (handler: DataHandler) {\n    if (this._dataHandler) {\n      throw new Error('requestHandler is already registered')\n    }\n\n    // TODO Is this check required? TypeScript's linter suggests not\n    // tslint:disable-next-line:strict-type-predicates\n    if (typeof handler !== 'function') {\n      throw new Error('requestHandler must be a function')\n    }\n\n    this._log.trace('registering data handler')\n    this._dataHandler = handler\n  }\n\n  deregisterDataHandler () {\n    this._dataHandler = undefined\n  }\n\n  registerMoneyHandler (handler: MoneyHandler) {\n    if (this._moneyHandler) {\n      throw new Error('requestHandler is already registered')\n    }\n\n    // TODO Is this check required? TypeScript's linter suggests not\n    // tslint:disable-next-line:strict-type-predicates\n    if (typeof handler !== 'function') {\n      throw new Error('requestHandler must be a function')\n    }\n\n    this._log.trace('registering money handler')\n    this._moneyHandler = handler\n  }\n\n  deregisterMoneyHandler () {\n    this._moneyHandler = undefined\n  }\n\n  protocolDataToIlpAndCustom (packet: BtpPacketData) {\n    return protocolDataToIlpAndCustom(packet)\n  }\n\n  /**\n   * Converts protocol map to Btp packet. Reference in\n   * procotol-data-converter.ts.\n   */\n  ilpAndCustomToProtocolData (obj: { ilp?: Buffer, custom?: Object , protocolMap?: Map<string, Buffer | string | Object> }) {\n    return ilpAndCustomToProtocolData(obj)\n  }\n\n  /**\n   * Function to send Btp requests with proper timeout for response or error.\n   *\n   * Create a listener for for an incoming Btp response/error. Resolves on\n   * btp response, rejects on btp error. Send an outgoing btp packet (request),\n   * and set a timer. If the timer expires before a response/error is received, time\n   * out. If a response/error is received, `_handleIncomingBtpPacket` emits\n   * `__callback__`, which triggers the aforementioned listener.\n   */\n  protected async _call (to: string, btpPacket: BtpPacket): Promise<BtpPacketData> {\n    const requestId = btpPacket.requestId\n\n    let callback: Listener\n    let timer: NodeJS.Timer\n    const response = new Promise<BtpPacketData>((resolve, reject) => {\n      callback = (type: number, data: BtpPacketData) => {\n        switch (type) {\n          case BtpPacket.TYPE_RESPONSE:\n            resolve(data)\n            clearTimeout(timer)\n            break\n\n          case BtpPacket.TYPE_ERROR:\n            reject(new Error(JSON.stringify(data)))\n            clearTimeout(timer)\n            break\n\n          default:\n            throw new Error('Unknown BTP packet type: ' + type)\n        }\n      }\n      this.once('__callback_' + requestId, callback)\n    })\n\n    await this._handleOutgoingBtpPacket(to, btpPacket)\n\n    const timeout = new Promise<BtpPacketData>((resolve, reject) => {\n      timer = setTimeout(() => {\n        this.removeListener('__callback_' + requestId, callback)\n        reject(new Error(requestId + ' timed out'))\n      }, this._responseTimeout)\n    })\n\n    return Promise.race([\n      response,\n      timeout\n    ])\n  }\n\n  /**\n   * If a response or error packet is received, trigger the callback function\n   * defined in _call (i.e. response/error returned before timing out)\n   * function. Throw error on PREPARE, FULFILL or REJECT packets, because they\n   * are not BTP packets. If TRANSFER or MESSAGE packets are received, invoke\n   * money handler or data handler respectively. Otherwise prepare a response and handle the outgoing BTP\n   * packet. The reason this function does not handle sending back an ERROR\n   * packet in the websocket is because that is defined in the\n   * _handleIncomingWsMessage function.\n   */\n  protected async _handleIncomingBtpPacket (from: string, btpPacket: BtpPacket) {\n    const { type, requestId, data } = btpPacket\n    const typeString = BtpPacket.typeToString(type)\n\n    this._log.trace(`received btp packet. type=${typeString} requestId=${requestId} info=${generatePacketDataTracer(data)}`)\n    let result: Array<BtpSubProtocol>\n    switch (type) {\n      case BtpPacket.TYPE_RESPONSE:\n      case BtpPacket.TYPE_ERROR:\n        this.emit('__callback_' + requestId, type, data)\n        return\n      case BtpPacket.TYPE_PREPARE:\n      case BtpPacket.TYPE_FULFILL:\n      case BtpPacket.TYPE_REJECT:\n        throw new Error('Unsupported BTP packet')\n\n      case BtpPacket.TYPE_TRANSFER:\n        result = await this._handleMoney(from, btpPacket)\n        break\n\n      case BtpPacket.TYPE_MESSAGE:\n        result = await this._handleData(from, btpPacket)\n        break\n\n      default:\n        throw new Error('Unknown BTP packet type')\n    }\n\n    await this._handleOutgoingBtpPacket(from, {\n      type: BtpPacket.TYPE_RESPONSE,\n      requestId,\n      data: { protocolData: result || [] }\n    })\n  }\n\n  /**\n   * Called after receiving btp packet of type message. First convert it to ILP\n   * format, then handle the ILP data with the regsistered data handler, and then convert it back to BTP\n   * structure and send a response. E.g. for prepare, fulfill, and reject packets.\n   */\n  protected async _handleData (from: string, btpPacket: BtpPacket): Promise<Array<BtpSubProtocol>> {\n    const { data } = btpPacket\n    const { ilp } = protocolDataToIlpAndCustom(data) /* Defined in protocol-data-converter.ts. */\n\n    if (!this._dataHandler) {\n      throw new Error('no request handler registered')\n    }\n\n    const response = await this._dataHandler(ilp)\n    return ilpAndCustomToProtocolData({ ilp: response })\n  }\n\n  /**\n   * Need to fully define on you own.\n   */\n  protected async _handleMoney (from: string, btpPacket: BtpPacket): Promise<Array<BtpSubProtocol>> {\n    throw new Error('No sendMoney functionality is included in this module')\n  }\n\n  /**\n   * Send a BTP packet to a user and wait for the promise to resolve without\n   * error.\n   */\n  protected async _handleOutgoingBtpPacket (to: string, btpPacket: BtpPacket) {\n    const ws = this._ws || this._incomingWs\n\n    const { type, requestId, data } = btpPacket\n    const typeString = BtpPacket.typeToString(type)\n    this._log.trace(`sending btp packet. type=${typeString} requestId=${requestId} info=${generatePacketDataTracer(data)}`)\n\n    try {\n      await new Promise((resolve) => ws!.send(BtpPacket.serialize(btpPacket), resolve))\n    } catch (e) {\n      this._log.error('unable to send btp message to client: ' + e.message, 'btp packet:', JSON.stringify(btpPacket))\n    }\n  }\n\n  /**\n   * If the instance is not already disconnected, change the ReadyState and\n   * emit a disconnect event.\n   */\n  private _emitDisconnect () {\n    if (this._readyState !== ReadyState.DISCONNECTED) {\n      this._readyState = ReadyState.DISCONNECTED\n      this.emit('disconnect')\n    }\n  }\n\n  /**\n   * If the ReadyState is CONNECTING it implies a first time connect, so\n   * accordingly emit that message. Otherwise if the instance has already\n   * registered listeners (i.e. connected before) and is in the appropriate\n   * ready state then emit a normal 'connect' event.\n   */\n  private _emitConnect () {\n    if (this._readyState === ReadyState.CONNECTING) {\n      this.emit('_first_time_connect')\n    } else if (this._readyState === ReadyState.READY_TO_EMIT || this._readyState === ReadyState.DISCONNECTED) {\n      this._readyState = ReadyState.CONNECTED\n      this.emit('connect')\n    }\n  }\n\n  /**\n   * Make sure the auth packet is structured correctly with both an 'auth'\n   * subprotocol and an 'auth token' subprotocol. The auth token needs to match the\n   * secret defined by the server (which should have been given to the client\n   * beforehand.) If the auth token does not pass any of these checks, error.\n   */\n  private _validateAuthPacket (authPacket: BtpPacket): void {\n    assert.strictEqual(authPacket.type, BtpPacket.TYPE_MESSAGE, 'First message sent over BTP connection must be auth packet')\n    assert(authPacket.data.protocolData.length >= 2, 'Auth packet must have auth and auth_token subprotocols')\n    assert.strictEqual(authPacket.data.protocolData[0].protocolName, 'auth', 'First subprotocol must be auth')\n\n    const tokenProto = authPacket.data.protocolData.find(\n      (subProtocol) => subProtocol.protocolName === 'auth_token')\n    assert(tokenProto, 'auth_token subprotocol is required')\n    const token = tokenProto!.data.toString()\n    if (token !== this._listener!.secret) {\n      this._log.debug('received token %s, but expected %s', JSON.stringify(token), JSON.stringify(this._listener!.secret))\n      throw new Error('invalid auth_token')\n    }\n  }\n}\n\n/**\n * Generate a new request id.\n */\nfunction _requestId (): Promise<number> {\n  return new Promise<number>((resolve, reject) => {\n    crypto.randomBytes(4, (err, buf) => {\n      if (err) return reject(err)\n      resolve(buf.readUInt32BE(0))\n    })\n  })\n}\n"]}