"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const InvalidFieldsError_1 = require("./errors/InvalidFieldsError");
exports.InvalidFieldsError = InvalidFieldsError_1.default;
const DataHandlerAlreadyRegisteredError_1 = require("./errors/DataHandlerAlreadyRegisteredError");
exports.DataHandlerAlreadyRegisteredError = DataHandlerAlreadyRegisteredError_1.default;
const MoneyHandlerAlreadyRegisteredError_1 = require("./errors/MoneyHandlerAlreadyRegisteredError");
exports.MoneyHandlerAlreadyRegisteredError = MoneyHandlerAlreadyRegisteredError_1.default;
const IlpPacket = require("ilp-packet");
const oer_utils_1 = require("oer-utils");
const converters_1 = require("./converters");
const util_1 = require("./util");
const debug = require('debug')('ilp-compat-plugin');
const PASSTHROUGH_EVENTS = [
    'connect',
    'disconnect',
    'error',
    'info_change'
];
const PEER_PROTOCOL_FULFILLMENT = Buffer.alloc(32);
exports.COMPAT_SYMBOL = Symbol();
class Plugin extends events_1.EventEmitter {
    constructor(oldPlugin) {
        super();
        this.oldPlugin = oldPlugin;
        this.transfers = {};
        const originalEmit = this.oldPlugin.emit;
        this.oldPlugin.emit = (eventType, ...args) => {
            originalEmit.call(oldPlugin, eventType, ...args);
            if (PASSTHROUGH_EVENTS.indexOf(eventType) !== -1) {
                this.emit(eventType, ...args);
            }
        };
        this.oldPlugin.on('outgoing_fulfill', this._handleOutgoingFulfill.bind(this));
        this.oldPlugin.on('outgoing_reject', this._handleOutgoingReject.bind(this, 'reject'));
        this.oldPlugin.on('outgoing_cancel', this._handleOutgoingReject.bind(this, 'cancel'));
        this.oldPlugin.on('incoming_transfer', this._handleIncomingTransfer.bind(this));
        this.oldPlugin.on('incoming_prepare', this._handleIncomingPrepare.bind(this));
        this.oldPlugin.registerRequestHandler(this._handleRequest.bind(this));
    }
    static isV2Plugin(plugin) {
        return plugin.constructor.version === 2;
    }
    connect() {
        return this.oldPlugin.connect();
    }
    disconnect() {
        return this.oldPlugin.disconnect();
    }
    isConnected() {
        return this.oldPlugin.isConnected();
    }
    sendData(data) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!Buffer.isBuffer(data)) {
                throw new TypeError('sendData must be passed a buffer. typeof=' + typeof data);
            }
            if (data[0] === IlpPacket.Type.TYPE_ILP_PREPARE) {
                const ilpPrepare = IlpPacket.deserializeIlpPrepare(data);
                if (ilpPrepare.destination === 'peer.config') {
                    return this._getIldcpResponse();
                }
                const lpi1Transfer = converters_1.ilpPrepareToLpi1Transfer(ilpPrepare);
                lpi1Transfer.to = this._getTo(ilpPrepare.destination);
                lpi1Transfer.from = this.oldPlugin.getAccount(),
                    lpi1Transfer.ledger = this.oldPlugin.getInfo().prefix;
                return new Promise((resolve, reject) => {
                    this.transfers[lpi1Transfer.id] = { resolve, reject };
                    this.oldPlugin.sendTransfer(lpi1Transfer)
                        .catch(reject);
                });
            }
            else {
                const responseMessage = yield this.oldPlugin.sendRequest({
                    from: this.oldPlugin.getAccount(),
                    to: this._getTo(),
                    ledger: this.oldPlugin.getInfo().prefix,
                    ilp: util_1.base64url(data)
                });
                if (responseMessage.ilp) {
                    return Buffer.from(responseMessage.ilp, 'base64');
                }
                else if (responseMessage.custom &&
                    typeof responseMessage.custom === 'object' &&
                    Object.keys(responseMessage.custom).length) {
                    return Buffer.from(JSON.stringify(responseMessage.custom));
                }
                else {
                    debug('received empty response.');
                    return Buffer.alloc(0);
                }
            }
        });
    }
    sendMoney(amount) {
        return __awaiter(this, void 0, void 0, function* () {
            return;
        });
    }
    registerDataHandler(handler) {
        if (this._dataHandler) {
            throw new DataHandlerAlreadyRegisteredError_1.default('data handler is already registered.');
        }
        if (typeof handler !== 'function') {
            throw new InvalidFieldsError_1.default('data handler must be a function.');
        }
        this._dataHandler = handler;
    }
    deregisterDataHandler() {
        this._dataHandler = undefined;
    }
    registerMoneyHandler(handler) {
        if (this._moneyHandler) {
            throw new MoneyHandlerAlreadyRegisteredError_1.default('money handler is already registered.');
        }
        if (typeof handler !== 'function') {
            throw new InvalidFieldsError_1.default('money handler must be a function.');
        }
        this._moneyHandler = handler;
    }
    deregisterMoneyHandler() {
        this._moneyHandler = undefined;
    }
    _getTo(destination) {
        const prefix = this.oldPlugin.getInfo().prefix;
        let to;
        if (destination && destination.startsWith(prefix)) {
            to = prefix + destination.substring(prefix.length).split('.')[0];
        }
        else {
            to = this.oldPlugin.getInfo().connectors[0];
        }
        if (!to) {
            throw new Error('No valid destination: no connector and destination is not local. destination=' + destination + ' prefix=' + prefix);
        }
        return to;
    }
    _handleOutgoingFulfill(transfer, fulfillment, ilp) {
        if (!this.transfers[transfer.id]) {
            debug('fulfillment for outgoing transfer ignored, unknown transfer id. transferId=%s', transfer.id);
            return;
        }
        debug('outgoing transfer fulfilled. transferId=%s', transfer.id);
        const ilpFulfill = converters_1.lpi1FulfillmentToIlpFulfill(fulfillment, ilp);
        const { resolve } = this.transfers[transfer.id];
        resolve(ilpFulfill);
    }
    _handleOutgoingReject(type, transfer, reason) {
        if (!this.transfers[transfer.id]) {
            debug('%sion for outgoing transfer ignored, unknown transfer id. transferId=%s', type, transfer.id);
            return;
        }
        debug('outgoing transfer %sed. transferId=%s', type, transfer.id);
        const { resolve, reject } = this.transfers[transfer.id];
        try {
            const ilpReject = converters_1.lpi1RejectionToIlpReject(reason);
            resolve(ilpReject);
        }
        catch (err) {
            reject(err);
        }
    }
    _handleIncomingTransfer(lpi1Transfer) {
        debug('incoming optimistic transfer. transferId=%s amount=%s', lpi1Transfer.id, lpi1Transfer.amount);
        if (!this._moneyHandler) {
            debug(`no money handler, ignoring incoming optimistic transfer ${lpi1Transfer.id}`);
            return;
        }
        Promise.resolve(this._moneyHandler(lpi1Transfer.amount))
            .catch(err => {
            const errInfo = (err && typeof err === 'object' && err.stack) ? err.stack : err;
            debug(`could not process incoming money ${lpi1Transfer.id}: ${errInfo}`);
        });
    }
    _handleIncomingPrepare(lpi1Transfer) {
        debug('incoming prepared transfer. transferId=%s', lpi1Transfer.id);
        const ilpPrepare = converters_1.lpi1TransferToIlpPrepare(lpi1Transfer);
        (() => __awaiter(this, void 0, void 0, function* () {
            if (!this._dataHandler) {
                debug(`no data handler, rejecting incoming transfer ${lpi1Transfer.id}`);
                this.oldPlugin.rejectIncomingTransfer(lpi1Transfer.id, {
                    code: 'T01',
                    name: 'Ledger Unreachable',
                    message: 'No data handler registered',
                    triggered_by: this.oldPlugin.getAccount(),
                    triggered_at: new Date(),
                    forwarded_by: ''
                });
                return;
            }
            const responsePacket = yield this._dataHandler(ilpPrepare);
            if (responsePacket[0] === IlpPacket.Type.TYPE_ILP_FULFILL) {
                const { fulfillment, ilp } = converters_1.ilpFulfillToLpi1Fulfillment(responsePacket);
                this.oldPlugin.fulfillCondition(lpi1Transfer.id, fulfillment, ilp);
            }
            else if (responsePacket[0] === IlpPacket.Type.TYPE_ILP_REJECT) {
                const reason = converters_1.ilpRejectToLpi1Rejection(responsePacket);
                this.oldPlugin.rejectIncomingTransfer(lpi1Transfer.id, reason);
            }
            else {
                throw new Error('unknown ilp response packet.');
            }
        }))()
            .catch(err => {
            const errInfo = (err && typeof err === 'object' && err.stack) ? err.stack : err;
            debug(`could not process incoming transfer ${lpi1Transfer.id}: ${errInfo}`);
            this.oldPlugin.rejectIncomingTransfer(lpi1Transfer.id, {
                code: 'F00',
                name: 'Bad Request',
                message: err.message,
                triggered_by: '',
                triggered_at: new Date(),
                forwarded_by: ''
            });
        });
    }
    _handleRequest(request) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._dataHandler) {
                debug(`no data handler, rejecting incoming request ${request.id}`);
                throw new Error('no handler.');
            }
            if (request.ilp) {
                return {
                    to: request.from,
                    from: request.to,
                    ledger: request.ledger,
                    ilp: util_1.base64url(yield this._dataHandler(Buffer.from(request.ilp, 'base64')))
                };
            }
            else {
                throw new Error('cannot handle requests without ilp packet');
            }
        });
    }
    _getIldcpResponse() {
        const info = this.oldPlugin.getInfo();
        const clientName = this.oldPlugin.getAccount();
        const writer = new oer_utils_1.Writer();
        writer.writeVarOctetString(Buffer.from(clientName, 'ascii'));
        writer.writeUInt8(info.currencyScale || 9);
        writer.writeVarOctetString(Buffer.from(info.currency || '', 'utf8'));
        const ildcpResponse = writer.getBuffer();
        return IlpPacket.serializeIlpFulfill({
            fulfillment: PEER_PROTOCOL_FULFILLMENT,
            data: ildcpResponse
        });
    }
}
Plugin.version = 2;
function convert(oldPlugin) {
    if (typeof oldPlugin !== 'object') {
        throw new TypeError('not a plugin: not an object');
    }
    if (Plugin.isV2Plugin(oldPlugin)) {
        return oldPlugin;
    }
    if (typeof oldPlugin.sendTransfer !== 'function') {
        throw new TypeError('not a plugin: no sendTransfer method');
    }
    if (oldPlugin[exports.COMPAT_SYMBOL]) {
        return oldPlugin[exports.COMPAT_SYMBOL];
    }
    const instance = new Plugin(oldPlugin);
    oldPlugin[exports.COMPAT_SYMBOL] = instance;
    return instance;
}
exports.default = convert;
const es6Exports = exports;
module.exports = convert;
Object.assign(module.exports, es6Exports);
//# sourceMappingURL=index.js.map