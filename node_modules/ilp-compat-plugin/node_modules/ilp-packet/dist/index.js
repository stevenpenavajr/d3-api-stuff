"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const oer_utils_1 = require("oer-utils");
const date_1 = require("./src/utils/date");
const uint64_1 = require("./src/utils/uint64");
const Long = require("long");
const assert = require("assert");
const errors = require("./src/errors");
exports.Errors = errors;
var Type;
(function (Type) {
    Type[Type["TYPE_ILP_PAYMENT"] = 1] = "TYPE_ILP_PAYMENT";
    Type[Type["TYPE_ILQP_LIQUIDITY_REQUEST"] = 2] = "TYPE_ILQP_LIQUIDITY_REQUEST";
    Type[Type["TYPE_ILQP_LIQUIDITY_RESPONSE"] = 3] = "TYPE_ILQP_LIQUIDITY_RESPONSE";
    Type[Type["TYPE_ILQP_BY_SOURCE_REQUEST"] = 4] = "TYPE_ILQP_BY_SOURCE_REQUEST";
    Type[Type["TYPE_ILQP_BY_SOURCE_RESPONSE"] = 5] = "TYPE_ILQP_BY_SOURCE_RESPONSE";
    Type[Type["TYPE_ILQP_BY_DESTINATION_REQUEST"] = 6] = "TYPE_ILQP_BY_DESTINATION_REQUEST";
    Type[Type["TYPE_ILQP_BY_DESTINATION_RESPONSE"] = 7] = "TYPE_ILQP_BY_DESTINATION_RESPONSE";
    Type[Type["TYPE_ILP_ERROR"] = 8] = "TYPE_ILP_ERROR";
    Type[Type["TYPE_ILP_FULFILLMENT"] = 9] = "TYPE_ILP_FULFILLMENT";
    Type[Type["TYPE_ILP_FORWARDED_PAYMENT"] = 10] = "TYPE_ILP_FORWARDED_PAYMENT";
    Type[Type["TYPE_ILP_REJECTION"] = 11] = "TYPE_ILP_REJECTION";
    Type[Type["TYPE_ILP_PREPARE"] = 12] = "TYPE_ILP_PREPARE";
    Type[Type["TYPE_ILP_FULFILL"] = 13] = "TYPE_ILP_FULFILL";
    Type[Type["TYPE_ILP_REJECT"] = 14] = "TYPE_ILP_REJECT";
})(Type = exports.Type || (exports.Type = {}));
exports.errorToReject = (address, error) => {
    return exports.serializeIlpReject({
        code: error.ilpErrorCode || 'F00',
        triggeredBy: address,
        message: error.message || '',
        data: error.ilpErrorData || Buffer.alloc(0)
    });
};
exports.serializeEnvelope = (type, contents) => {
    const writer = new oer_utils_1.Writer();
    writer.writeUInt8(type);
    writer.writeVarOctetString(contents);
    return writer.getBuffer();
};
exports.deserializeEnvelope = (binary) => {
    const envelopeReader = oer_utils_1.Reader.from(binary);
    const type = envelopeReader.readUInt8();
    const contents = envelopeReader.readVarOctetString();
    return { type, contents };
};
exports.serializeIlpPayment = (json) => {
    assert(json.amount && typeof json.amount === 'string', 'amount must be a string');
    assert(typeof json.account === 'string', 'account is required');
    assert(!json.data || Buffer.isBuffer(json.data), 'data must be a buffer');
    const writer = new oer_utils_1.Writer();
    const amount = Long.fromString(json.amount, true);
    writer.writeUInt32(amount.getHighBitsUnsigned());
    writer.writeUInt32(amount.getLowBitsUnsigned());
    writer.writeVarOctetString(Buffer.from(json.account, 'ascii'));
    writer.writeVarOctetString(json.data || Buffer.alloc(0));
    writer.writeUInt8(0);
    return exports.serializeEnvelope(Type.TYPE_ILP_PAYMENT, writer.getBuffer());
};
exports.deserializeIlpPayment = (binary) => {
    const { type, contents } = exports.deserializeEnvelope(binary);
    if (type !== Type.TYPE_ILP_PAYMENT) {
        throw new Error('Packet has incorrect type');
    }
    const reader = oer_utils_1.Reader.from(contents);
    const highBits = reader.readUInt32();
    const lowBits = reader.readUInt32();
    const amount = Long.fromBits(lowBits, highBits, true).toString();
    const account = reader.readVarOctetString().toString('ascii');
    const data = reader.readVarOctetString();
    return {
        amount,
        account,
        data
    };
};
exports.serializeIlpForwardedPayment = (json) => {
    assert(typeof json.account === 'string', 'account must be a string');
    assert(!json.data || Buffer.isBuffer(json.data), 'data must be a buffer');
    const writer = new oer_utils_1.Writer();
    writer.writeVarOctetString(Buffer.from(json.account, 'ascii'));
    writer.writeVarOctetString(json.data || Buffer.alloc(0));
    writer.writeUInt8(0);
    return exports.serializeEnvelope(Type.TYPE_ILP_FORWARDED_PAYMENT, writer.getBuffer());
};
exports.deserializeIlpForwardedPayment = (binary) => {
    const { type, contents } = exports.deserializeEnvelope(binary);
    if (type !== Type.TYPE_ILP_FORWARDED_PAYMENT) {
        throw new Error('Packet has incorrect type');
    }
    const reader = oer_utils_1.Reader.from(contents);
    const account = reader.readVarOctetString().toString('ascii');
    const data = reader.readVarOctetString();
    return {
        account,
        data
    };
};
exports.serializeIlqpLiquidityRequest = (json) => {
    assert(typeof json.destinationAccount === 'string', 'destinationAccount must be a string');
    assert(typeof json.destinationHoldDuration === 'number', 'destinationHoldDuration must be a number');
    const writer = new oer_utils_1.Writer();
    writer.writeVarOctetString(Buffer.from(json.destinationAccount, 'ascii'));
    writer.writeUInt32(json.destinationHoldDuration);
    writer.writeUInt8(0);
    return exports.serializeEnvelope(Type.TYPE_ILQP_LIQUIDITY_REQUEST, writer.getBuffer());
};
exports.deserializeIlqpLiquidityRequest = (binary) => {
    const { type, contents } = exports.deserializeEnvelope(binary);
    if (type !== Type.TYPE_ILQP_LIQUIDITY_REQUEST) {
        throw new Error('Packet has incorrect type');
    }
    const reader = oer_utils_1.Reader.from(contents);
    const destinationAccount = reader.readVarOctetString().toString('ascii');
    const destinationHoldDuration = reader.readUInt32();
    return {
        destinationAccount,
        destinationHoldDuration
    };
};
const SIZE_OF_POINT = 16;
exports.serializeIlqpLiquidityResponse = (json) => {
    assert(Buffer.isBuffer(json.liquidityCurve), 'liquidityCurve must be a buffer');
    assert(typeof json.appliesToPrefix === 'string', 'appliesToPrefix must be a string');
    assert(typeof json.sourceHoldDuration === 'number', 'sourceHoldDuration must be a number');
    assert(json.expiresAt instanceof Date, 'expiresAt must be a Date object');
    const writer = new oer_utils_1.Writer();
    if (json.liquidityCurve.length % SIZE_OF_POINT !== 0) {
        throw new Error('invalid liquidity curve, length must be multiple of ' +
            SIZE_OF_POINT + ', but was: ' +
            json.liquidityCurve.length);
    }
    writer.writeVarUInt(json.liquidityCurve.length / SIZE_OF_POINT);
    writer.write(json.liquidityCurve);
    writer.writeVarOctetString(Buffer.from(json.appliesToPrefix, 'ascii'));
    writer.writeUInt32(json.sourceHoldDuration);
    writer.writeVarOctetString(Buffer.from(date_1.dateToGeneralizedTime(json.expiresAt), 'ascii'));
    writer.writeUInt8(0);
    return exports.serializeEnvelope(Type.TYPE_ILQP_LIQUIDITY_RESPONSE, writer.getBuffer());
};
exports.deserializeIlqpLiquidityResponse = (binary) => {
    const { type, contents } = exports.deserializeEnvelope(binary);
    if (type !== Type.TYPE_ILQP_LIQUIDITY_RESPONSE) {
        throw new Error('Packet has incorrect type');
    }
    const reader = oer_utils_1.Reader.from(contents);
    const numPoints = reader.readVarUInt();
    const liquidityCurve = reader.read(numPoints * SIZE_OF_POINT);
    const appliesToPrefix = reader.readVarOctetString().toString('ascii');
    const sourceHoldDuration = reader.readUInt32();
    const expiresAt = date_1.generalizedTimeToDate(reader.readVarOctetString().toString('ascii'));
    return {
        liquidityCurve,
        appliesToPrefix,
        sourceHoldDuration,
        expiresAt
    };
};
exports.serializeIlqpBySourceRequest = (json) => {
    assert(typeof json.destinationAccount === 'string', 'destinationAccount must be a string');
    assert(json.sourceAmount && typeof json.sourceAmount === 'string', 'sourceAmount must be a string');
    const writer = new oer_utils_1.Writer();
    writer.writeVarOctetString(Buffer.from(json.destinationAccount, 'ascii'));
    writer.writeUInt64(uint64_1.stringToTwoNumbers(json.sourceAmount));
    writer.writeUInt32(json.destinationHoldDuration);
    writer.writeUInt8(0);
    return exports.serializeEnvelope(Type.TYPE_ILQP_BY_SOURCE_REQUEST, writer.getBuffer());
};
exports.deserializeIlqpBySourceRequest = (binary) => {
    const { type, contents } = exports.deserializeEnvelope(binary);
    if (type !== Type.TYPE_ILQP_BY_SOURCE_REQUEST) {
        throw new Error('Packet has incorrect type');
    }
    const reader = oer_utils_1.Reader.from(contents);
    const destinationAccount = reader.readVarOctetString().toString('ascii');
    const sourceAmount = uint64_1.twoNumbersToString(reader.readUInt64());
    const destinationHoldDuration = reader.readUInt32();
    return {
        destinationAccount,
        sourceAmount,
        destinationHoldDuration
    };
};
exports.serializeIlqpBySourceResponse = (json) => {
    const writer = new oer_utils_1.Writer();
    writer.writeUInt64(uint64_1.stringToTwoNumbers(json.destinationAmount));
    writer.writeUInt32(json.sourceHoldDuration);
    writer.writeUInt8(0);
    return exports.serializeEnvelope(Type.TYPE_ILQP_BY_SOURCE_RESPONSE, writer.getBuffer());
};
exports.deserializeIlqpBySourceResponse = (binary) => {
    const { type, contents } = exports.deserializeEnvelope(binary);
    if (type !== Type.TYPE_ILQP_BY_SOURCE_RESPONSE) {
        throw new Error('Packet has incorrect type');
    }
    const reader = oer_utils_1.Reader.from(contents);
    const destinationAmount = uint64_1.twoNumbersToString(reader.readUInt64());
    const sourceHoldDuration = reader.readUInt32();
    return {
        destinationAmount,
        sourceHoldDuration
    };
};
exports.serializeIlqpByDestinationRequest = (json) => {
    const writer = new oer_utils_1.Writer();
    writer.writeVarOctetString(Buffer.from(json.destinationAccount, 'ascii'));
    writer.writeUInt64(uint64_1.stringToTwoNumbers(json.destinationAmount));
    writer.writeUInt32(json.destinationHoldDuration);
    writer.writeUInt8(0);
    return exports.serializeEnvelope(Type.TYPE_ILQP_BY_DESTINATION_REQUEST, writer.getBuffer());
};
exports.deserializeIlqpByDestinationRequest = (binary) => {
    const { type, contents } = exports.deserializeEnvelope(binary);
    if (type !== Type.TYPE_ILQP_BY_DESTINATION_REQUEST) {
        throw new Error('Packet has incorrect type');
    }
    const reader = oer_utils_1.Reader.from(contents);
    const destinationAccount = reader.readVarOctetString().toString('ascii');
    const destinationAmount = uint64_1.twoNumbersToString(reader.readUInt64());
    const destinationHoldDuration = reader.readUInt32();
    return {
        destinationAccount,
        destinationAmount,
        destinationHoldDuration
    };
};
exports.serializeIlqpByDestinationResponse = (json) => {
    const writer = new oer_utils_1.Writer();
    writer.writeUInt64(uint64_1.stringToTwoNumbers(json.sourceAmount));
    writer.writeUInt32(json.sourceHoldDuration);
    writer.writeUInt8(0);
    return exports.serializeEnvelope(Type.TYPE_ILQP_BY_DESTINATION_RESPONSE, writer.getBuffer());
};
exports.deserializeIlqpByDestinationResponse = (binary) => {
    const { type, contents } = exports.deserializeEnvelope(binary);
    if (type !== Type.TYPE_ILQP_BY_DESTINATION_RESPONSE) {
        throw new Error('Packet has incorrect type');
    }
    const reader = oer_utils_1.Reader.from(contents);
    const sourceAmount = uint64_1.twoNumbersToString(reader.readUInt64());
    const sourceHoldDuration = reader.readUInt32();
    return {
        sourceAmount,
        sourceHoldDuration
    };
};
const ILP_ERROR_CODE_LENGTH = 3;
exports.serializeIlpError = (json) => {
    const writer = new oer_utils_1.Writer();
    const codeBuffer = Buffer.from(json.code, 'ascii');
    if (codeBuffer.length !== ILP_ERROR_CODE_LENGTH) {
        throw new Error('ILP error codes must be three bytes long, received: ' + json.code);
    }
    writer.write(codeBuffer);
    writer.writeVarOctetString(Buffer.from(json.name, 'ascii'));
    writer.writeVarOctetString(Buffer.from(json.triggeredBy, 'ascii'));
    writer.writeVarUInt(json.forwardedBy.length);
    json.forwardedBy.forEach(forwardedBy => {
        writer.writeVarOctetString(Buffer.from(forwardedBy, 'ascii'));
    });
    writer.writeVarOctetString(Buffer.from(date_1.dateToGeneralizedTime(json.triggeredAt), 'ascii'));
    writer.writeVarOctetString(Buffer.from(json.data, 'ascii'));
    writer.writeUInt8(0);
    return exports.serializeEnvelope(Type.TYPE_ILP_ERROR, writer.getBuffer());
};
exports.deserializeIlpError = (binary) => {
    const { type, contents } = exports.deserializeEnvelope(binary);
    if (type !== Type.TYPE_ILP_ERROR) {
        throw new Error('Packet has incorrect type');
    }
    const reader = oer_utils_1.Reader.from(contents);
    const code = reader.read(ILP_ERROR_CODE_LENGTH).toString('ascii');
    const name = reader.readVarOctetString().toString('ascii');
    const triggeredBy = reader.readVarOctetString().toString('ascii');
    const forwardedByLength = reader.readVarUInt();
    const forwardedBy = new Array(forwardedByLength);
    for (let i = 0; i < forwardedByLength; i++) {
        forwardedBy[i] = reader.readVarOctetString().toString('ascii');
    }
    const triggeredAt = date_1.generalizedTimeToDate(reader.readVarOctetString().toString('ascii'));
    const data = reader.readVarOctetString().toString('ascii');
    return {
        code,
        name,
        triggeredBy,
        forwardedBy,
        triggeredAt,
        data
    };
};
exports.serializeIlpFulfillment = (json) => {
    const writer = new oer_utils_1.Writer();
    writer.writeVarOctetString(json.data || Buffer.alloc(0));
    writer.writeUInt8(0);
    return exports.serializeEnvelope(Type.TYPE_ILP_FULFILLMENT, writer.getBuffer());
};
exports.deserializeIlpFulfillment = (binary) => {
    const { type, contents } = exports.deserializeEnvelope(binary);
    if (type !== Type.TYPE_ILP_FULFILLMENT) {
        throw new Error('Packet has incorrect type');
    }
    const reader = oer_utils_1.Reader.from(contents);
    const data = reader.readVarOctetString();
    return {
        data
    };
};
exports.serializeIlpRejection = (json) => {
    const writer = new oer_utils_1.Writer();
    const codeBuffer = Buffer.from(json.code, 'ascii');
    if (codeBuffer.length !== ILP_ERROR_CODE_LENGTH) {
        throw new Error('ILP error codes must be three bytes long, received: ' + json.code);
    }
    writer.write(codeBuffer);
    writer.writeVarOctetString(Buffer.from(json.triggeredBy, 'ascii'));
    writer.writeVarOctetString(Buffer.from(json.message, 'utf8'));
    writer.writeVarOctetString(json.data || Buffer.alloc(0));
    writer.writeUInt8(0);
    return exports.serializeEnvelope(Type.TYPE_ILP_REJECTION, writer.getBuffer());
};
exports.deserializeIlpRejection = (binary) => {
    const { type, contents } = exports.deserializeEnvelope(binary);
    if (type !== Type.TYPE_ILP_REJECTION) {
        throw new Error('Packet has incorrect type');
    }
    const reader = oer_utils_1.Reader.from(contents);
    const code = reader.read(ILP_ERROR_CODE_LENGTH).toString('ascii');
    const triggeredBy = reader.readVarOctetString().toString('ascii');
    const message = reader.readVarOctetString().toString('utf8');
    const data = reader.readVarOctetString();
    return {
        code,
        triggeredBy,
        message,
        data
    };
};
exports.serializeIlpPrepare = (json) => {
    assert(json.amount && typeof json.amount === 'string', 'amount must be a string');
    assert(Buffer.isBuffer(json.executionCondition) &&
        json.executionCondition.length === 32, 'executionCondition must be a 32-byte buffer');
    assert(json.expiresAt && json.expiresAt instanceof Date, 'expiresAt must be a Date');
    assert(typeof json.destination === 'string', 'destination is required');
    assert(!json.data || Buffer.isBuffer(json.data), 'data must be a buffer');
    const writer = new oer_utils_1.Writer();
    const amount = Long.fromString(json.amount, true);
    writer.writeUInt32(amount.getHighBitsUnsigned());
    writer.writeUInt32(amount.getLowBitsUnsigned());
    writer.write(Buffer.from(date_1.dateToInterledgerTime(json.expiresAt), 'ascii'));
    writer.write(json.executionCondition);
    writer.writeVarOctetString(Buffer.from(json.destination, 'ascii'));
    writer.writeVarOctetString(json.data);
    return exports.serializeEnvelope(Type.TYPE_ILP_PREPARE, writer.getBuffer());
};
exports.deserializeIlpPrepare = (binary) => {
    const { type, contents } = exports.deserializeEnvelope(binary);
    if (type !== Type.TYPE_ILP_PREPARE) {
        throw new Error('Packet has incorrect type');
    }
    const reader = oer_utils_1.Reader.from(contents);
    const highBits = reader.readUInt32();
    const lowBits = reader.readUInt32();
    const amount = Long.fromBits(lowBits, highBits, true).toString();
    const expiresAt = date_1.interledgerTimeToDate(reader.read(date_1.INTERLEDGER_TIME_LENGTH).toString('ascii'));
    const executionCondition = reader.read(32);
    const destination = reader.readVarOctetString().toString('ascii');
    const data = reader.readVarOctetString();
    return {
        amount,
        executionCondition,
        expiresAt,
        destination,
        data
    };
};
exports.serializeIlpFulfill = (json) => {
    assert(Buffer.isBuffer(json.fulfillment) &&
        json.fulfillment.length === 32, 'fulfillment must be a 32-byte buffer');
    assert(!json.data || Buffer.isBuffer(json.data), 'data must be a buffer');
    const writer = new oer_utils_1.Writer();
    writer.write(json.fulfillment);
    writer.writeVarOctetString(json.data);
    return exports.serializeEnvelope(Type.TYPE_ILP_FULFILL, writer.getBuffer());
};
exports.deserializeIlpFulfill = (binary) => {
    const { type, contents } = exports.deserializeEnvelope(binary);
    if (type !== Type.TYPE_ILP_FULFILL) {
        throw new Error('Packet has incorrect type');
    }
    const reader = oer_utils_1.Reader.from(contents);
    const fulfillment = reader.read(32);
    const data = reader.readVarOctetString();
    return {
        fulfillment,
        data
    };
};
exports.serializeIlpReject = (json) => {
    assert(json.code && typeof json.code === 'string', 'code must be a string');
    assert(typeof json.triggeredBy === 'string', 'triggeredBy must be a string');
    assert(typeof json.message === 'string', 'message must be a string');
    assert(!json.data || Buffer.isBuffer(json.data), 'data must be a buffer');
    const writer = new oer_utils_1.Writer();
    const codeBuffer = Buffer.from(json.code, 'ascii');
    if (codeBuffer.length !== ILP_ERROR_CODE_LENGTH) {
        throw new Error('ILP error codes must be three bytes long, received: ' + json.code);
    }
    writer.write(codeBuffer);
    writer.writeVarOctetString(Buffer.from(json.triggeredBy, 'ascii'));
    writer.writeVarOctetString(Buffer.from(json.message, 'utf8'));
    writer.writeVarOctetString(json.data || Buffer.alloc(0));
    return exports.serializeEnvelope(Type.TYPE_ILP_REJECT, writer.getBuffer());
};
exports.deserializeIlpReject = (binary) => {
    const { type, contents } = exports.deserializeEnvelope(binary);
    if (type !== Type.TYPE_ILP_REJECT) {
        throw new Error('Packet has incorrect type');
    }
    const reader = oer_utils_1.Reader.from(contents);
    const code = reader.read(ILP_ERROR_CODE_LENGTH).toString('ascii');
    const triggeredBy = reader.readVarOctetString().toString('ascii');
    const message = reader.readVarOctetString().toString('utf8');
    const data = reader.readVarOctetString();
    return {
        code,
        triggeredBy,
        message,
        data
    };
};
exports.serializeIlpPacket = (obj) => {
    switch (obj.type) {
        case Type.TYPE_ILP_PAYMENT: return exports.serializeIlpPayment(obj.data);
        case Type.TYPE_ILQP_LIQUIDITY_REQUEST: return exports.serializeIlqpLiquidityRequest(obj.data);
        case Type.TYPE_ILQP_LIQUIDITY_RESPONSE: return exports.serializeIlqpLiquidityResponse(obj.data);
        case Type.TYPE_ILQP_BY_SOURCE_REQUEST: return exports.serializeIlqpBySourceRequest(obj.data);
        case Type.TYPE_ILQP_BY_SOURCE_RESPONSE: return exports.serializeIlqpBySourceResponse(obj.data);
        case Type.TYPE_ILQP_BY_DESTINATION_REQUEST: return exports.serializeIlqpByDestinationRequest(obj.data);
        case Type.TYPE_ILQP_BY_DESTINATION_RESPONSE: return exports.serializeIlqpByDestinationResponse(obj.data);
        case Type.TYPE_ILP_ERROR: return exports.serializeIlpError(obj.data);
        case Type.TYPE_ILP_FULFILLMENT: return exports.serializeIlpFulfillment(obj.data);
        case Type.TYPE_ILP_FORWARDED_PAYMENT: return exports.serializeIlpForwardedPayment(obj.data);
        case Type.TYPE_ILP_REJECTION: return exports.serializeIlpRejection(obj.data);
        case Type.TYPE_ILP_PREPARE: return exports.serializeIlpPrepare(obj.data);
        case Type.TYPE_ILP_FULFILL: return exports.serializeIlpFulfill(obj.data);
        case Type.TYPE_ILP_REJECT: return exports.serializeIlpReject(obj.data);
        default: throw new Error('Object has invalid type');
    }
};
exports.deserializeIlpPacket = (binary) => {
    let packet;
    let typeString;
    switch (binary[0]) {
        case Type.TYPE_ILP_PAYMENT:
            packet = exports.deserializeIlpPayment(binary);
            typeString = 'ilp_payment';
            break;
        case Type.TYPE_ILQP_LIQUIDITY_REQUEST:
            packet = exports.deserializeIlqpLiquidityRequest(binary);
            typeString = 'ilqp_liquidity_request';
            break;
        case Type.TYPE_ILQP_LIQUIDITY_RESPONSE:
            packet = exports.deserializeIlqpLiquidityResponse(binary);
            typeString = 'ilqp_liquidity_response';
            break;
        case Type.TYPE_ILQP_BY_SOURCE_REQUEST:
            packet = exports.deserializeIlqpBySourceRequest(binary);
            typeString = 'ilqp_by_source_request';
            break;
        case Type.TYPE_ILQP_BY_SOURCE_RESPONSE:
            packet = exports.deserializeIlqpBySourceResponse(binary);
            typeString = 'ilqp_by_source_response';
            break;
        case Type.TYPE_ILQP_BY_DESTINATION_REQUEST:
            packet = exports.deserializeIlqpByDestinationRequest(binary);
            typeString = 'ilqp_by_destination_request';
            break;
        case Type.TYPE_ILQP_BY_DESTINATION_RESPONSE:
            packet = exports.deserializeIlqpByDestinationResponse(binary);
            typeString = 'ilqp_by_destination_response';
            break;
        case Type.TYPE_ILP_ERROR:
            packet = exports.deserializeIlpError(binary);
            typeString = 'ilp_error';
            break;
        case Type.TYPE_ILP_FULFILLMENT:
            packet = exports.deserializeIlpFulfillment(binary);
            typeString = 'ilp_fulfillment';
            break;
        case Type.TYPE_ILP_FORWARDED_PAYMENT:
            packet = exports.deserializeIlpForwardedPayment(binary);
            typeString = 'ilp_forwarded_payment';
            break;
        case Type.TYPE_ILP_REJECTION:
            packet = exports.deserializeIlpRejection(binary);
            typeString = 'ilp_rejection';
            break;
        case Type.TYPE_ILP_PREPARE:
            packet = exports.deserializeIlpPrepare(binary);
            typeString = 'ilp_prepare';
            break;
        case Type.TYPE_ILP_FULFILL:
            packet = exports.deserializeIlpFulfill(binary);
            typeString = 'ilp_fulfill';
            break;
        case Type.TYPE_ILP_REJECT:
            packet = exports.deserializeIlpReject(binary);
            typeString = 'ilp_reject';
            break;
        default:
            throw new Error('Packet has invalid type');
    }
    return {
        type: binary[0],
        typeString,
        data: packet
    };
};
//# sourceMappingURL=index.js.map