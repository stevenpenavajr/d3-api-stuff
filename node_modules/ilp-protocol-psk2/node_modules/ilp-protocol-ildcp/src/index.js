"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const IlpPacket = require("ilp-packet");
const oer_utils_1 = require("oer-utils");
const debug = require('debug')('ilp-protocol-ildcp');
const ILDCP_DESTINATION = 'peer.config';
const PEER_PROTOCOL_FULFILLMENT = Buffer.alloc(32);
const PEER_PROTOCOL_CONDITION = Buffer.from('Zmh6rfhivXdsj8GLjp+OIAiXFIVu4jOzkCpZHQ1fKSU=', 'base64');
const PEER_PROTOCOL_EXPIRY_DURATION = 60000;
const deserializeIldcpRequest = (request) => {
    const ilp = IlpPacket.deserializeIlpPrepare(request);
    if (ilp.destination !== ILDCP_DESTINATION) {
        throw new TypeError('packet is not an IL-DCP request.');
    }
    if (!PEER_PROTOCOL_CONDITION.equals(ilp.executionCondition)) {
        throw new Error('packet does not contain correct condition for a peer protocol request.');
    }
    if (Date.now() > Number(ilp.expiresAt)) {
        throw new Error('IL-DCP request packet is expired.');
    }
    return {};
};
exports.deserializeIldcpRequest = deserializeIldcpRequest;
const serializeIldcpRequest = (request) => {
    return IlpPacket.serializeIlpPrepare({
        amount: '0',
        destination: ILDCP_DESTINATION,
        executionCondition: PEER_PROTOCOL_CONDITION,
        expiresAt: new Date(Date.now() + PEER_PROTOCOL_EXPIRY_DURATION),
        data: Buffer.alloc(0)
    });
};
exports.serializeIldcpRequest = serializeIldcpRequest;
const deserializeIldcpResponse = (response) => {
    const { fulfillment, data } = IlpPacket.deserializeIlpFulfill(response);
    if (!PEER_PROTOCOL_FULFILLMENT.equals(fulfillment)) {
        throw new Error('IL-DCP response does not contain the expected fulfillment.');
    }
    const reader = oer_utils_1.Reader.from(data);
    const clientAddress = reader.readVarOctetString().toString('ascii');
    const assetScale = reader.readUInt8();
    const assetCode = reader.readVarOctetString().toString('utf8');
    return { clientAddress, assetScale, assetCode };
};
exports.deserializeIldcpResponse = deserializeIldcpResponse;
const serializeIldcpResponse = (response) => {
    const writer = new oer_utils_1.Writer();
    writer.writeVarOctetString(Buffer.from(response.clientAddress, 'ascii'));
    writer.writeUInt8(response.assetScale);
    writer.writeVarOctetString(Buffer.from(response.assetCode, 'utf8'));
    return IlpPacket.serializeIlpFulfill({
        fulfillment: PEER_PROTOCOL_FULFILLMENT,
        data: writer.getBuffer()
    });
};
exports.serializeIldcpResponse = serializeIldcpResponse;
const fetch = (sendData) => __awaiter(this, void 0, void 0, function* () {
    const data = yield sendData(IlpPacket.serializeIlpPrepare({
        amount: '0',
        executionCondition: PEER_PROTOCOL_CONDITION,
        expiresAt: new Date(Date.now() + PEER_PROTOCOL_EXPIRY_DURATION),
        destination: 'peer.config',
        data: Buffer.alloc(0)
    }));
    if (data[0] === IlpPacket.Type.TYPE_ILP_REJECT) {
        const { triggeredBy, message } = IlpPacket.deserializeIlpReject(data);
        debug('IL-DCP request rejected. triggeredBy=%s errorMessage=%s', triggeredBy, message);
        throw new Error('IL-DCP failed: ' + message);
    }
    else if (data[0] !== IlpPacket.Type.TYPE_ILP_FULFILL) {
        debug('invalid response type. type=%s', data[0]);
        throw new Error('IL-DCP error, unable to retrieve client configuration.');
    }
    const { clientAddress, assetScale, assetCode } = deserializeIldcpResponse(data);
    debug('received client info. clientAddress=%s assetScale=%s assetCode=%s', clientAddress, assetScale, assetCode);
    return { clientAddress, assetScale, assetCode };
});
exports.fetch = fetch;
const serve = ({ requestPacket, handler, serverAddress }) => __awaiter(this, void 0, void 0, function* () {
    try {
        deserializeIldcpRequest(requestPacket);
        const info = yield handler({});
        return serializeIldcpResponse(info);
    }
    catch (err) {
        const errInfo = (err && typeof err === 'object' && err.stack) ? err.stack : err;
        debug('error while handling ildcp request. error=%s', errInfo);
        return IlpPacket.serializeIlpReject({
            code: 'F00',
            message: (err && typeof err === 'object' && err.message) ? err.message : 'unexpected error.',
            triggeredBy: serverAddress,
            data: Buffer.alloc(0)
        });
    }
});
exports.serve = serve;
//# sourceMappingURL=index.js.map