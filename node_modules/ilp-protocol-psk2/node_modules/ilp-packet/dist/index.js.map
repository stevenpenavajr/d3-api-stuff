{"version":3,"file":"index.js","sourceRoot":"","sources":["../index.ts"],"names":[],"mappings":"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","sourcesContent":["import { Reader, Writer } from 'oer-utils'\nimport {\n  dateToGeneralizedTime,\n  generalizedTimeToDate,\n  dateToInterledgerTime,\n  interledgerTimeToDate,\n  INTERLEDGER_TIME_LENGTH } from './src/utils/date'\nimport { stringToTwoNumbers, twoNumbersToString } from './src/utils/uint64'\nimport Long = require('long')\nimport * as assert from 'assert'\n\nimport * as errors from './src/errors'\nexport const Errors = errors\n\nexport enum Type {\n  TYPE_ILP_PAYMENT = 1,\n  TYPE_ILQP_LIQUIDITY_REQUEST = 2,\n  TYPE_ILQP_LIQUIDITY_RESPONSE = 3,\n  TYPE_ILQP_BY_SOURCE_REQUEST = 4,\n  TYPE_ILQP_BY_SOURCE_RESPONSE = 5,\n  TYPE_ILQP_BY_DESTINATION_REQUEST = 6,\n  TYPE_ILQP_BY_DESTINATION_RESPONSE = 7,\n  TYPE_ILP_ERROR = 8,\n  TYPE_ILP_FULFILLMENT = 9,\n  TYPE_ILP_FORWARDED_PAYMENT = 10, // experimental\n  TYPE_ILP_REJECTION = 11,\n  TYPE_ILP_PREPARE = 12,\n  TYPE_ILP_FULFILL = 13,\n  TYPE_ILP_REJECT = 14\n}\n\nexport interface IlpErrorClass {\n  message: string,\n  ilpErrorCode?: string,\n  ilpErrorData?: Buffer\n}\n\nexport const errorToReject = (address: string, error: IlpErrorClass) => {\n  return serializeIlpReject({\n    code: error.ilpErrorCode || 'F00',\n    triggeredBy: address,\n    message: error.message || '',\n    data: error.ilpErrorData || Buffer.alloc(0)\n  })\n}\n\nexport const serializeEnvelope = (type: number, contents: Buffer) => {\n  const writer = new Writer()\n  writer.writeUInt8(type)\n  writer.writeVarOctetString(contents)\n  return writer.getBuffer()\n}\n\nexport const deserializeEnvelope = (binary: Buffer) => {\n  const envelopeReader = Reader.from(binary)\n  const type = envelopeReader.readUInt8()\n  const contents = envelopeReader.readVarOctetString()\n\n  return { type, contents }\n}\n\nexport interface IlpPacket {\n  type: Type,\n  data: any\n}\n\nexport interface IlpPayment {\n  amount: string,\n  account: string,\n  data: Buffer\n}\n\nexport interface IlpForwardedPayment {\n  account: string,\n  data: Buffer\n}\n\nexport const serializeIlpPayment = (json: IlpPayment) => {\n  assert(json.amount && typeof json.amount === 'string', 'amount must be a string')\n  assert(typeof json.account === 'string', 'account is required')\n  assert(!json.data || Buffer.isBuffer(json.data), 'data must be a buffer')\n\n  const writer = new Writer()\n\n  // amount\n  const amount = Long.fromString(json.amount, true)\n  writer.writeUInt32(amount.getHighBitsUnsigned())\n  writer.writeUInt32(amount.getLowBitsUnsigned())\n\n  // account\n  writer.writeVarOctetString(Buffer.from(json.account, 'ascii'))\n\n  // data\n  writer.writeVarOctetString(json.data || Buffer.alloc(0))\n\n  // extensibility\n  writer.writeUInt8(0)\n\n  return serializeEnvelope(Type.TYPE_ILP_PAYMENT, writer.getBuffer())\n}\n\nexport const deserializeIlpPayment = (binary: Buffer): IlpPayment => {\n  const { type, contents } = deserializeEnvelope(binary)\n\n  if (type !== Type.TYPE_ILP_PAYMENT) {\n    throw new Error('Packet has incorrect type')\n  }\n\n  const reader = Reader.from(contents)\n\n  const highBits = reader.readUInt32()\n  const lowBits = reader.readUInt32()\n  const amount = Long.fromBits(lowBits, highBits, true).toString()\n  const account = reader.readVarOctetString().toString('ascii')\n  const data = reader.readVarOctetString()\n\n  // Ignore remaining bytes for extensibility\n\n  return {\n    amount,\n    account,\n    data\n  }\n}\n\nexport const serializeIlpForwardedPayment = (json: IlpForwardedPayment) => {\n  assert(typeof json.account === 'string', 'account must be a string')\n  assert(!json.data || Buffer.isBuffer(json.data), 'data must be a buffer')\n\n  const writer = new Writer()\n\n  // account\n  writer.writeVarOctetString(Buffer.from(json.account, 'ascii'))\n\n  // data\n  writer.writeVarOctetString(json.data || Buffer.alloc(0))\n\n  // extensibility\n  writer.writeUInt8(0)\n\n  return serializeEnvelope(Type.TYPE_ILP_FORWARDED_PAYMENT, writer.getBuffer())\n}\n\nexport const deserializeIlpForwardedPayment = (binary: Buffer): IlpForwardedPayment => {\n  const { type, contents } = deserializeEnvelope(binary)\n\n  if (type !== Type.TYPE_ILP_FORWARDED_PAYMENT) {\n    throw new Error('Packet has incorrect type')\n  }\n\n  const reader = Reader.from(contents)\n\n  const account = reader.readVarOctetString().toString('ascii')\n  const data = reader.readVarOctetString()\n\n  // Ignore remaining bytes for extensibility\n\n  return {\n    account,\n    data\n  }\n}\n\nexport interface IlqpLiquidityRequest {\n  destinationAccount: string,\n  destinationHoldDuration: number\n}\n\nexport const serializeIlqpLiquidityRequest = (json: IlqpLiquidityRequest) => {\n  assert(typeof json.destinationAccount === 'string', 'destinationAccount must be a string')\n  assert(typeof json.destinationHoldDuration === 'number', 'destinationHoldDuration must be a number')\n\n  const writer = new Writer()\n\n  // destinationAccount\n  writer.writeVarOctetString(Buffer.from(json.destinationAccount, 'ascii'))\n\n  // destinationHoldDuration\n  writer.writeUInt32(json.destinationHoldDuration)\n\n  // extensibility\n  writer.writeUInt8(0)\n\n  return serializeEnvelope(Type.TYPE_ILQP_LIQUIDITY_REQUEST, writer.getBuffer())\n}\n\nexport const deserializeIlqpLiquidityRequest = (binary: Buffer): IlqpLiquidityRequest => {\n  const { type, contents } = deserializeEnvelope(binary)\n\n  if (type !== Type.TYPE_ILQP_LIQUIDITY_REQUEST) {\n    throw new Error('Packet has incorrect type')\n  }\n\n  const reader = Reader.from(contents)\n\n  const destinationAccount = reader.readVarOctetString().toString('ascii')\n\n  const destinationHoldDuration = reader.readUInt32()\n\n  // Ignore remaining bytes for extensibility\n\n  return {\n    destinationAccount,\n    destinationHoldDuration\n  }\n}\n\nexport interface IlqpLiquidityResponse {\n  liquidityCurve: Buffer,\n  appliesToPrefix: string,\n  sourceHoldDuration: number,\n  expiresAt: Date\n}\n\n// Each point in a liquidity curve is two UInt64s\nconst SIZE_OF_POINT = 16\n\nexport const serializeIlqpLiquidityResponse = (json: IlqpLiquidityResponse) => {\n  assert(Buffer.isBuffer(json.liquidityCurve), 'liquidityCurve must be a buffer')\n  assert(typeof json.appliesToPrefix === 'string', 'appliesToPrefix must be a string')\n  assert(typeof json.sourceHoldDuration === 'number', 'sourceHoldDuration must be a number')\n  assert(json.expiresAt instanceof Date, 'expiresAt must be a Date object')\n\n  const writer = new Writer()\n\n  // liquidityCurve\n  if (json.liquidityCurve.length % SIZE_OF_POINT !== 0) {\n    throw new Error(\n      'invalid liquidity curve, length must be multiple of ' +\n      SIZE_OF_POINT + ', but was: ' +\n      json.liquidityCurve.length\n    )\n  }\n  writer.writeVarUInt(json.liquidityCurve.length / SIZE_OF_POINT)\n  writer.write(json.liquidityCurve)\n\n  // appliesToPrefix\n  writer.writeVarOctetString(Buffer.from(json.appliesToPrefix, 'ascii'))\n\n  // sourceHoldDuration\n  writer.writeUInt32(json.sourceHoldDuration)\n\n  // expiresAt\n  writer.writeVarOctetString(Buffer.from(dateToGeneralizedTime(json.expiresAt), 'ascii'))\n\n  // extensibility\n  writer.writeUInt8(0)\n\n  return serializeEnvelope(Type.TYPE_ILQP_LIQUIDITY_RESPONSE, writer.getBuffer())\n}\n\nexport const deserializeIlqpLiquidityResponse = (binary: Buffer): IlqpLiquidityResponse => {\n  const { type, contents } = deserializeEnvelope(binary)\n\n  if (type !== Type.TYPE_ILQP_LIQUIDITY_RESPONSE) {\n    throw new Error('Packet has incorrect type')\n  }\n\n  const reader = Reader.from(contents)\n\n  const numPoints = reader.readVarUInt()\n  const liquidityCurve = reader.read(numPoints * SIZE_OF_POINT)\n\n  const appliesToPrefix = reader.readVarOctetString().toString('ascii')\n\n  const sourceHoldDuration = reader.readUInt32()\n\n  const expiresAt = generalizedTimeToDate(reader.readVarOctetString().toString('ascii'))\n\n  // Ignore remaining bytes for extensibility\n\n  return {\n    liquidityCurve,\n    appliesToPrefix,\n    sourceHoldDuration,\n    expiresAt\n  }\n}\n\nexport interface IlqpBySourceRequest {\n  destinationAccount: string,\n  sourceAmount: string,\n  destinationHoldDuration: number,\n}\n\nexport const serializeIlqpBySourceRequest = (json: IlqpBySourceRequest) => {\n  assert(typeof json.destinationAccount === 'string', 'destinationAccount must be a string')\n  assert(json.sourceAmount && typeof json.sourceAmount === 'string', 'sourceAmount must be a string')\n\n  const writer = new Writer()\n\n  // destinationAccount\n  writer.writeVarOctetString(Buffer.from(json.destinationAccount, 'ascii'))\n\n  // sourceAmount\n  writer.writeUInt64(stringToTwoNumbers(json.sourceAmount))\n\n  // destinationHoldDuration\n  writer.writeUInt32(json.destinationHoldDuration)\n\n  // extensibility\n  writer.writeUInt8(0)\n\n  return serializeEnvelope(Type.TYPE_ILQP_BY_SOURCE_REQUEST, writer.getBuffer())\n}\n\nexport const deserializeIlqpBySourceRequest = (binary: Buffer): IlqpBySourceRequest => {\n  const { type, contents } = deserializeEnvelope(binary)\n\n  if (type !== Type.TYPE_ILQP_BY_SOURCE_REQUEST) {\n    throw new Error('Packet has incorrect type')\n  }\n\n  const reader = Reader.from(contents)\n\n  const destinationAccount = reader.readVarOctetString().toString('ascii')\n\n  const sourceAmount = twoNumbersToString(reader.readUInt64())\n\n  const destinationHoldDuration = reader.readUInt32()\n\n  // Ignore remaining bytes for extensibility\n\n  return {\n    destinationAccount,\n    sourceAmount,\n    destinationHoldDuration\n  }\n}\n\nexport interface IlqpBySourceResponse {\n  destinationAmount: string,\n  sourceHoldDuration: number,\n}\n\nexport const serializeIlqpBySourceResponse = (json: IlqpBySourceResponse) => {\n  const writer = new Writer()\n\n  // destinationAmount\n  // TODO: Proper UInt64 support\n  writer.writeUInt64(stringToTwoNumbers(json.destinationAmount))\n\n  // sourceHoldDuration\n  writer.writeUInt32(json.sourceHoldDuration)\n\n  // extensibility\n  writer.writeUInt8(0)\n\n  return serializeEnvelope(Type.TYPE_ILQP_BY_SOURCE_RESPONSE, writer.getBuffer())\n}\n\nexport const deserializeIlqpBySourceResponse = (binary: Buffer): IlqpBySourceResponse => {\n  const { type, contents } = deserializeEnvelope(binary)\n\n  if (type !== Type.TYPE_ILQP_BY_SOURCE_RESPONSE) {\n    throw new Error('Packet has incorrect type')\n  }\n\n  const reader = Reader.from(contents)\n\n  const destinationAmount = twoNumbersToString(reader.readUInt64())\n\n  const sourceHoldDuration = reader.readUInt32()\n\n  // Ignore remaining bytes for extensibility\n\n  return {\n    destinationAmount,\n    sourceHoldDuration\n  }\n}\n\nexport interface IlqpByDestinationRequest {\n  destinationAccount: string,\n  destinationAmount: string,\n  destinationHoldDuration: number,\n}\n\nexport const serializeIlqpByDestinationRequest = (json: IlqpByDestinationRequest) => {\n  const writer = new Writer()\n\n  // destinationAccount\n  writer.writeVarOctetString(Buffer.from(json.destinationAccount, 'ascii'))\n\n  // destinationAmount\n  writer.writeUInt64(stringToTwoNumbers(json.destinationAmount))\n\n  // destinationHoldDuration\n  writer.writeUInt32(json.destinationHoldDuration)\n\n  // extensibility\n  writer.writeUInt8(0)\n\n  return serializeEnvelope(Type.TYPE_ILQP_BY_DESTINATION_REQUEST, writer.getBuffer())\n}\n\nexport const deserializeIlqpByDestinationRequest = (binary: Buffer): IlqpByDestinationRequest => {\n  const { type, contents } = deserializeEnvelope(binary)\n\n  if (type !== Type.TYPE_ILQP_BY_DESTINATION_REQUEST) {\n    throw new Error('Packet has incorrect type')\n  }\n\n  const reader = Reader.from(contents)\n\n  const destinationAccount = reader.readVarOctetString().toString('ascii')\n\n  const destinationAmount = twoNumbersToString(reader.readUInt64())\n\n  const destinationHoldDuration = reader.readUInt32()\n\n  // Ignore remaining bytes for extensibility\n\n  return {\n    destinationAccount,\n    destinationAmount,\n    destinationHoldDuration\n  }\n}\n\nexport interface IlqpByDestinationResponse {\n  sourceAmount: string,\n  sourceHoldDuration: number,\n}\n\nexport const serializeIlqpByDestinationResponse = (json: IlqpByDestinationResponse) => {\n  const writer = new Writer()\n\n  // destinationAmount\n  // TODO: Proper UInt64 support\n  writer.writeUInt64(stringToTwoNumbers(json.sourceAmount))\n\n  // sourceHoldDuration\n  writer.writeUInt32(json.sourceHoldDuration)\n\n  // extensibility\n  writer.writeUInt8(0)\n\n  return serializeEnvelope(Type.TYPE_ILQP_BY_DESTINATION_RESPONSE, writer.getBuffer())\n}\n\nexport const deserializeIlqpByDestinationResponse = (binary: Buffer): IlqpByDestinationResponse => {\n  const { type, contents } = deserializeEnvelope(binary)\n\n  if (type !== Type.TYPE_ILQP_BY_DESTINATION_RESPONSE) {\n    throw new Error('Packet has incorrect type')\n  }\n\n  const reader = Reader.from(contents)\n\n  const sourceAmount = twoNumbersToString(reader.readUInt64())\n\n  const sourceHoldDuration = reader.readUInt32()\n\n  // Ignore remaining bytes for extensibility\n\n  return {\n    sourceAmount,\n    sourceHoldDuration\n  }\n}\n\nexport interface IlpError {\n  code: string,\n  name: string,\n  triggeredBy: string,\n  forwardedBy: string[],\n  triggeredAt: Date,\n  data: string\n}\n\nconst ILP_ERROR_CODE_LENGTH = 3\n\nexport const serializeIlpError = (json: IlpError) => {\n  const writer = new Writer()\n\n  // Convert code to buffer to ensure we are counting bytes, not UTF8 characters\n  const codeBuffer = Buffer.from(json.code, 'ascii')\n  if (codeBuffer.length !== ILP_ERROR_CODE_LENGTH) {\n    throw new Error('ILP error codes must be three bytes long, received: ' + json.code)\n  }\n\n  // code\n  writer.write(codeBuffer)\n\n  // name\n  writer.writeVarOctetString(Buffer.from(json.name, 'ascii'))\n\n  // triggeredBy\n  writer.writeVarOctetString(Buffer.from(json.triggeredBy, 'ascii'))\n\n  // forwardedBy\n  writer.writeVarUInt(json.forwardedBy.length)\n  json.forwardedBy.forEach(forwardedBy => {\n    writer.writeVarOctetString(Buffer.from(forwardedBy, 'ascii'))\n  })\n\n  // triggeredAt\n  writer.writeVarOctetString(Buffer.from(dateToGeneralizedTime(json.triggeredAt), 'ascii'))\n\n  // data\n  writer.writeVarOctetString(Buffer.from(json.data, 'ascii'))\n\n  // extensibility\n  writer.writeUInt8(0)\n\n  return serializeEnvelope(Type.TYPE_ILP_ERROR, writer.getBuffer())\n}\n\nexport const deserializeIlpError = (binary: Buffer): IlpError => {\n  const { type, contents } = deserializeEnvelope(binary)\n\n  if (type !== Type.TYPE_ILP_ERROR) {\n    throw new Error('Packet has incorrect type')\n  }\n\n  const reader = Reader.from(contents)\n\n  const code = reader.read(ILP_ERROR_CODE_LENGTH).toString('ascii')\n\n  const name = reader.readVarOctetString().toString('ascii')\n\n  const triggeredBy = reader.readVarOctetString().toString('ascii')\n\n  const forwardedByLength = reader.readVarUInt()\n  const forwardedBy: string[] = new Array(forwardedByLength)\n  for (let i = 0; i < forwardedByLength; i++) {\n    forwardedBy[i] = reader.readVarOctetString().toString('ascii')\n  }\n\n  const triggeredAt = generalizedTimeToDate(reader.readVarOctetString().toString('ascii'))\n\n  const data = reader.readVarOctetString().toString('ascii')\n\n  // Ignore remaining bytes for extensibility\n\n  return {\n    code,\n    name,\n    triggeredBy,\n    forwardedBy,\n    triggeredAt,\n    data\n  }\n}\n\nexport interface IlpFulfillment {\n  data: Buffer\n}\n\nexport const serializeIlpFulfillment = (json: IlpFulfillment) => {\n  const writer = new Writer()\n\n  // data\n  writer.writeVarOctetString(json.data || Buffer.alloc(0))\n\n  // extensibility\n  writer.writeUInt8(0)\n\n  return serializeEnvelope(Type.TYPE_ILP_FULFILLMENT, writer.getBuffer())\n}\n\nexport const deserializeIlpFulfillment = (binary: Buffer): IlpFulfillment => {\n  const { type, contents } = deserializeEnvelope(binary)\n\n  if (type !== Type.TYPE_ILP_FULFILLMENT) {\n    throw new Error('Packet has incorrect type')\n  }\n\n  const reader = Reader.from(contents)\n\n  const data = reader.readVarOctetString()\n\n  // Ignore remaining bytes for extensibility\n\n  return {\n    data\n  }\n}\n\nexport interface IlpRejection {\n  code: string,\n  triggeredBy: string,\n  message: string,\n  data: Buffer\n}\n\nexport const serializeIlpRejection = (json: IlpRejection) => {\n  const writer = new Writer()\n\n  // Convert code to buffer to ensure we are counting bytes, not UTF8 characters\n  const codeBuffer = Buffer.from(json.code, 'ascii')\n  if (codeBuffer.length !== ILP_ERROR_CODE_LENGTH) {\n    throw new Error('ILP error codes must be three bytes long, received: ' + json.code)\n  }\n\n  // code\n  writer.write(codeBuffer)\n\n  // triggeredBy\n  writer.writeVarOctetString(Buffer.from(json.triggeredBy, 'ascii'))\n\n  // message\n  writer.writeVarOctetString(Buffer.from(json.message, 'utf8'))\n\n  // data\n  writer.writeVarOctetString(json.data || Buffer.alloc(0))\n\n  // extensibility\n  writer.writeUInt8(0)\n\n  return serializeEnvelope(Type.TYPE_ILP_REJECTION, writer.getBuffer())\n}\n\nexport const deserializeIlpRejection = (binary: Buffer): IlpRejection => {\n  const { type, contents } = deserializeEnvelope(binary)\n\n  if (type !== Type.TYPE_ILP_REJECTION) {\n    throw new Error('Packet has incorrect type')\n  }\n\n  const reader = Reader.from(contents)\n\n  const code = reader.read(ILP_ERROR_CODE_LENGTH).toString('ascii')\n\n  const triggeredBy = reader.readVarOctetString().toString('ascii')\n\n  const message = reader.readVarOctetString().toString('utf8')\n\n  const data = reader.readVarOctetString()\n\n  // Ignore remaining bytes for extensibility\n\n  return {\n    code,\n    triggeredBy,\n    message,\n    data\n  }\n}\n\nexport interface IlpPrepare {\n  amount: string,\n  executionCondition: Buffer,\n  expiresAt: Date,\n  destination: string,\n  data: Buffer\n}\n\nexport const serializeIlpPrepare = (json: IlpPrepare) => {\n  assert(json.amount && typeof json.amount === 'string', 'amount must be a string')\n  assert(Buffer.isBuffer(json.executionCondition) &&\n    json.executionCondition.length === 32, 'executionCondition must be a 32-byte buffer')\n  assert(json.expiresAt && json.expiresAt instanceof Date, 'expiresAt must be a Date')\n  assert(typeof json.destination === 'string', 'destination is required')\n  assert(!json.data || Buffer.isBuffer(json.data), 'data must be a buffer')\n\n  const writer = new Writer()\n\n  const amount = Long.fromString(json.amount, true)\n  writer.writeUInt32(amount.getHighBitsUnsigned())\n  writer.writeUInt32(amount.getLowBitsUnsigned())\n  writer.write(Buffer.from(dateToInterledgerTime(json.expiresAt), 'ascii'))\n  writer.write(json.executionCondition)\n  writer.writeVarOctetString(Buffer.from(json.destination, 'ascii'))\n  writer.writeVarOctetString(json.data)\n\n  return serializeEnvelope(Type.TYPE_ILP_PREPARE, writer.getBuffer())\n}\n\nexport const deserializeIlpPrepare = (binary: Buffer): IlpPrepare => {\n  const { type, contents } = deserializeEnvelope(binary)\n\n  if (type !== Type.TYPE_ILP_PREPARE) {\n    throw new Error('Packet has incorrect type')\n  }\n\n  const reader = Reader.from(contents)\n  const highBits = reader.readUInt32()\n  const lowBits = reader.readUInt32()\n  const amount = Long.fromBits(lowBits, highBits, true).toString()\n  const expiresAt = interledgerTimeToDate(reader.read(INTERLEDGER_TIME_LENGTH).toString('ascii'))\n  const executionCondition = reader.read(32)\n  const destination = reader.readVarOctetString().toString('ascii')\n  const data = reader.readVarOctetString()\n\n  return {\n    amount,\n    executionCondition,\n    expiresAt,\n    destination,\n    data\n  }\n}\n\nexport interface IlpFulfill {\n  fulfillment: Buffer,\n  data: Buffer\n}\n\nexport const serializeIlpFulfill = (json: IlpFulfill) => {\n  assert(Buffer.isBuffer(json.fulfillment) &&\n    json.fulfillment.length === 32, 'fulfillment must be a 32-byte buffer')\n  assert(!json.data || Buffer.isBuffer(json.data), 'data must be a buffer')\n\n  \n  const writer = new Writer()\n  writer.write(json.fulfillment)\n  writer.writeVarOctetString(json.data)\n\n  return serializeEnvelope(Type.TYPE_ILP_FULFILL, writer.getBuffer())\n}\n\nexport const deserializeIlpFulfill = (binary: Buffer): IlpFulfill => {\n  const { type, contents } = deserializeEnvelope(binary)\n\n  if (type !== Type.TYPE_ILP_FULFILL) {\n    throw new Error('Packet has incorrect type')\n  }\n\n  const reader = Reader.from(contents)\n  const fulfillment = reader.read(32)\n  const data = reader.readVarOctetString()\n\n  return {\n    fulfillment,\n    data\n  }\n}\n\nexport const serializeIlpReject = (json: IlpRejection) => {\n  assert(json.code && typeof json.code === 'string', 'code must be a string')\n  assert(typeof json.triggeredBy === 'string', 'triggeredBy must be a string')\n  assert(typeof json.message === 'string', 'message must be a string')\n  assert(!json.data || Buffer.isBuffer(json.data), 'data must be a buffer')\n\n  const writer = new Writer()\n\n  // Convert code to buffer to ensure we are counting bytes, not UTF8 characters\n  const codeBuffer = Buffer.from(json.code, 'ascii')\n  if (codeBuffer.length !== ILP_ERROR_CODE_LENGTH) {\n    throw new Error('ILP error codes must be three bytes long, received: ' + json.code)\n  }\n\n  writer.write(codeBuffer)\n  writer.writeVarOctetString(Buffer.from(json.triggeredBy, 'ascii'))\n  writer.writeVarOctetString(Buffer.from(json.message, 'utf8'))\n  writer.writeVarOctetString(json.data || Buffer.alloc(0))\n\n  return serializeEnvelope(Type.TYPE_ILP_REJECT, writer.getBuffer())\n}\n\nexport const deserializeIlpReject = (binary: Buffer): IlpRejection => {\n  const { type, contents } = deserializeEnvelope(binary)\n\n  if (type !== Type.TYPE_ILP_REJECT) {\n    throw new Error('Packet has incorrect type')\n  }\n\n  const reader = Reader.from(contents)\n  const code = reader.read(ILP_ERROR_CODE_LENGTH).toString('ascii')\n  const triggeredBy = reader.readVarOctetString().toString('ascii')\n  const message = reader.readVarOctetString().toString('utf8')\n  const data = reader.readVarOctetString()\n\n  return {\n    code,\n    triggeredBy,\n    message,\n    data\n  }\n}\n\nexport const serializeIlpPacket = (obj: IlpPacket) => {\n  switch (obj.type) {\n    case Type.TYPE_ILP_PAYMENT: return serializeIlpPayment(obj.data)\n    case Type.TYPE_ILQP_LIQUIDITY_REQUEST: return serializeIlqpLiquidityRequest(obj.data)\n    case Type.TYPE_ILQP_LIQUIDITY_RESPONSE: return serializeIlqpLiquidityResponse(obj.data)\n    case Type.TYPE_ILQP_BY_SOURCE_REQUEST: return serializeIlqpBySourceRequest(obj.data)\n    case Type.TYPE_ILQP_BY_SOURCE_RESPONSE: return serializeIlqpBySourceResponse(obj.data)\n    case Type.TYPE_ILQP_BY_DESTINATION_REQUEST: return serializeIlqpByDestinationRequest(obj.data)\n    case Type.TYPE_ILQP_BY_DESTINATION_RESPONSE: return serializeIlqpByDestinationResponse(obj.data)\n    case Type.TYPE_ILP_ERROR: return serializeIlpError(obj.data)\n    case Type.TYPE_ILP_FULFILLMENT: return serializeIlpFulfillment(obj.data)\n    case Type.TYPE_ILP_FORWARDED_PAYMENT: return serializeIlpForwardedPayment(obj.data)\n    case Type.TYPE_ILP_REJECTION: return serializeIlpRejection(obj.data)\n    case Type.TYPE_ILP_PREPARE: return serializeIlpPrepare(obj.data)\n    case Type.TYPE_ILP_FULFILL: return serializeIlpFulfill(obj.data)\n    case Type.TYPE_ILP_REJECT: return serializeIlpReject(obj.data)\n    default: throw new Error('Object has invalid type')\n  }\n}\n\nexport const deserializeIlpPacket = (binary: Buffer) => {\n  let packet\n  let typeString\n  switch (binary[0]) {\n    case Type.TYPE_ILP_PAYMENT:\n      packet = deserializeIlpPayment(binary)\n      typeString = 'ilp_payment'\n      break\n    case Type.TYPE_ILQP_LIQUIDITY_REQUEST:\n      packet = deserializeIlqpLiquidityRequest(binary)\n      typeString = 'ilqp_liquidity_request'\n      break\n    case Type.TYPE_ILQP_LIQUIDITY_RESPONSE:\n      packet = deserializeIlqpLiquidityResponse(binary)\n      typeString = 'ilqp_liquidity_response'\n      break\n    case Type.TYPE_ILQP_BY_SOURCE_REQUEST:\n      packet = deserializeIlqpBySourceRequest(binary)\n      typeString = 'ilqp_by_source_request'\n      break\n    case Type.TYPE_ILQP_BY_SOURCE_RESPONSE:\n      packet = deserializeIlqpBySourceResponse(binary)\n      typeString = 'ilqp_by_source_response'\n      break\n    case Type.TYPE_ILQP_BY_DESTINATION_REQUEST:\n      packet = deserializeIlqpByDestinationRequest(binary)\n      typeString = 'ilqp_by_destination_request'\n      break\n    case Type.TYPE_ILQP_BY_DESTINATION_RESPONSE:\n      packet = deserializeIlqpByDestinationResponse(binary)\n      typeString = 'ilqp_by_destination_response'\n      break\n    case Type.TYPE_ILP_ERROR:\n      packet = deserializeIlpError(binary)\n      typeString = 'ilp_error'\n      break\n    case Type.TYPE_ILP_FULFILLMENT:\n      packet = deserializeIlpFulfillment(binary)\n      typeString = 'ilp_fulfillment'\n      break\n    case Type.TYPE_ILP_FORWARDED_PAYMENT:\n      packet = deserializeIlpForwardedPayment(binary)\n      typeString = 'ilp_forwarded_payment'\n      break\n    case Type.TYPE_ILP_REJECTION:\n      packet = deserializeIlpRejection(binary)\n      typeString = 'ilp_rejection'\n      break\n    case Type.TYPE_ILP_PREPARE:\n      packet = deserializeIlpPrepare(binary)\n      typeString = 'ilp_prepare'\n      break\n    case Type.TYPE_ILP_FULFILL:\n      packet = deserializeIlpFulfill(binary)\n      typeString = 'ilp_fulfill'\n      break\n    case Type.TYPE_ILP_REJECT:\n      packet = deserializeIlpReject(binary)\n      typeString = 'ilp_reject'\n      break\n    default:\n      throw new Error('Packet has invalid type')\n  }\n  return {\n    type: binary[0],\n    typeString,\n    data: packet\n  }\n}\n"]}