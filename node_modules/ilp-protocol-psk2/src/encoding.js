"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const crypto = require("crypto");
const oer = require("oer-utils");
const bignumber_js_1 = require("bignumber.js");
const Long = require("long");
const constants = require("./constants");
var Type;
(function (Type) {
    Type[Type["Request"] = 4] = "Request";
    Type[Type["Response"] = 5] = "Response";
    Type[Type["Error"] = 6] = "Error";
})(Type = exports.Type || (exports.Type = {}));
function serializePskPacket(sharedSecret, pskPacket) {
    const { type, requestId, amount, data } = pskPacket;
    assert(Number.isInteger(requestId) && requestId <= constants.MAX_UINT32, 'requestId must be a UInt32');
    assert(amount instanceof bignumber_js_1.default && amount.isInteger() && amount.lte(constants.MAX_UINT64), 'amount must be a UInt64');
    const writer = new oer.Writer();
    writer.writeUInt8(type);
    writer.writeUInt32(requestId);
    writer.writeUInt64(bigNumberToHighLow(amount));
    writer.writeVarOctetString(data);
    const plaintext = writer.getBuffer();
    const ciphertext = encrypt(sharedSecret, plaintext);
    return ciphertext;
}
exports.serializePskPacket = serializePskPacket;
function deserializePskPacket(sharedSecret, buffer) {
    const plaintext = decrypt(sharedSecret, buffer);
    const reader = oer.Reader.from(plaintext);
    const type = reader.readUInt8();
    assert(Type[type], 'PSK packet has unexpected type: ' + type);
    return {
        type,
        requestId: reader.readUInt32(),
        amount: highLowToBigNumber(reader.readUInt64()),
        data: reader.readVarOctetString()
    };
}
exports.deserializePskPacket = deserializePskPacket;
function serializeLegacyPskPacket(sharedSecret, pskPacket) {
    const { type, paymentId, sequence, paymentAmount, chunkAmount, applicationData = Buffer.alloc(0) } = pskPacket;
    assert(Number.isInteger(type) && type < 256, 'type must be a UInt8');
    assert(Buffer.isBuffer(paymentId) && paymentId.length === 16, 'paymentId must be a 16-byte buffer');
    assert(Number.isInteger(sequence) && sequence <= constants.MAX_UINT32, 'sequence must be a UInt32');
    assert(paymentAmount instanceof bignumber_js_1.default && paymentAmount.isInteger() && paymentAmount.lte(constants.MAX_UINT64), 'paymentAmount must be a UInt64');
    assert(chunkAmount instanceof bignumber_js_1.default && chunkAmount.isInteger() && chunkAmount.lte(constants.MAX_UINT64), 'chunkAmount must be a UInt64');
    assert(Buffer.isBuffer(applicationData), 'applicationData must be a buffer');
    const writer = new oer.Writer();
    writer.writeUInt8(type);
    writer.writeOctetString(paymentId, 16);
    writer.writeUInt32(sequence);
    writer.writeUInt64(bigNumberToHighLow(paymentAmount));
    writer.writeUInt64(bigNumberToHighLow(chunkAmount));
    writer.writeVarOctetString(applicationData);
    writer.writeUInt8(0);
    const contents = writer.getBuffer();
    const ciphertext = encrypt(sharedSecret, contents);
    return ciphertext;
}
exports.serializeLegacyPskPacket = serializeLegacyPskPacket;
function deserializeLegacyPskPacket(sharedSecret, ciphertext) {
    const contents = decrypt(sharedSecret, ciphertext);
    const reader = new oer.Reader(contents);
    return {
        type: reader.readUInt8(),
        paymentId: reader.readOctetString(16),
        sequence: reader.readUInt32(),
        paymentAmount: highLowToBigNumber(reader.readUInt64()),
        chunkAmount: highLowToBigNumber(reader.readUInt64()),
        applicationData: reader.readVarOctetString()
    };
}
exports.deserializeLegacyPskPacket = deserializeLegacyPskPacket;
function encrypt(secret, data) {
    const iv = crypto.randomBytes(constants.IV_LENGTH);
    const pskEncryptionKey = hmac(secret, Buffer.from(constants.PSK_ENCRYPTION_STRING, 'utf8'));
    const cipher = crypto.createCipheriv(constants.ENCRYPTION_ALGORITHM, pskEncryptionKey, iv);
    const encryptedInitial = cipher.update(data);
    const encryptedFinal = cipher.final();
    const tag = cipher.getAuthTag();
    return Buffer.concat([
        iv,
        tag,
        encryptedInitial,
        encryptedFinal
    ]);
}
function decrypt(secret, data) {
    assert(data.length > 0, 'cannot decrypt empty buffer');
    const pskEncryptionKey = hmac(secret, Buffer.from(constants.PSK_ENCRYPTION_STRING, 'utf8'));
    const nonce = data.slice(0, constants.IV_LENGTH);
    const tag = data.slice(constants.IV_LENGTH, constants.IV_LENGTH + constants.AUTH_TAG_LENGTH);
    const encrypted = data.slice(constants.IV_LENGTH + constants.AUTH_TAG_LENGTH);
    const decipher = crypto.createDecipheriv(constants.ENCRYPTION_ALGORITHM, pskEncryptionKey, nonce);
    decipher.setAuthTag(tag);
    return Buffer.concat([
        decipher.update(encrypted),
        decipher.final()
    ]);
}
function hmac(key, message) {
    const h = crypto.createHmac('sha256', key);
    h.update(message);
    return h.digest();
}
function highLowToBigNumber(highLow) {
    const long = Long.fromBits(highLow[1], highLow[0], true);
    return new bignumber_js_1.default(long.toString(10));
}
function bigNumberToHighLow(bignum) {
    const long = Long.fromString(bignum.toString(10), true);
    return [long.getHighBitsUnsigned(), long.getLowBitsUnsigned()];
}
//# sourceMappingURL=encoding.js.map