{"version":3,"file":"sender.js","sourceRoot":"","sources":["sender.ts"],"names":[],"mappings":"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","sourcesContent":["import * as assert from 'assert'\nimport * as crypto from 'crypto'\nimport * as Debug from 'debug'\nimport BigNumber from 'bignumber.js'\nimport * as IlpPacket from 'ilp-packet'\nimport { default as convert, PluginV1, PluginV2 } from 'ilp-compat-plugin'\nimport * as constants from './constants'\nimport * as encoding from './encoding'\nimport { dataToFulfillment, fulfillmentToCondition } from './condition'\n\nconst DEFAULT_TRANSFER_TIMEOUT = 30000\nconst STARTING_TRANSFER_AMOUNT = 1000\nconst TRANSFER_INCREASE = 1.1\nconst TRANSFER_DECREASE = 0.5\n\n/** Parameters for the [`sendRequest`]{@link sendRequest} method */\nexport interface SendRequestParams {\n  /** Shared secret from the Receiver (generated with the [`generateAddressAndSecret`]{@link Receiver.generateAddressAndSecret} method). */\n  sharedSecret: Buffer,\n  /** Destination account of the Receiver (generated with the [`generateAddressAndSecret`]{@link Receiver.generateAddressAndSecret} method). */\n  destinationAccount: string,\n  /** Amount to send, denominated in the minimum units on the sender's ledger */\n  sourceAmount: BigNumber | string | number,\n  /** Data to send to the receiver (will be encrypted and authenticated) */\n  data?: Buffer,\n  /** Minimum destination amount the receiver should accept, denominated in the minimum units of the receiver's ledger */\n  minDestinationAmount?: BigNumber | string | number,\n  /** Optional ID for the request, which is used to correlate requests and responses. Defaults to a random UInt32 */\n  requestId?: number,\n  /** Expiry time for the ILP Prepare packet, defaults to 30 seconds from when the request is created */\n  expiresAt?: Date,\n  /**\n   * Option to use an unfulfillable condition. For example, this may be used to send test payments for quotes.\n   *\n   * It is recommended to either generate this using crypto.randomBytes(32) or Buffer.alloc(32, 0).\n   */\n  unfulfillableCondition?: Buffer\n}\n\n/** Successful response indicating the payment was sent */\nexport interface PskResponse {\n  /** Always true for PskResponses */\n  fulfilled: boolean,\n  // TODO should there be a field like \"fulfilled\" for developers who are not using Typescript?\n  /**\n   * Amount that the receiver says they received. Note: you must trust the receiver not to lie about this.\n   *\n   * If the PSK packet the receiver sends back is tampered with or otherwise not understandable, this will be set to 0.\n   */\n  destinationAmount: BigNumber,\n  /**\n   * Authenticated response from the receiver.\n   *\n   * If the PSK packet the receiver sends back is tampered with or otherwise not understandable, this will be set to an empty buffer.\n   */\n  data: Buffer\n}\n\n/** Error response indicating the payment was rejected */\nexport interface PskError {\n  /** Always false for PskErrors */\n  fulfilled: boolean,\n  /** ILP Error Code (for example, `'F99'`) */\n  code: string,\n  /** Error message. Note this is **not** authenticated and does not necessarily come from the receiver */\n  message: string,\n  /** ILP Address of the party that rejected the packet */\n  triggeredBy: string,\n  /**\n   * Amount that the receiver says they received. Note: you must trust the receiver not to lie about this.\n   *\n   * If the PSK packet the receiver sends back is tampered with or otherwise not understandable, this will be set to 0.\n   */\n  destinationAmount: BigNumber,\n  /**\n   * Authenticated response from the receiver.\n   *\n   * If the PSK packet the receiver sends back is tampered with or otherwise not understandable, this will be set to an empty buffer.\n   */\n  data: Buffer,\n\n  /**\n   * Unauthenticated data that is _probably not_ from the receiver.\n   *\n   * This may be produced by a connector, for example if the error should contain machine-readable information.\n   */\n  unauthenticatedData: Buffer\n}\n\nexport function isPskResponse (result: PskResponse | PskError): result is PskResponse {\n  return result.fulfilled\n}\n\nexport function isPskError (result: PskResponse | PskError): result is PskError {\n  return !result.fulfilled\n}\n\n/**\n * Send a PSK2 request. This may be any of: a one-off payment, an unfulfillable packet for a quote, or one chunk of a streaming payment.\n *\n * @example <caption>One-off payment</caption>\n * ```typescript\n *   import { sendRequest } from 'ilp-protocol-psk2'\n *\n *   // These values must be communicated beforehand for the sender to send a payment\n *   const { destinationAccount, sharedSecret } = await getAddressAndSecretFromReceiver()\n *\n *   const { destinationAmount, data } = await sendRequest(myLedgerPlugin, {\n *     destinationAccount,\n *     sharedSecret,\n *     destinationAmount: '1000',\n *     data: Buffer.from('hello', 'utf8')\n *   })\n *\n *   console.log(`Sent payment of: 1000. Receiver got: ${result.destinationAmount}`)\n *   console.log(`Receiver responded: ${data.toString('utf8')}`)\n *   // Note the data encoding and content is up to the application\n * ```\n *\n * @example <caption>Quote (unfulfillable test payment)</caption>\n * ```typescript\n *   import { sendRequest } from 'ilp-protocol-psk2'\n *\n *   // These values must be communicated beforehand for the sender to send a payment\n *   const { destinationAccount, sharedSecret } = await getAddressAndSecretFromReceiver()\n *\n *   const { destinationAmount, data } = await sendRequest(myLedgerPlugin, {\n *     destinationAccount,\n *     sharedSecret,\n *     destinationAmount: '1000',\n *     unfulfillableCondition: 'random'\n *   })\n *   const rate = destinationAmount.dividedBy('1000')\n *\n *   console.log(`Path exchange rate is: ${rate}`)\n * ```\n */\nexport async function sendRequest (plugin: PluginV2, params: SendRequestParams): Promise<PskResponse | PskError> {\n  const debug = Debug('ilp-protocol-psk2:sendRequest')\n\n  const requestId = (typeof params.requestId === 'number' ? params.requestId : Math.floor(Math.random() * (constants.MAX_UINT32 + 1)))\n  const sourceAmount = new BigNumber(params.sourceAmount)\n\n  // If the minDestinationAmount is provided, use that\n  // Otherwise, set it to 0 unless the unfulfillableCondition is set, in which case we set it to the maximum value\n  // (This ensures that receivers will respond with the amount they received, as long as they check the amount before the condition)\n  let minDestinationAmount: BigNumber\n  if (params.minDestinationAmount !== undefined) {\n    minDestinationAmount = new BigNumber(params.minDestinationAmount)\n  } else if (params.unfulfillableCondition !== undefined) {\n    minDestinationAmount = constants.MAX_UINT64\n  } else {\n    minDestinationAmount = new BigNumber(0)\n  }\n  assert(Number.isInteger(requestId) && requestId <= constants.MAX_UINT32, 'requestId must be a UInt32')\n  assert(sourceAmount.isInteger() && sourceAmount.lessThanOrEqualTo(constants.MAX_UINT64), 'sourceAmount must be a UInt64')\n  assert(minDestinationAmount.isInteger() && minDestinationAmount.lessThanOrEqualTo(constants.MAX_UINT64), 'minDestinationAmount must be a UInt64')\n\n  // TODO enforce data limit\n\n  const pskPacket = encoding.serializePskPacket(params.sharedSecret, {\n    type: encoding.Type.Request,\n    requestId,\n    amount: new BigNumber(params.minDestinationAmount || 0),\n    data: params.data || Buffer.alloc(0)\n  })\n  let fulfillment\n  let executionCondition\n  if (params.unfulfillableCondition) {\n    assert(params.unfulfillableCondition.length === 32, 'unfulfillableCondition must be 32 bytes')\n    debug(`using user-specified unfulfillable condition for request: ${requestId}`)\n    executionCondition = params.unfulfillableCondition\n  } else {\n    fulfillment = dataToFulfillment(params.sharedSecret, pskPacket)\n    executionCondition = fulfillmentToCondition(fulfillment)\n  }\n  const prepare = IlpPacket.serializeIlpPrepare({\n    destination: params.destinationAccount,\n    amount: new BigNumber(params.sourceAmount).toString(10),\n    executionCondition,\n    expiresAt: params.expiresAt || new Date(Date.now() + DEFAULT_TRANSFER_TIMEOUT),\n    data: pskPacket\n  })\n\n  debug(`sending request ${requestId} for amount: ${params.sourceAmount}`)\n  const response = await plugin.sendData(prepare)\n\n  if (!Buffer.isBuffer(response) || response.length === 0) {\n    throw new Error('Got empty response from plugin.sendData')\n  }\n\n  let packet: IlpPacket.IlpFulfill | IlpPacket.IlpRejection\n  try {\n    const parsed = IlpPacket.deserializeIlpPacket(response)\n    if (parsed.type === IlpPacket.Type.TYPE_ILP_FULFILL || parsed.type === IlpPacket.Type.TYPE_ILP_REJECT) {\n      packet = parsed.data as IlpPacket.IlpFulfill | IlpPacket.IlpRejection\n    } else {\n      throw new Error('Unexpected ILP packet type: ' + parsed.type)\n    }\n  } catch (err) {\n    debug('error parsing prepare response:', err, response && response.toString('hex'))\n    throw new Error('Unable to parse response from plugin.sendData')\n  }\n\n  // Try sending a legacy packet if we got an Unexpected Payment error\n  // (This functionality will be removed in the next version)\n  if (!isFulfill(packet) && packet.code === 'F06' && packet.data.length === 0) {\n    debug(`got an F06 error for request ${requestId}, trying to send a legacy packet instead`)\n    if (params.unfulfillableCondition) {\n      try {\n        const quote = await quoteSourceAmount(plugin, {\n          destinationAccount: params.destinationAccount,\n          sharedSecret: params.sharedSecret,\n          sourceAmount: params.sourceAmount\n        })\n        return {\n          fulfilled: false,\n          code: 'F99',\n          message: '',\n          triggeredBy: params.destinationAccount,\n          data: Buffer.alloc(0),\n          destinationAmount: new BigNumber(quote.destinationAmount)\n        }\n      } catch (err) {\n        debug(`sending a legacy quote request did not work either for request ${requestId}:`, err)\n        return {\n          ...packet,\n          fulfilled: false,\n          destinationAmount: new BigNumber(0)\n        }\n      }\n    } else {\n      try {\n        debug(`sending a legacy single chunk for request: ${requestId}`)\n        // If the data is exactly 20 bytes, assume it is the paymentId and sequence for compatbility purposes\n        let id: Buffer\n        if (Buffer.isBuffer(params.data) && (params.data.length === 20 || params.data.length === 16)) {\n          id = params.data.slice(0, 16)\n        } else {\n          id = Buffer.alloc(16, 0)\n        }\n        const result = await sendSingleChunk(plugin, {\n          id,\n          destinationAccount: params.destinationAccount,\n          sharedSecret: params.sharedSecret,\n          sourceAmount: params.sourceAmount,\n          sequence: requestId,\n          minDestinationAmount: params.minDestinationAmount,\n          lastChunk: false\n        })\n        return {\n          fulfilled: true,\n          destinationAmount: new BigNumber(result.destinationAmount),\n          data: Buffer.alloc(0)\n        }\n      } catch (err) {\n        debug(`sending a legacy single chunk did not work either for request ${requestId}:`, err)\n        return {\n          ...packet,\n          fulfilled: false,\n          destinationAmount: new BigNumber(0)\n        }\n      }\n    }\n  }\n\n  let pskResponsePacket: encoding.PskPacket\n  let unauthenticatedData = Buffer.alloc(0)\n  if (packet.data.length > 0) {\n    try {\n      pskResponsePacket = encoding.deserializePskPacket(params.sharedSecret, packet.data)\n    } catch (err) {\n      debug('error parsing PSK response packet:', packet.data.toString('hex'), err)\n      unauthenticatedData = packet.data\n    }\n  }\n  /* tslint:disable-next-line:no-unnecessary-type-assertion */\n  pskResponsePacket = pskResponsePacket!\n\n  // Return the fields from the response packet only if the request ID and PSK packet type are what we expect\n  let destinationAmount\n  let data\n  const expectedType = (isFulfill(packet) ? encoding.Type.Response : encoding.Type.Error)\n  if (!pskResponsePacket) {\n    destinationAmount = new BigNumber(0)\n    data = Buffer.alloc(0)\n  } else if (pskResponsePacket.type !== expectedType) {\n    console.warn(`Received PSK response packet whose type should be ${expectedType} but is ${pskResponsePacket.type}. Either the receiver is faulty or a connector is messing with us`)\n    destinationAmount = new BigNumber(0)\n    data = Buffer.alloc(0)\n  } else if (pskResponsePacket.requestId !== requestId) {\n    console.warn(`Received PSK response packet whose ID (${pskResponsePacket.requestId}) does not match our request (${requestId}). either the receiver is faulty or a connector is messing with us`)\n    destinationAmount = new BigNumber(0)\n    data = Buffer.alloc(0)\n  } else {\n    destinationAmount = pskResponsePacket.amount\n    data = pskResponsePacket.data\n  }\n\n  if (isFulfill(packet)) {\n    debug(`request ${requestId} was fulfilled`)\n    return {\n      fulfilled: true,\n      destinationAmount,\n      data\n    }\n  } else {\n    debug(`request ${requestId} was rejected with code: ${packet.code}`)\n    return {\n      fulfilled: false,\n      code: packet.code,\n      message: packet.message,\n      triggeredBy: packet.triggeredBy,\n      destinationAmount,\n      data,\n      unauthenticatedData\n    }\n  }\n}\n\nfunction isFulfill (packet: IlpPacket.IlpFulfill | IlpPacket.IlpRejection): packet is IlpPacket.IlpFulfill {\n  return packet.hasOwnProperty('fulfillment')\n}\n\n/** Parameters for the [`quoteSourceAmount`]{@link quoteSourceAmount} method. */\nexport interface QuoteSourceParams {\n  /**\n   * Integer amount indicating how much the sender would like to send.\n   *\n   * **Note:** The `quoteSourceAmount` method will send an unfulfillable test payment of this amount to the Receiver to determine the path exchange rate.\n   */\n  sourceAmount: BigNumber | string | number,\n  /** Shared secret from the Receiver (generated with the [`generateAddressAndSecret`]{@link Receiver.generateAddressAndSecret} method). */\n  sharedSecret: Buffer,\n  /** Destination account of the Receiver (generated with the [`generateAddressAndSecret`]{@link Receiver.generateAddressAndSecret} method). */\n  destinationAccount: string,\n  /** Optional ID that will be used as the PSK Payment ID. A random one will be used if none is provided. */\n  id?: Buffer\n}\n\n/** Parameters for the [`quoteDestinationAmount`]{@link quoteDestinationAmount} method. */\nexport interface QuoteDestinationParams {\n  /**\n   * Integer amount indicating how much the sender would like to deliver to the Receiver, denoted in the Receiver's units.\n   *\n   * **Note:** The `quoteDestinationAmount` method will send an unfulfillable test payment of 1000 source units to the Receiver to determine the path exchange rate.\n   */\n  destinationAmount: BigNumber | string | number,\n  /** Shared secret from the Receiver (generated with the [`generateAddressAndSecret`]{@link Receiver.generateAddressAndSecret} method). */\n  sharedSecret: Buffer,\n  /** Destination account of the Receiver (generated with the [`generateAddressAndSecret`]{@link Receiver.generateAddressAndSecret} method). */\n  destinationAccount: string,\n  /** Optional ID that will be used as the PSK Payment ID. A random one will be used if none is provided. */\n  id?: Buffer\n}\n\n/** Quote result from either the [`quoteSourceAmount`]{@link quoteSourceAmount} or [`quoteDestinationAmount`]{@link quoteDestinationAmount} methods. */\nexport interface QuoteResult {\n  /** Integer amount indicating approximately how much the sender must send in order to deliver the given destination amount to the Receiver. */\n  sourceAmount: string,\n  /** Integer amount indicating approximately how much will be delivered to the Receiver if the sender sends the given destination amoutn. Denominated in the Receiver's units. */\n  destinationAmount: string\n}\n\n/** Parameters for the [`sendSingleChunk`]{@link sendSingleChunk} method to send a one-off payment. */\nexport interface SendSingleChunkParams {\n  /** Integer amount indicating how much should be sent. Denoted in the sender's units. */\n  sourceAmount: BigNumber | string | number,\n  /** Shared secret from the Receiver (generated with the [`generateAddressAndSecret`]{@link Receiver.generateAddressAndSecret} method). */\n  sharedSecret: Buffer,\n  /** Destination account of the Receiver (generated with the [`generateAddressAndSecret`]{@link Receiver.generateAddressAndSecret} method). */\n  destinationAccount: string,\n  /**\n   * Minimum amount that the Receiver should get in order for them to fulfill the payment. Defaults to `0`.\n   *\n   * If the sender gets a quote before sending, they SHOULD set this value to the destination amount they expect will be delivered.\n   * A `0`-amount means that the Receiver will fulfill the payment even if the connectors charge unreasonably high fees.\n   */\n  minDestinationAmount?: BigNumber | string | number,\n}\n\n/** Parameters for the [`sendSingleChunk`]{@link sendSingleChunk} method that give the user more control and may be used for streaming payments. */\nexport interface SendSingleChunkAdvancedParams {\n  /** See [SendSingleChunkParams]{@link SendSingleChunkParams} */\n  sourceAmount: BigNumber | string | number,\n  /** See [SendSingleChunkParams]{@link SendSingleChunkParams} */\n  sharedSecret: Buffer,\n  /** See [SendSingleChunkParams]{@link SendSingleChunkParams} */\n  destinationAccount: string\n  /** See [SendSingleChunkParams]{@link SendSingleChunkParams} */\n  minDestinationAmount?: BigNumber | string | number,\n  /**\n   * Optional ID that will be used as the PSK Payment ID and that the Receiver will use to group payment chunks. Defaults to a random 16-byte ID.\n   *\n   * This value must be set if the sender wants the Receiver to associate multiple payment chunks with one payment or interaction.\n   *\n   * If this value is set, the user MUST increment the `sequence` number for each chunk fulfilled.\n   */\n  id: Buffer,\n  /**\n   * Sequence number for the chunk within a larger payment. Defaults to `0`.\n   *\n   * If the `id` is set, this value MUST be incremented for each chunk fulfilled.\n   */\n  sequence: number,\n  /**\n   * Indicates to the Receiver whether this is the last chunk of the given payment `id`. Defaults to `true`.\n   *\n   * Once the Receiver has received a chunk with the last chunk flag set, they will no longer accept more chunks\n   */\n  lastChunk: boolean\n}\n\n/** Return value from [`sendSingleChunk`]{@link sendSingleChunk}, [`sendSourceAmount`]{@link sendSourceAmount}, and [`sendDestinationAmount`]{@link sendDestinationAmount}. */\nexport interface SendResult {\n  id: Buffer,\n  /** Integer amount that the sender sent. Denoted in the sender's currency and units. */\n  sourceAmount: string,\n  /** Integer amount that the receiver says they received. Denoted in the receiver's currency and units. */\n  destinationAmount: string,\n  /** The number of payment chunks that were sent successfully as part of this payment. */\n  chunksFulfilled: number,\n  /** The number of payment chunks that were rejected as part of this payment. */\n  chunksRejected: number\n}\n\n/** Parameters for sending a chunked payment with the **experimental** [`sendSourceAmount`]{@link sendSourceAmount} method */\nexport interface SendSourceParams {\n  /** Source amount that the sender will send. Denoted in the sender's currency and units. This may be split into multiple chunks. */\n  sourceAmount: BigNumber | string | number,\n  /** Shared secret from the Receiver (generated with the [`generateAddressAndSecret`]{@link Receiver.generateAddressAndSecret} method). */\n  sharedSecret: Buffer,\n  /** Destination account of the Receiver (generated with the [`generateAddressAndSecret`]{@link Receiver.generateAddressAndSecret} method). */\n  destinationAccount: string,\n  /** Optional ID that will be used as the PSK Payment ID. Defaults to a random 16-byte ID. */\n  id?: Buffer\n}\n\n/** Parameters for sending a chunked payment with the **experimental** [`sendDestinationAmount`]{@link sendDestinationAmount} method */\nexport interface SendDestinationParams {\n  /**\n   * Destination amount that will be delivered to the Receiver. Denoted in the receiver's currency and units.\n   *\n   * **Note:** The sender will keep sending payment chunks until the receiver says they have gotten this amount. This method SHOULD NOT be used with untrusted receivers.\n   */\n  destinationAmount: BigNumber | string | number,\n  /** Shared secret from the Receiver (generated with the [`generateAddressAndSecret`]{@link Receiver.generateAddressAndSecret} method). */\n  sharedSecret: Buffer,\n  /** Destination account of the Receiver (generated with the [`generateAddressAndSecret`]{@link Receiver.generateAddressAndSecret} method). */\n  destinationAccount: string,\n  /** Optional ID that will be used as the PSK Payment ID. Defaults to a random 16-byte ID. */\n  id?: Buffer\n}\n\n/**\n * @deprecated Use sendRequest with an unfulfillable condition instead.\n */\nexport async function quoteSourceAmount (plugin: PluginV2 | PluginV1, params: QuoteSourceParams) {\n  console.warn('DeprecationWarning: quoteSourceAmount is deprecated and will be removed in the next version. Use sendRequest with an unfulfillable condition instead')\n  let {\n    sourceAmount,\n    sharedSecret,\n    destinationAccount,\n    id = crypto.randomBytes(16)\n  } = params\n  sourceAmount = new BigNumber(sourceAmount)\n  assert(sourceAmount.isInteger(), 'sourceAmount must be an integer')\n  assert(sharedSecret, 'sharedSecret is required')\n  assert(sharedSecret.length >= 32, 'sharedSecret must be at least 32 bytes')\n  /* tslint:disable-next-line:strict-type-predicates */\n  assert(destinationAccount && typeof destinationAccount === 'string', 'destinationAccount is required')\n  assert((Buffer.isBuffer(id) && id.length === 16), 'id must be a 16-byte buffer')\n  return quote(plugin, sharedSecret, id, destinationAccount, sourceAmount, undefined)\n}\n\n/**\n * @deprecated Use sendRequest with an unfulfillable condition instead.\n */\nexport async function quoteDestinationAmount (plugin: PluginV2 | PluginV1, params: QuoteDestinationParams) {\n  console.warn('DeprecationWarning: quoteDestinationAmount is deprecated and will be removed in the next version. Use sendRequest with an unfulfillable condition instead')\n  let {\n    destinationAmount,\n    sharedSecret,\n    destinationAccount,\n    id = crypto.randomBytes(16)\n  } = params\n  destinationAmount = new BigNumber(destinationAmount)\n  assert(destinationAmount.isInteger(), 'destinationAmount must be an integer')\n  assert(sharedSecret, 'sharedSecret is required')\n  assert(sharedSecret.length >= 32, 'sharedSecret must be at least 32 bytes')\n  /* tslint:disable-next-line:strict-type-predicates */\n  assert(destinationAccount && typeof destinationAccount === 'string', 'destinationAccount is required')\n  assert((Buffer.isBuffer(id) && id.length === 16), 'id must be a 16-byte buffer if supplied')\n  return quote(plugin, sharedSecret, id, destinationAccount, undefined, destinationAmount)\n}\n\nasync function quote (\n  plugin: PluginV2 | PluginV1,\n  sharedSecret: Buffer,\n  id: Buffer,\n  destinationAccount: string,\n  sourceAmount?: BigNumber,\n  destinationAmount?: BigNumber\n): Promise<QuoteResult> {\n  plugin = convert(plugin)\n  const debug = Debug('ilp-protocol-psk2:quote')\n\n  const sequence = 0\n  const data = encoding.serializeLegacyPskPacket(\n    sharedSecret, {\n      // TODO should this be the last chunk? what if you want to use the same id for the quote and payment?\n      type: constants.TYPE_PSK2_LAST_CHUNK,\n      paymentId: id,\n      sequence,\n      paymentAmount: constants.MAX_UINT64,\n      // Setting the chunk amount to the max will cause the receiver to\n      // reject the chunk (though we also make the condition unfulfillable\n      // to ensure that they cannot fulfill the chunk)\n      chunkAmount: constants.MAX_UINT64\n    })\n  const amount = new BigNumber(sourceAmount || STARTING_TRANSFER_AMOUNT).toString(10)\n  const ilp = IlpPacket.serializeIlpPrepare({\n    destination: destinationAccount,\n    amount,\n    executionCondition: crypto.randomBytes(32),\n    expiresAt: new Date(Date.now() + DEFAULT_TRANSFER_TIMEOUT),\n    data\n  })\n\n  let amountArrived = new BigNumber(0)\n  const result = await plugin.sendData(ilp)\n  let rejection\n  try {\n    rejection = IlpPacket.deserializeIlpReject(result)\n    assert(rejection.code === 'F99', `Got unexpected error code: ${rejection.code} ${rejection.message}`)\n    assert(rejection.data.length > 0, 'Got empty response data')\n  } catch (err) {\n    debug('error deserializing quote response:', err)\n    throw new Error('Error getting quote: ' + err.message)\n  }\n\n  try {\n    const quoteResponse = encoding.deserializeLegacyPskPacket(sharedSecret, rejection.data)\n\n    // Validate that this is actually the response to our request\n    assert(quoteResponse.type === constants.TYPE_PSK2_REJECT, 'response type must be error')\n    assert(id.equals(quoteResponse.paymentId), 'response Payment ID does not match outgoing quote')\n    assert(sequence === quoteResponse.sequence, 'sequence does not match outgoing quote')\n\n    amountArrived = quoteResponse.chunkAmount\n  } catch (decryptionErr) {\n    debug('error parsing encrypted quote response', decryptionErr, result.toString('base64'))\n    throw new Error('unable to parse quote response')\n  }\n\n  debug(`receiver got: ${amountArrived.toString(10)} when sender sent: ${amount} (rate: ${amountArrived.div(amount).toString(10)})`)\n  let quotedSourceAmount\n  let quotedDestinationAmount\n  if (sourceAmount) {\n    quotedSourceAmount = new BigNumber(sourceAmount)\n    quotedDestinationAmount = amountArrived\n  } else {\n    quotedSourceAmount = new BigNumber(destinationAmount as BigNumber)\n      .div(amountArrived)\n      .times(STARTING_TRANSFER_AMOUNT)\n      .round(0, BigNumber.ROUND_UP)\n    // TODO should we always round up or just half up?\n    quotedDestinationAmount = new BigNumber(destinationAmount as BigNumber)\n  }\n  return {\n    sourceAmount: quotedSourceAmount.toString(10),\n    destinationAmount: quotedDestinationAmount.toString(10)\n  }\n}\n\n/**\n * @deprecated Use [`sendRequest`]{@link sendRequest} instead\n */\nexport async function sendSingleChunk (plugin: any, params: SendSingleChunkParams | SendSingleChunkAdvancedParams): Promise<SendResult> {\n  console.warn('DeprecationWarning: sendSingleChunk is deprecated and will be removed in the next version. Use sendRequest instead')\n  plugin = convert(plugin)\n  const debug = Debug('ilp-protocol-psk2:sendSingleChunk')\n  const {\n    sourceAmount,\n    sharedSecret,\n    destinationAccount,\n    minDestinationAmount = 0\n  } = params\n\n  function isAdvanced (params: SendSingleChunkParams | SendSingleChunkAdvancedParams): params is SendSingleChunkAdvancedParams {\n    /* tslint:disable-next-line */\n    return (params as SendSingleChunkAdvancedParams).id !== undefined\n  }\n  const {\n    id,\n    sequence,\n    lastChunk\n  } = (isAdvanced(params) ? params : {\n    // Defaults\n    id: crypto.randomBytes(16),\n    sequence: 0,\n    lastChunk: true\n  })\n\n  assert(sharedSecret, 'sharedSecret is required')\n  assert(sharedSecret.length >= 32, 'sharedSecret must be at least 32 bytes')\n  assert(sourceAmount, 'sourceAmount is required')\n  assert(!id || (Buffer.isBuffer(id) && id.length === 16), 'id must be a 16-byte buffer if supplied')\n\n  debug(`sending single chunk payment ${id.toString('hex')} with source amount: ${sourceAmount} and minimum destination amount: ${minDestinationAmount}`)\n\n  const data = encoding.serializeLegacyPskPacket(sharedSecret, {\n    type: (lastChunk ? constants.TYPE_PSK2_LAST_CHUNK : constants.TYPE_PSK2_CHUNK),\n    paymentId: id,\n    sequence,\n    // We don't set the paymentAmount to the minDestinationAmount just in case\n    // we deliver slightly too much (for example because of rounding issues) and we\n    // don't want the receiver to reject the transfer because of this\n    paymentAmount: constants.MAX_UINT64,\n    chunkAmount: new BigNumber(minDestinationAmount)\n  })\n  const fulfillment = dataToFulfillment(sharedSecret, data)\n  const executionCondition = fulfillmentToCondition(fulfillment)\n  const ilp = IlpPacket.serializeIlpPrepare({\n    destination: destinationAccount,\n    amount: new BigNumber(sourceAmount).toString(10),\n    executionCondition,\n    expiresAt: new Date(Date.now() + DEFAULT_TRANSFER_TIMEOUT),\n    data\n  })\n\n  const result = await plugin.sendData(ilp)\n\n  let parsed\n  try {\n    parsed = IlpPacket.deserializeIlpPacket(result)\n  } catch (err) {\n    debug('error parsing sendData response:', err, 'response:', result.toString('base64'))\n    throw err\n  }\n\n  let fulfillmentInfo: IlpPacket.IlpFulfill\n  if (parsed.type === IlpPacket.Type.TYPE_ILP_FULFILL) {\n    /* tslint:disable-next-line:no-unnecessary-type-assertion */\n    fulfillmentInfo = parsed.data as IlpPacket.IlpFulfill\n  } else if (parsed.type === IlpPacket.Type.TYPE_ILP_REJECT) {\n    /* tslint:disable-next-line:no-unnecessary-type-assertion */\n    const rejection: IlpPacket.IlpRejection = parsed.data as IlpPacket.IlpRejection\n    // TODO throw specific error if the receiver says they received too little\n    // TODO use ILP error code string\n    debug('error sending payment:', JSON.stringify(rejection))\n    throw new Error(`Error sending payment. code: ${rejection.code}, message: ${rejection.message} `)\n  } else {\n    debug('sendData returned unexpected packet type:', JSON.stringify(parsed))\n    throw new Error('Unexpected type for sendData response: ' + parsed.type)\n  }\n\n  if (!fulfillment.equals(fulfillmentInfo.fulfillment)) {\n    debug(`Received invalid fulfillment. expected: ${fulfillment.toString('base64')}, actual: ${fulfillmentInfo.fulfillment.toString('base64')}`)\n    throw new Error(`Received invalid fulfillment. expected: ${fulfillment.toString('base64')}, actual: ${fulfillmentInfo.fulfillment.toString('base64')}`)\n  }\n\n  let amountArrived\n  try {\n    const response = encoding.deserializeLegacyPskPacket(sharedSecret, fulfillmentInfo.data)\n\n    assert(constants.TYPE_PSK2_FULFILLMENT === response.type, `unexpected PSK packet type. expected: ${constants.TYPE_PSK2_FULFILLMENT}, actual: ${response.type}`)\n    assert(id.equals(response.paymentId), `response does not correspond to request. payment id does not match. actual: ${response.paymentId.toString('hex')}, expected: ${id.toString('hex')}`)\n    assert(sequence === response.sequence, `response does not correspond to request. sequence does not match. actual: ${response.sequence}, expected: ${sequence}`)\n\n    amountArrived = response.chunkAmount\n  } catch (err) {\n    debug('got invalid response:', err, JSON.stringify(result))\n    throw new Error('Invalid response from receiver: ' + err.message)\n  }\n\n  debug(`sent single chunk payment ${id.toString('hex')} with source amount: ${sourceAmount}, destination amount: ${amountArrived.toString(10)}`)\n\n  return {\n    // TODO should this be a buffer or string?\n    id,\n    sourceAmount: new BigNumber(sourceAmount).toString(10),\n    destinationAmount: amountArrived.toString(10),\n    chunksFulfilled: 1,\n    chunksRejected: 0\n  }\n}\n\n/**\n * @deprecated PSK2 no longer includes chunked payments. They will be implemented in a separate protocol / module.\n */\nexport async function sendSourceAmount (plugin: any, params: SendSourceParams): Promise<SendResult> {\n  console.warn('DeprecationWarning: Chunked payments are deprecated in this module and will be removed in the next version. Chunked payments will be implemented by a separate protocol / module that properly handles segmentation and reassembly of money and data.')\n  assert(params.sourceAmount, 'sourceAmount is required')\n  return sendChunkedPayment(plugin, params)\n}\n\n/**\n * @deprecated PSK2 no longer includes chunked payments. They will be implemented in a separate protocol / module.\n */\nexport async function sendDestinationAmount (plugin: any, params: SendDestinationParams): Promise<SendResult> {\n  console.warn('DeprecationWarning: Chunked payments are deprecated in this module and will be removed in the next version. Chunked payments will be implemented by a separate protocol / module that properly handles segmentation and reassembly of money and data.')\n  // TODO allow setting a maximum source amount? (the problem would be that even if you hit the max, you still would have sent it without delivering the destination amount)\n  assert(params.destinationAmount, 'destinationAmount is required')\n  return sendChunkedPayment(plugin, params)\n}\n\ninterface ChunkedPaymentParams {\n  sharedSecret: Buffer,\n  destinationAccount: string,\n  sourceAmount?: BigNumber | string | number,\n  destinationAmount?: BigNumber | string | number,\n  id?: Buffer\n}\n// TODO accept user data also\nasync function sendChunkedPayment (plugin: any, params: ChunkedPaymentParams): Promise<SendResult> {\n  const {\n    sharedSecret,\n    destinationAccount,\n    sourceAmount,\n    destinationAmount,\n    id = crypto.randomBytes(16)\n  } = params\n  assert(sharedSecret, 'sharedSecret is required')\n  assert(sharedSecret.length >= 32, 'sharedSecret must be at least 32 bytes')\n  assert(destinationAccount, 'destinationAccount is required')\n  assert((Buffer.isBuffer(id) && id.length === 16), 'id must be a 16-byte buffer if supplied')\n  plugin = convert(plugin)\n  const debug = Debug('ilp-protocol-psk2:chunkedPayment')\n\n  let amountSent = new BigNumber(0)\n  let amountDelivered = new BigNumber(0)\n  let sequence = 0\n  let chunkSize = new BigNumber(STARTING_TRANSFER_AMOUNT)\n  let lastChunk = false\n  let timeToWait = 0\n  let rate = new BigNumber(0)\n  let chunksFulfilled = 0\n  let chunksRejected = 0\n\n  function handleReceiverResponse (encrypted: Buffer, expectedType: number, expectedSequence: number) {\n    try {\n      const response = encoding.deserializeLegacyPskPacket(sharedSecret, encrypted)\n\n      assert(expectedType === response.type, `unexpected packet type. expected: ${expectedType}, actual: ${response.type}`)\n      assert(id.equals(response.paymentId), `response does not correspond to request. payment id does not match. actual: ${response.paymentId.toString('hex')}, expected: ${id.toString('hex')}`)\n      assert(expectedSequence === response.sequence, `response does not correspond to request. sequence does not match. actual: ${response.sequence}, expected: ${sequence - 1}`)\n\n      const amountReceived = response.paymentAmount\n      debug(`receiver says they have received: ${amountReceived.toString(10)}`)\n      if (amountReceived.gte(amountDelivered)) {\n        amountDelivered = amountReceived\n        rate = amountDelivered.div(amountSent)\n      } else {\n        // TODO should we throw a more serious error here?\n        debug(`receiver decreased the amount they say they received. previously: ${amountDelivered.toString(10)}, now: ${amountReceived.toString(10)}`)\n      }\n    } catch (err) {\n      debug('error decrypting response data:', err, encrypted.toString('base64'))\n      throw new Error('Got bad response from receiver: ' + err.message)\n    }\n  }\n\n  while (true) {\n    // Figure out if we've sent enough already\n    let amountLeftToSend\n    if (sourceAmount) {\n      // Fixed source amount\n      amountLeftToSend = new BigNumber(sourceAmount).minus(amountSent)\n      debug(`amount left to send: ${amountLeftToSend.toString(10)}`)\n    } else {\n      // Fixed destination amount\n      const amountLeftToDeliver = new BigNumber(destinationAmount || 0).minus(amountDelivered)\n      if (amountLeftToDeliver.lte(0)) {\n        debug('amount left to deliver: 0')\n        break\n      }\n      // Use the path exchange rate to figure out the amount left to send\n      if (amountSent.gt(0)) {\n        const rate = amountDelivered.div(amountSent)\n        amountLeftToSend = amountLeftToDeliver.div(rate).round(0, BigNumber.ROUND_CEIL) // round up\n        debug(`amount left to send: ${amountLeftToSend.toString(10)} (amount left to deliver: ${amountLeftToDeliver.toString(10)}, rate: ${rate.toString(10)})`)\n      } else {\n        // We don't know how much more we need to send\n        amountLeftToSend = constants.MAX_UINT64\n        debug('amount left to send: unknown')\n      }\n    }\n\n    // Stop if we've already sent enough\n    if (amountLeftToSend.lte(0)) {\n      break\n    }\n\n    // If there's only one more chunk to send, communicate that to the receiver\n    if (amountLeftToSend.lte(chunkSize)) {\n      debug('sending last chunk')\n      chunkSize = amountLeftToSend\n      lastChunk = true\n    }\n\n    // TODO should we allow the rate to fluctuate more?\n    const minimumAmountReceiverShouldAccept = BigNumber.min(\n      rate.times(chunkSize).round(0, BigNumber.ROUND_DOWN),\n      constants.MAX_UINT64)\n\n    const data = encoding.serializeLegacyPskPacket(sharedSecret, {\n      type: (lastChunk ? constants.TYPE_PSK2_LAST_CHUNK : constants.TYPE_PSK2_CHUNK),\n      paymentId: id,\n      sequence,\n      paymentAmount: (destinationAmount ? new BigNumber(destinationAmount) : constants.MAX_UINT64),\n      chunkAmount: minimumAmountReceiverShouldAccept\n    })\n    const fulfillment = dataToFulfillment(sharedSecret, data)\n    const executionCondition = fulfillmentToCondition(fulfillment)\n    const prepare = IlpPacket.serializeIlpPrepare({\n      destination: destinationAccount,\n      amount: chunkSize.toString(10),\n      expiresAt: new Date(Date.now() + DEFAULT_TRANSFER_TIMEOUT),\n      executionCondition,\n      data\n    })\n\n    const result = await plugin.sendData(prepare)\n\n    let parsed\n    try {\n      parsed = IlpPacket.deserializeIlpPacket(result)\n    } catch (err) {\n      debug('error parsing sendData response:', err, 'response:', result.toString('base64'))\n      throw err\n    }\n\n    if (parsed.type === IlpPacket.Type.TYPE_ILP_FULFILL) {\n      /* tslint:disable-next-line:no-unnecessary-type-assertion */\n      const fulfill = parsed.data as IlpPacket.IlpFulfill\n\n      if (!fulfillment.equals(fulfill.fulfillment)) {\n        debug(`Received invalid fulfillment. expected: ${fulfillment.toString('base64')}, actual: ${fulfill.fulfillment.toString('base64')}`)\n        throw new Error(`Received invalid fulfillment. expected: ${fulfillment.toString('base64')}, actual: ${fulfill.fulfillment.toString('base64')}`)\n      }\n\n      amountSent = amountSent.plus(chunkSize)\n      handleReceiverResponse(fulfill.data, constants.TYPE_PSK2_FULFILLMENT, sequence)\n\n      chunksFulfilled += 1\n      chunkSize = chunkSize.times(TRANSFER_INCREASE).round(0)\n      debug('transfer was successful, increasing chunk size to:', chunkSize.toString(10))\n      timeToWait = 0\n\n      if (lastChunk) {\n        break\n      } else {\n        sequence++\n      }\n    } else if (parsed.type === IlpPacket.Type.TYPE_ILP_REJECT) {\n      /* tslint:disable-next-line:no-unnecessary-type-assertion */\n      const rejection = parsed.data as IlpPacket.IlpRejection\n      if (rejection.code === 'F99') {\n        // Handle if the receiver rejects the transfer with a PSK packet\n        handleReceiverResponse(\n          rejection.data,\n          constants.TYPE_PSK2_REJECT,\n          sequence)\n      } else if (rejection.code[0] === 'T' || rejection.code[0] === 'R') {\n        // Handle temporary and relative errors\n        // TODO is this the right behavior in this situation?\n        // TODO don't retry forever\n        chunkSize = chunkSize\n          .times(TRANSFER_DECREASE)\n          .round(0)\n        if (chunkSize.lt(1)) {\n          chunkSize = new BigNumber(1)\n        }\n        timeToWait = Math.max(timeToWait * 2, 100)\n        debug(`got temporary ILP rejection: ${rejection.code}, reducing chunk size to: ${chunkSize.toString(10)} and waiting: ${timeToWait}ms`)\n        await new Promise((resolve, reject) => setTimeout(resolve, timeToWait))\n      } else {\n        // TODO is it ever worth retrying here?\n        debug('got ILP rejection with final error:', JSON.stringify(rejection))\n        throw new Error(`Transfer rejected with final error: ${rejection.code}${(rejection.message ? ': ' + rejection.message : '')}`)\n      }\n    } else {\n      debug('sendData returned unexpected packet type:', JSON.stringify(parsed))\n      throw new Error('Unexpected type for sendData response: ' + parsed.type)\n    }\n  }\n\n  debug(`sent payment. source amount: ${amountSent.toString(10)}, destination amount: ${amountDelivered.toString(10)}, number of chunks: ${sequence + 1}`)\n\n  return {\n    id,\n    sourceAmount: amountSent.toString(10),\n    destinationAmount: amountDelivered.toString(10),\n    chunksFulfilled,\n    chunksRejected\n  }\n}\n"]}