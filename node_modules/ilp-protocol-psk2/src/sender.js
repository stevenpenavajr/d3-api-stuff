"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const crypto = require("crypto");
const Debug = require("debug");
const bignumber_js_1 = require("bignumber.js");
const IlpPacket = require("ilp-packet");
const ilp_compat_plugin_1 = require("ilp-compat-plugin");
const constants = require("./constants");
const encoding = require("./encoding");
const condition_1 = require("./condition");
const DEFAULT_TRANSFER_TIMEOUT = 30000;
const STARTING_TRANSFER_AMOUNT = 1000;
const TRANSFER_INCREASE = 1.1;
const TRANSFER_DECREASE = 0.5;
function isPskResponse(result) {
    return result.fulfilled;
}
exports.isPskResponse = isPskResponse;
function isPskError(result) {
    return !result.fulfilled;
}
exports.isPskError = isPskError;
function sendRequest(plugin, params) {
    return __awaiter(this, void 0, void 0, function* () {
        const debug = Debug('ilp-protocol-psk2:sendRequest');
        const requestId = (typeof params.requestId === 'number' ? params.requestId : Math.floor(Math.random() * (constants.MAX_UINT32 + 1)));
        const sourceAmount = new bignumber_js_1.default(params.sourceAmount);
        let minDestinationAmount;
        if (params.minDestinationAmount !== undefined) {
            minDestinationAmount = new bignumber_js_1.default(params.minDestinationAmount);
        }
        else if (params.unfulfillableCondition !== undefined) {
            minDestinationAmount = constants.MAX_UINT64;
        }
        else {
            minDestinationAmount = new bignumber_js_1.default(0);
        }
        assert(Number.isInteger(requestId) && requestId <= constants.MAX_UINT32, 'requestId must be a UInt32');
        assert(sourceAmount.isInteger() && sourceAmount.lessThanOrEqualTo(constants.MAX_UINT64), 'sourceAmount must be a UInt64');
        assert(minDestinationAmount.isInteger() && minDestinationAmount.lessThanOrEqualTo(constants.MAX_UINT64), 'minDestinationAmount must be a UInt64');
        const pskPacket = encoding.serializePskPacket(params.sharedSecret, {
            type: encoding.Type.Request,
            requestId,
            amount: new bignumber_js_1.default(params.minDestinationAmount || 0),
            data: params.data || Buffer.alloc(0)
        });
        let fulfillment;
        let executionCondition;
        if (params.unfulfillableCondition) {
            assert(params.unfulfillableCondition.length === 32, 'unfulfillableCondition must be 32 bytes');
            debug(`using user-specified unfulfillable condition for request: ${requestId}`);
            executionCondition = params.unfulfillableCondition;
        }
        else {
            fulfillment = condition_1.dataToFulfillment(params.sharedSecret, pskPacket);
            executionCondition = condition_1.fulfillmentToCondition(fulfillment);
        }
        const prepare = IlpPacket.serializeIlpPrepare({
            destination: params.destinationAccount,
            amount: new bignumber_js_1.default(params.sourceAmount).toString(10),
            executionCondition,
            expiresAt: params.expiresAt || new Date(Date.now() + DEFAULT_TRANSFER_TIMEOUT),
            data: pskPacket
        });
        debug(`sending request ${requestId} for amount: ${params.sourceAmount}`);
        const response = yield plugin.sendData(prepare);
        if (!Buffer.isBuffer(response) || response.length === 0) {
            throw new Error('Got empty response from plugin.sendData');
        }
        let packet;
        try {
            const parsed = IlpPacket.deserializeIlpPacket(response);
            if (parsed.type === IlpPacket.Type.TYPE_ILP_FULFILL || parsed.type === IlpPacket.Type.TYPE_ILP_REJECT) {
                packet = parsed.data;
            }
            else {
                throw new Error('Unexpected ILP packet type: ' + parsed.type);
            }
        }
        catch (err) {
            debug('error parsing prepare response:', err, response && response.toString('hex'));
            throw new Error('Unable to parse response from plugin.sendData');
        }
        if (!isFulfill(packet) && packet.code === 'F06' && packet.data.length === 0) {
            debug(`got an F06 error for request ${requestId}, trying to send a legacy packet instead`);
            if (params.unfulfillableCondition) {
                try {
                    const quote = yield quoteSourceAmount(plugin, {
                        destinationAccount: params.destinationAccount,
                        sharedSecret: params.sharedSecret,
                        sourceAmount: params.sourceAmount
                    });
                    return {
                        fulfilled: false,
                        code: 'F99',
                        message: '',
                        triggeredBy: params.destinationAccount,
                        data: Buffer.alloc(0),
                        destinationAmount: new bignumber_js_1.default(quote.destinationAmount)
                    };
                }
                catch (err) {
                    debug(`sending a legacy quote request did not work either for request ${requestId}:`, err);
                    return Object.assign({}, packet, { fulfilled: false, destinationAmount: new bignumber_js_1.default(0) });
                }
            }
            else {
                try {
                    debug(`sending a legacy single chunk for request: ${requestId}`);
                    let id;
                    if (Buffer.isBuffer(params.data) && (params.data.length === 20 || params.data.length === 16)) {
                        id = params.data.slice(0, 16);
                    }
                    else {
                        id = Buffer.alloc(16, 0);
                    }
                    const result = yield sendSingleChunk(plugin, {
                        id,
                        destinationAccount: params.destinationAccount,
                        sharedSecret: params.sharedSecret,
                        sourceAmount: params.sourceAmount,
                        sequence: requestId,
                        minDestinationAmount: params.minDestinationAmount,
                        lastChunk: false
                    });
                    return {
                        fulfilled: true,
                        destinationAmount: new bignumber_js_1.default(result.destinationAmount),
                        data: Buffer.alloc(0)
                    };
                }
                catch (err) {
                    debug(`sending a legacy single chunk did not work either for request ${requestId}:`, err);
                    return Object.assign({}, packet, { fulfilled: false, destinationAmount: new bignumber_js_1.default(0) });
                }
            }
        }
        let pskResponsePacket;
        let unauthenticatedData = Buffer.alloc(0);
        if (packet.data.length > 0) {
            try {
                pskResponsePacket = encoding.deserializePskPacket(params.sharedSecret, packet.data);
            }
            catch (err) {
                debug('error parsing PSK response packet:', packet.data.toString('hex'), err);
                unauthenticatedData = packet.data;
            }
        }
        pskResponsePacket = pskResponsePacket;
        let destinationAmount;
        let data;
        const expectedType = (isFulfill(packet) ? encoding.Type.Response : encoding.Type.Error);
        if (!pskResponsePacket) {
            destinationAmount = new bignumber_js_1.default(0);
            data = Buffer.alloc(0);
        }
        else if (pskResponsePacket.type !== expectedType) {
            console.warn(`Received PSK response packet whose type should be ${expectedType} but is ${pskResponsePacket.type}. Either the receiver is faulty or a connector is messing with us`);
            destinationAmount = new bignumber_js_1.default(0);
            data = Buffer.alloc(0);
        }
        else if (pskResponsePacket.requestId !== requestId) {
            console.warn(`Received PSK response packet whose ID (${pskResponsePacket.requestId}) does not match our request (${requestId}). either the receiver is faulty or a connector is messing with us`);
            destinationAmount = new bignumber_js_1.default(0);
            data = Buffer.alloc(0);
        }
        else {
            destinationAmount = pskResponsePacket.amount;
            data = pskResponsePacket.data;
        }
        if (isFulfill(packet)) {
            debug(`request ${requestId} was fulfilled`);
            return {
                fulfilled: true,
                destinationAmount,
                data
            };
        }
        else {
            debug(`request ${requestId} was rejected with code: ${packet.code}`);
            return {
                fulfilled: false,
                code: packet.code,
                message: packet.message,
                triggeredBy: packet.triggeredBy,
                destinationAmount,
                data,
                unauthenticatedData
            };
        }
    });
}
exports.sendRequest = sendRequest;
function isFulfill(packet) {
    return packet.hasOwnProperty('fulfillment');
}
function quoteSourceAmount(plugin, params) {
    return __awaiter(this, void 0, void 0, function* () {
        console.warn('DeprecationWarning: quoteSourceAmount is deprecated and will be removed in the next version. Use sendRequest with an unfulfillable condition instead');
        let { sourceAmount, sharedSecret, destinationAccount, id = crypto.randomBytes(16) } = params;
        sourceAmount = new bignumber_js_1.default(sourceAmount);
        assert(sourceAmount.isInteger(), 'sourceAmount must be an integer');
        assert(sharedSecret, 'sharedSecret is required');
        assert(sharedSecret.length >= 32, 'sharedSecret must be at least 32 bytes');
        assert(destinationAccount && typeof destinationAccount === 'string', 'destinationAccount is required');
        assert((Buffer.isBuffer(id) && id.length === 16), 'id must be a 16-byte buffer');
        return quote(plugin, sharedSecret, id, destinationAccount, sourceAmount, undefined);
    });
}
exports.quoteSourceAmount = quoteSourceAmount;
function quoteDestinationAmount(plugin, params) {
    return __awaiter(this, void 0, void 0, function* () {
        console.warn('DeprecationWarning: quoteDestinationAmount is deprecated and will be removed in the next version. Use sendRequest with an unfulfillable condition instead');
        let { destinationAmount, sharedSecret, destinationAccount, id = crypto.randomBytes(16) } = params;
        destinationAmount = new bignumber_js_1.default(destinationAmount);
        assert(destinationAmount.isInteger(), 'destinationAmount must be an integer');
        assert(sharedSecret, 'sharedSecret is required');
        assert(sharedSecret.length >= 32, 'sharedSecret must be at least 32 bytes');
        assert(destinationAccount && typeof destinationAccount === 'string', 'destinationAccount is required');
        assert((Buffer.isBuffer(id) && id.length === 16), 'id must be a 16-byte buffer if supplied');
        return quote(plugin, sharedSecret, id, destinationAccount, undefined, destinationAmount);
    });
}
exports.quoteDestinationAmount = quoteDestinationAmount;
function quote(plugin, sharedSecret, id, destinationAccount, sourceAmount, destinationAmount) {
    return __awaiter(this, void 0, void 0, function* () {
        plugin = ilp_compat_plugin_1.default(plugin);
        const debug = Debug('ilp-protocol-psk2:quote');
        const sequence = 0;
        const data = encoding.serializeLegacyPskPacket(sharedSecret, {
            type: constants.TYPE_PSK2_LAST_CHUNK,
            paymentId: id,
            sequence,
            paymentAmount: constants.MAX_UINT64,
            chunkAmount: constants.MAX_UINT64
        });
        const amount = new bignumber_js_1.default(sourceAmount || STARTING_TRANSFER_AMOUNT).toString(10);
        const ilp = IlpPacket.serializeIlpPrepare({
            destination: destinationAccount,
            amount,
            executionCondition: crypto.randomBytes(32),
            expiresAt: new Date(Date.now() + DEFAULT_TRANSFER_TIMEOUT),
            data
        });
        let amountArrived = new bignumber_js_1.default(0);
        const result = yield plugin.sendData(ilp);
        let rejection;
        try {
            rejection = IlpPacket.deserializeIlpReject(result);
            assert(rejection.code === 'F99', `Got unexpected error code: ${rejection.code} ${rejection.message}`);
            assert(rejection.data.length > 0, 'Got empty response data');
        }
        catch (err) {
            debug('error deserializing quote response:', err);
            throw new Error('Error getting quote: ' + err.message);
        }
        try {
            const quoteResponse = encoding.deserializeLegacyPskPacket(sharedSecret, rejection.data);
            assert(quoteResponse.type === constants.TYPE_PSK2_REJECT, 'response type must be error');
            assert(id.equals(quoteResponse.paymentId), 'response Payment ID does not match outgoing quote');
            assert(sequence === quoteResponse.sequence, 'sequence does not match outgoing quote');
            amountArrived = quoteResponse.chunkAmount;
        }
        catch (decryptionErr) {
            debug('error parsing encrypted quote response', decryptionErr, result.toString('base64'));
            throw new Error('unable to parse quote response');
        }
        debug(`receiver got: ${amountArrived.toString(10)} when sender sent: ${amount} (rate: ${amountArrived.div(amount).toString(10)})`);
        let quotedSourceAmount;
        let quotedDestinationAmount;
        if (sourceAmount) {
            quotedSourceAmount = new bignumber_js_1.default(sourceAmount);
            quotedDestinationAmount = amountArrived;
        }
        else {
            quotedSourceAmount = new bignumber_js_1.default(destinationAmount)
                .div(amountArrived)
                .times(STARTING_TRANSFER_AMOUNT)
                .round(0, bignumber_js_1.default.ROUND_UP);
            quotedDestinationAmount = new bignumber_js_1.default(destinationAmount);
        }
        return {
            sourceAmount: quotedSourceAmount.toString(10),
            destinationAmount: quotedDestinationAmount.toString(10)
        };
    });
}
function sendSingleChunk(plugin, params) {
    return __awaiter(this, void 0, void 0, function* () {
        console.warn('DeprecationWarning: sendSingleChunk is deprecated and will be removed in the next version. Use sendRequest instead');
        plugin = ilp_compat_plugin_1.default(plugin);
        const debug = Debug('ilp-protocol-psk2:sendSingleChunk');
        const { sourceAmount, sharedSecret, destinationAccount, minDestinationAmount = 0 } = params;
        function isAdvanced(params) {
            return params.id !== undefined;
        }
        const { id, sequence, lastChunk } = (isAdvanced(params) ? params : {
            id: crypto.randomBytes(16),
            sequence: 0,
            lastChunk: true
        });
        assert(sharedSecret, 'sharedSecret is required');
        assert(sharedSecret.length >= 32, 'sharedSecret must be at least 32 bytes');
        assert(sourceAmount, 'sourceAmount is required');
        assert(!id || (Buffer.isBuffer(id) && id.length === 16), 'id must be a 16-byte buffer if supplied');
        debug(`sending single chunk payment ${id.toString('hex')} with source amount: ${sourceAmount} and minimum destination amount: ${minDestinationAmount}`);
        const data = encoding.serializeLegacyPskPacket(sharedSecret, {
            type: (lastChunk ? constants.TYPE_PSK2_LAST_CHUNK : constants.TYPE_PSK2_CHUNK),
            paymentId: id,
            sequence,
            paymentAmount: constants.MAX_UINT64,
            chunkAmount: new bignumber_js_1.default(minDestinationAmount)
        });
        const fulfillment = condition_1.dataToFulfillment(sharedSecret, data);
        const executionCondition = condition_1.fulfillmentToCondition(fulfillment);
        const ilp = IlpPacket.serializeIlpPrepare({
            destination: destinationAccount,
            amount: new bignumber_js_1.default(sourceAmount).toString(10),
            executionCondition,
            expiresAt: new Date(Date.now() + DEFAULT_TRANSFER_TIMEOUT),
            data
        });
        const result = yield plugin.sendData(ilp);
        let parsed;
        try {
            parsed = IlpPacket.deserializeIlpPacket(result);
        }
        catch (err) {
            debug('error parsing sendData response:', err, 'response:', result.toString('base64'));
            throw err;
        }
        let fulfillmentInfo;
        if (parsed.type === IlpPacket.Type.TYPE_ILP_FULFILL) {
            fulfillmentInfo = parsed.data;
        }
        else if (parsed.type === IlpPacket.Type.TYPE_ILP_REJECT) {
            const rejection = parsed.data;
            debug('error sending payment:', JSON.stringify(rejection));
            throw new Error(`Error sending payment. code: ${rejection.code}, message: ${rejection.message} `);
        }
        else {
            debug('sendData returned unexpected packet type:', JSON.stringify(parsed));
            throw new Error('Unexpected type for sendData response: ' + parsed.type);
        }
        if (!fulfillment.equals(fulfillmentInfo.fulfillment)) {
            debug(`Received invalid fulfillment. expected: ${fulfillment.toString('base64')}, actual: ${fulfillmentInfo.fulfillment.toString('base64')}`);
            throw new Error(`Received invalid fulfillment. expected: ${fulfillment.toString('base64')}, actual: ${fulfillmentInfo.fulfillment.toString('base64')}`);
        }
        let amountArrived;
        try {
            const response = encoding.deserializeLegacyPskPacket(sharedSecret, fulfillmentInfo.data);
            assert(constants.TYPE_PSK2_FULFILLMENT === response.type, `unexpected PSK packet type. expected: ${constants.TYPE_PSK2_FULFILLMENT}, actual: ${response.type}`);
            assert(id.equals(response.paymentId), `response does not correspond to request. payment id does not match. actual: ${response.paymentId.toString('hex')}, expected: ${id.toString('hex')}`);
            assert(sequence === response.sequence, `response does not correspond to request. sequence does not match. actual: ${response.sequence}, expected: ${sequence}`);
            amountArrived = response.chunkAmount;
        }
        catch (err) {
            debug('got invalid response:', err, JSON.stringify(result));
            throw new Error('Invalid response from receiver: ' + err.message);
        }
        debug(`sent single chunk payment ${id.toString('hex')} with source amount: ${sourceAmount}, destination amount: ${amountArrived.toString(10)}`);
        return {
            id,
            sourceAmount: new bignumber_js_1.default(sourceAmount).toString(10),
            destinationAmount: amountArrived.toString(10),
            chunksFulfilled: 1,
            chunksRejected: 0
        };
    });
}
exports.sendSingleChunk = sendSingleChunk;
function sendSourceAmount(plugin, params) {
    return __awaiter(this, void 0, void 0, function* () {
        console.warn('DeprecationWarning: Chunked payments are deprecated in this module and will be removed in the next version. Chunked payments will be implemented by a separate protocol / module that properly handles segmentation and reassembly of money and data.');
        assert(params.sourceAmount, 'sourceAmount is required');
        return sendChunkedPayment(plugin, params);
    });
}
exports.sendSourceAmount = sendSourceAmount;
function sendDestinationAmount(plugin, params) {
    return __awaiter(this, void 0, void 0, function* () {
        console.warn('DeprecationWarning: Chunked payments are deprecated in this module and will be removed in the next version. Chunked payments will be implemented by a separate protocol / module that properly handles segmentation and reassembly of money and data.');
        assert(params.destinationAmount, 'destinationAmount is required');
        return sendChunkedPayment(plugin, params);
    });
}
exports.sendDestinationAmount = sendDestinationAmount;
function sendChunkedPayment(plugin, params) {
    return __awaiter(this, void 0, void 0, function* () {
        const { sharedSecret, destinationAccount, sourceAmount, destinationAmount, id = crypto.randomBytes(16) } = params;
        assert(sharedSecret, 'sharedSecret is required');
        assert(sharedSecret.length >= 32, 'sharedSecret must be at least 32 bytes');
        assert(destinationAccount, 'destinationAccount is required');
        assert((Buffer.isBuffer(id) && id.length === 16), 'id must be a 16-byte buffer if supplied');
        plugin = ilp_compat_plugin_1.default(plugin);
        const debug = Debug('ilp-protocol-psk2:chunkedPayment');
        let amountSent = new bignumber_js_1.default(0);
        let amountDelivered = new bignumber_js_1.default(0);
        let sequence = 0;
        let chunkSize = new bignumber_js_1.default(STARTING_TRANSFER_AMOUNT);
        let lastChunk = false;
        let timeToWait = 0;
        let rate = new bignumber_js_1.default(0);
        let chunksFulfilled = 0;
        let chunksRejected = 0;
        function handleReceiverResponse(encrypted, expectedType, expectedSequence) {
            try {
                const response = encoding.deserializeLegacyPskPacket(sharedSecret, encrypted);
                assert(expectedType === response.type, `unexpected packet type. expected: ${expectedType}, actual: ${response.type}`);
                assert(id.equals(response.paymentId), `response does not correspond to request. payment id does not match. actual: ${response.paymentId.toString('hex')}, expected: ${id.toString('hex')}`);
                assert(expectedSequence === response.sequence, `response does not correspond to request. sequence does not match. actual: ${response.sequence}, expected: ${sequence - 1}`);
                const amountReceived = response.paymentAmount;
                debug(`receiver says they have received: ${amountReceived.toString(10)}`);
                if (amountReceived.gte(amountDelivered)) {
                    amountDelivered = amountReceived;
                    rate = amountDelivered.div(amountSent);
                }
                else {
                    debug(`receiver decreased the amount they say they received. previously: ${amountDelivered.toString(10)}, now: ${amountReceived.toString(10)}`);
                }
            }
            catch (err) {
                debug('error decrypting response data:', err, encrypted.toString('base64'));
                throw new Error('Got bad response from receiver: ' + err.message);
            }
        }
        while (true) {
            let amountLeftToSend;
            if (sourceAmount) {
                amountLeftToSend = new bignumber_js_1.default(sourceAmount).minus(amountSent);
                debug(`amount left to send: ${amountLeftToSend.toString(10)}`);
            }
            else {
                const amountLeftToDeliver = new bignumber_js_1.default(destinationAmount || 0).minus(amountDelivered);
                if (amountLeftToDeliver.lte(0)) {
                    debug('amount left to deliver: 0');
                    break;
                }
                if (amountSent.gt(0)) {
                    const rate = amountDelivered.div(amountSent);
                    amountLeftToSend = amountLeftToDeliver.div(rate).round(0, bignumber_js_1.default.ROUND_CEIL);
                    debug(`amount left to send: ${amountLeftToSend.toString(10)} (amount left to deliver: ${amountLeftToDeliver.toString(10)}, rate: ${rate.toString(10)})`);
                }
                else {
                    amountLeftToSend = constants.MAX_UINT64;
                    debug('amount left to send: unknown');
                }
            }
            if (amountLeftToSend.lte(0)) {
                break;
            }
            if (amountLeftToSend.lte(chunkSize)) {
                debug('sending last chunk');
                chunkSize = amountLeftToSend;
                lastChunk = true;
            }
            const minimumAmountReceiverShouldAccept = bignumber_js_1.default.min(rate.times(chunkSize).round(0, bignumber_js_1.default.ROUND_DOWN), constants.MAX_UINT64);
            const data = encoding.serializeLegacyPskPacket(sharedSecret, {
                type: (lastChunk ? constants.TYPE_PSK2_LAST_CHUNK : constants.TYPE_PSK2_CHUNK),
                paymentId: id,
                sequence,
                paymentAmount: (destinationAmount ? new bignumber_js_1.default(destinationAmount) : constants.MAX_UINT64),
                chunkAmount: minimumAmountReceiverShouldAccept
            });
            const fulfillment = condition_1.dataToFulfillment(sharedSecret, data);
            const executionCondition = condition_1.fulfillmentToCondition(fulfillment);
            const prepare = IlpPacket.serializeIlpPrepare({
                destination: destinationAccount,
                amount: chunkSize.toString(10),
                expiresAt: new Date(Date.now() + DEFAULT_TRANSFER_TIMEOUT),
                executionCondition,
                data
            });
            const result = yield plugin.sendData(prepare);
            let parsed;
            try {
                parsed = IlpPacket.deserializeIlpPacket(result);
            }
            catch (err) {
                debug('error parsing sendData response:', err, 'response:', result.toString('base64'));
                throw err;
            }
            if (parsed.type === IlpPacket.Type.TYPE_ILP_FULFILL) {
                const fulfill = parsed.data;
                if (!fulfillment.equals(fulfill.fulfillment)) {
                    debug(`Received invalid fulfillment. expected: ${fulfillment.toString('base64')}, actual: ${fulfill.fulfillment.toString('base64')}`);
                    throw new Error(`Received invalid fulfillment. expected: ${fulfillment.toString('base64')}, actual: ${fulfill.fulfillment.toString('base64')}`);
                }
                amountSent = amountSent.plus(chunkSize);
                handleReceiverResponse(fulfill.data, constants.TYPE_PSK2_FULFILLMENT, sequence);
                chunksFulfilled += 1;
                chunkSize = chunkSize.times(TRANSFER_INCREASE).round(0);
                debug('transfer was successful, increasing chunk size to:', chunkSize.toString(10));
                timeToWait = 0;
                if (lastChunk) {
                    break;
                }
                else {
                    sequence++;
                }
            }
            else if (parsed.type === IlpPacket.Type.TYPE_ILP_REJECT) {
                const rejection = parsed.data;
                if (rejection.code === 'F99') {
                    handleReceiverResponse(rejection.data, constants.TYPE_PSK2_REJECT, sequence);
                }
                else if (rejection.code[0] === 'T' || rejection.code[0] === 'R') {
                    chunkSize = chunkSize
                        .times(TRANSFER_DECREASE)
                        .round(0);
                    if (chunkSize.lt(1)) {
                        chunkSize = new bignumber_js_1.default(1);
                    }
                    timeToWait = Math.max(timeToWait * 2, 100);
                    debug(`got temporary ILP rejection: ${rejection.code}, reducing chunk size to: ${chunkSize.toString(10)} and waiting: ${timeToWait}ms`);
                    yield new Promise((resolve, reject) => setTimeout(resolve, timeToWait));
                }
                else {
                    debug('got ILP rejection with final error:', JSON.stringify(rejection));
                    throw new Error(`Transfer rejected with final error: ${rejection.code}${(rejection.message ? ': ' + rejection.message : '')}`);
                }
            }
            else {
                debug('sendData returned unexpected packet type:', JSON.stringify(parsed));
                throw new Error('Unexpected type for sendData response: ' + parsed.type);
            }
        }
        debug(`sent payment. source amount: ${amountSent.toString(10)}, destination amount: ${amountDelivered.toString(10)}, number of chunks: ${sequence + 1}`);
        return {
            id,
            sourceAmount: amountSent.toString(10),
            destinationAmount: amountDelivered.toString(10),
            chunksFulfilled,
            chunksRejected
        };
    });
}
//# sourceMappingURL=sender.js.map