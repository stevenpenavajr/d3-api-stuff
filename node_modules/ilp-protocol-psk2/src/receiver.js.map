{"version":3,"file":"receiver.js","sourceRoot":"","sources":["receiver.ts"],"names":[],"mappings":"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","sourcesContent":["'use strict'\n\nimport * as assert from 'assert'\nimport * as crypto from 'crypto'\nimport * as Debug from 'debug'\nconst debug = Debug('ilp-protocol-psk2:receiver')\nimport BigNumber from 'bignumber.js'\nimport { default as convertToV2Plugin, PluginV1, PluginV2 } from 'ilp-compat-plugin'\nimport IlpPacket = require('ilp-packet')\nimport * as constants from './constants'\nimport * as encoding from './encoding'\nimport { dataToFulfillment, fulfillmentToCondition } from './condition'\nimport * as ILDCP from 'ilp-protocol-ildcp'\n\nconst PSK_GENERATION_STRING = 'ilp_psk2_generation'\nconst PSK_ADDRESS_FROM_SECRET_STRING = 'ilp_psk2_address_from_secret'\nconst TOKEN_LENGTH = 18\nconst SHARED_SECRET_LENGTH = 32\n\n/**\n * Review callback that will be called every time the Receiver receives an incoming packet.\n *\n * The RequestHandler can call [`accept`]{@link RequestHandlerParams.accept} to fulfill the packet or [`reject`]{@link RequestHandlerParams.reject} to reject it.\n */\nexport interface RequestHandler {\n  (params: RequestHandlerParams): any\n}\n\nexport interface RequestHandlerParams {\n  /** If a keyId was passed into [`createAddressAndSecret`]{@link Receiver.createAddressAndSecret}, it will be present here when a packet is sent to that `destinationAccount` */\n  keyId?: Buffer,\n  /** Indicates whether the request is fulfillable (unfulfillable requests are passed to the handler in case they carry useful application data) */\n  isFulfillable: boolean,\n  /** Amount that arrived */\n  amount: BigNumber,\n  /** Data sent by the sender */\n  data: Buffer,\n  /** Fulfill the packet, and optionally send some data back to the sender */\n  accept: (responseData?: Buffer) => void,\n  /** Reject the packet, and optionally send some data back to the sender */\n  reject: (responseData?: Buffer) => void\n}\n\n/**\n * Review callback that will be called every time the Receiver receives an incoming payment or payment chunk.\n *\n * The payment handler can call the [`accept`]{@link PaymentHandlerParams.accept} or [`reject`]{@link PaymentHandlerParams.reject} methods to fulfill or reject the entire payment.\n */\nexport interface PaymentHandler {\n  (params: PaymentHandlerParams): void | Promise<void>\n}\n\n/**\n * Parameters passed to the Receiver's payment handler callback.\n */\nexport interface PaymentHandlerParams {\n  id: Buffer,\n  /** Total amount that should be delivered by this payment.\n   * If the sender has not specified a destination amount, this value will be the maximum UInt64 value or 18446744073709551615.\n   */\n  expectedAmount: string,\n  /**\n   * Accept the entire payment.\n   * The Receiver will automatically fulfill all incoming chunks until the `expectedAmount`\n   * has been delivered or the sender has indicated the payment is finished.\n   *\n   * The Promise returned will resolve to a [`PaymentReceived`]{@link PaymentReceived} when the payment is finished.\n   */\n  accept: () => Promise<PaymentReceived>,\n  /**\n   * Reject the entire payment (and all subsequent chunks with the same `id`).\n   */\n  reject: (message: string) => void,\n  /**\n   * Alternative to `accept` that gives the user more control over the payment chunks they wish to fulfill.\n   * If this method is called, the PaymentHandler callback will be called again for subsequent chunks with the same payment `id`.\n   */\n  acceptSingleChunk: () => void,\n  /**\n   * Alternative to `reject` that gives the user more control over the payment chunks they wish to reject.\n   * If this method is called, the PaymentHandler callback will be called again for subsequent chunks with the same payment `id`.\n   */\n  rejectSingleChunk: (message: string) => void,\n  /**\n   * Details about this prepared chunk; in the form of a parsed interledger packet.\n   */\n  prepare: IlpPacket.IlpPrepare\n}\n\nexport interface PaymentReceived {\n  id: Buffer,\n  receivedAmount: string,\n  expectedAmount: string,\n  chunksFulfilled: number\n}\n\n/**\n * Params for instantiating a Receiver using the [`createReceiver`]{@link createReceiver} function.\n */\nexport interface ReceiverOpts {\n  /** Ledger Plugin */\n  plugin: PluginV2 | PluginV1,\n  /** @deprecated */\n  paymentHandler?: PaymentHandler,\n  /** Callback for handling incoming packets */\n  requestHandler?: RequestHandler,\n  /** Cryptographic seed that will be used to generate shared secrets for multiple senders */\n  secret?: Buffer\n}\n\n/**\n * PSK2 Receiver class that listens for and accepts incoming payments.\n *\n * The same Receiver may be used for accepting single-chunk payments, streaming payments, and chunked payments.\n *\n * It is recommended to use the [`createReceiver`]{@link createReceiver} function to instantiate Receivers.\n */\nexport class Receiver {\n  protected plugin: PluginV2\n  protected secret: Buffer\n  protected requestHandler: RequestHandler\n  protected paymentHandler: PaymentHandler\n  protected address: string\n  protected payments: Object\n  protected connected: boolean\n  protected usingRequestHandlerApi: boolean\n  protected specificRequestHandlers: { [key: string]: { sharedSecret: Buffer, requestHandler: RequestHandler } }\n\n  constructor (plugin: PluginV2 | PluginV1, secret: Buffer) {\n    // TODO stop accepting PluginV1\n    this.plugin = convertToV2Plugin(plugin)\n    assert(secret.length >= 32, 'secret must be at least 32 bytes')\n    this.secret = secret\n    this.paymentHandler = this.defaultPaymentHandler\n    this.address = ''\n    this.payments = {}\n    this.connected = false\n    this.requestHandler = this.defaultRequestHandler\n    this.usingRequestHandlerApi = false\n    this.specificRequestHandlers = {}\n  }\n\n  /**\n   * Fetch the receiver's ILP address using [ILDCP](https://github.com/interledgerjs/ilp-protocol-ildcp) and listen for incoming payments.\n   */\n  async connect (): Promise<void> {\n    debug('connect called')\n    await this.plugin.connect()\n    // TODO refetch address if we're connected for long enough\n    this.address = (await ILDCP.fetch(this.plugin.sendData.bind(this.plugin))).clientAddress\n    this.plugin.registerDataHandler(this.handleData)\n    this.connected = true\n    debug('connected')\n  }\n\n  /**\n   * Stop listening for incoming payments.\n   */\n  async disconnect (): Promise<void> {\n    debug('disconnect called')\n    this.connected = false\n    this.plugin.deregisterDataHandler()\n    await this.plugin.disconnect()\n    debug('disconnected')\n  }\n\n  /**\n   * Check if the receiver is currently listening for incoming payments.\n   */\n  isConnected (): boolean {\n    this.connected = this.connected && this.plugin.isConnected()\n    return this.connected\n  }\n\n  /**\n   * Register a callback that will be called each time a packet is received.\n   *\n   * The user must call `accept` to make the Receiver fulfill the packet.\n   */\n  registerRequestHandler (handler: RequestHandler): void {\n    if (this.paymentHandler !== this.defaultPaymentHandler) {\n      throw new Error('PaymentHandler and RequestHandler APIs cannot be used at the same time')\n    }\n    debug('registered request handler')\n    this.usingRequestHandlerApi = true\n    this.requestHandler = handler\n  }\n\n  /**\n   * Remove the handler callback.\n   */\n  deregisterRequestHandler (): void {\n    this.requestHandler = this.defaultRequestHandler\n  }\n\n  /**\n   * @deprecated. Switch to [`registerRequestHandler`]{@link Receiver.registerRequestHandler} instead\n   */\n  registerPaymentHandler (handler: PaymentHandler): void {\n    console.warn('DeprecationWarning: registerPaymentHandler is deprecated and will be removed in the next version. Use registerRequestHandler instead')\n    if (this.usingRequestHandlerApi) {\n      throw new Error('PaymentHandler and RequestHandler APIs cannot be used at the same time')\n    }\n    debug('registered payment handler')\n    /* tslint:disable-next-line:strict-type-predicates */\n    assert(typeof handler === 'function', 'payment handler must be a function')\n    this.paymentHandler = handler\n  }\n\n  /**\n   * @deprecated. Use RequestHandlers instead\n   */\n  deregisterPaymentHandler (): void {\n    this.paymentHandler = this.defaultPaymentHandler\n  }\n\n  /**\n   * Generate a unique ILP address and shared secret to give to a sender.\n   *\n   * The Receiver must be connected before this method can be called.\n   *\n   * **Note:** A single shared secret MUST NOT be given to more than one sender.\n   *\n   * @param keyId Additional segment that will be appended to the destinationAccount and can be used to correlate payments. This is authenticated but **unencrypted** so the entire Interledger will be able to see this value.\n   */\n  generateAddressAndSecret (keyId?: Buffer): { destinationAccount: string, sharedSecret: Buffer } {\n    assert(this.connected, 'Receiver must be connected')\n    const token = crypto.randomBytes(TOKEN_LENGTH)\n    const keygen = (keyId ? Buffer.concat([token, keyId]) : token)\n    const sharedSecret = generateSharedSecret(this.secret, keygen)\n    return {\n      sharedSecret,\n      destinationAccount: `${this.address}.${base64url(keygen)}`\n    }\n  }\n\n  /**\n   * Register a `RequestHandler` for a specific `sharedSecret`.\n   * This will be called instead of the normal `requestHandler` when requests come in for the `destinationAccount` returned by this function.\n   *\n   * This is especially useful for bidirectional protocols built on top of PSK2 in which both sides want to use the same sharedSecret.\n   *\n   * @param sharedSecret Secret to use for decrypting data and generating fulfillments\n   * @param handler Callback that will be called when a request comes in for the `destinationAccount` returned by this function\n   */\n  registerRequestHandlerForSecret (sharedSecret: Buffer, handler: RequestHandler): { destinationAccount: string, sharedSecret: Buffer } {\n    if (this.paymentHandler !== this.defaultPaymentHandler) {\n      throw new Error('PaymentHandler and RequestHandler APIs cannot be used at the same time')\n    }\n    this.usingRequestHandlerApi = true\n\n    const generator = hmac(this.secret, Buffer.from(PSK_ADDRESS_FROM_SECRET_STRING, 'utf8'))\n    const addressSuffix = base64url(hmac(generator, sharedSecret).slice(0, TOKEN_LENGTH))\n\n    if (this.specificRequestHandlers[addressSuffix]) {\n      throw new Error('RequestHandler already registered for that sharedSecret. The old handler must be deregistered first before another one is added')\n    }\n\n    this.specificRequestHandlers[addressSuffix] = {\n      sharedSecret,\n      requestHandler: handler\n    }\n    debug(`added specific request handler for address suffix: ${addressSuffix}`)\n\n    return {\n      sharedSecret,\n      destinationAccount: `${this.address}.${addressSuffix}`\n    }\n  }\n\n  /**\n   * Remove the requestHandler for a specific sharedSecret. Does nothing if there is no handler registered\n   */\n  deregisterRequestHandlerForSecret (sharedSecret: Buffer): void {\n    const generator = hmac(this.secret, Buffer.from(PSK_ADDRESS_FROM_SECRET_STRING, 'utf8'))\n    const addressSuffix = base64url(hmac(generator, sharedSecret).slice(0, TOKEN_LENGTH))\n\n    if (this.specificRequestHandlers[addressSuffix]) {\n      delete this.specificRequestHandlers[addressSuffix]\n      debug(`removed specific request handler for address suffix: ${addressSuffix}`)\n    } else {\n      debug(`tried to remove specific request handler for address suffix: ${addressSuffix}, but there was no handler registerd`)\n    }\n  }\n\n  protected async defaultPaymentHandler (params: PaymentHandlerParams): Promise<void> {\n    debug(`Receiver has no handler registered, rejecting payment ${params.id.toString('hex')}`)\n    return params.reject('Receiver has no payment handler registered')\n  }\n\n  protected async defaultRequestHandler (params: RequestHandlerParams): Promise<void> {\n    debug(`Receiver has no handler registered, rejecting request of amount: ${params.amount} with data: ${params.data.toString('hex')}`)\n    return params.reject(Buffer.alloc(0))\n  }\n\n  protected reject (code: string, message?: string, data?: Buffer) {\n    return IlpPacket.serializeIlpReject({\n      code,\n      message: message || '',\n      data: data || Buffer.alloc(0),\n      triggeredBy: this.address\n    })\n  }\n\n  // This is an arrow function so we don't need to use bind when setting it on the plugin\n  protected handleData = async (data: Buffer): Promise<Buffer> => {\n    let prepare: IlpPacket.IlpPrepare\n    let sharedSecret: Buffer\n    let requestHandler: RequestHandler\n    let keyId = undefined\n\n    try {\n      prepare = IlpPacket.deserializeIlpPrepare(data)\n    } catch (err) {\n      debug('error parsing incoming prepare:', err)\n      return this.reject('F06', 'Packet is not an IlpPrepare')\n    }\n\n    const localParts = prepare.destination.replace(this.address + '.', '').split('.')\n    if (localParts.length === 0) {\n      return this.reject('F02', 'Packet is not for this receiver')\n    }\n    if (this.specificRequestHandlers[localParts[0]]) {\n      requestHandler = this.specificRequestHandlers[localParts[0]].requestHandler\n      sharedSecret = this.specificRequestHandlers[localParts[0]].sharedSecret\n    } else {\n      const keygen = Buffer.from(localParts[0], 'base64')\n      if (keygen.length > TOKEN_LENGTH) {\n        keyId = keygen.slice(TOKEN_LENGTH)\n      }\n      sharedSecret = generateSharedSecret(this.secret, keygen)\n      requestHandler = this.requestHandler.bind(this)\n    }\n\n    let packet\n    let isLegacy\n    try {\n      packet = encoding.deserializePskPacket(sharedSecret, prepare.data)\n      isLegacy = false\n    } catch (err) {\n      try {\n        packet = encoding.deserializeLegacyPskPacket(sharedSecret, prepare.data)\n        isLegacy = true\n      } catch (err) {\n        debug('unable to parse PSK packet, either because it is an unrecognized type or because the data has been tampered with:', JSON.stringify(prepare), err && err.message)\n        // TODO should this be a different error?\n        return this.reject('F06', 'Unable to parse data')\n      }\n    }\n    // Support the old PaymentHandler API for now\n    if (this.usingRequestHandlerApi && !isLegacy) {\n      if (packet.type !== encoding.Type.Request) {\n        // TODO should this be a different error?\n        debug('packet is not a PSK Request (should be type 4):', packet)\n        return this.reject('F06', 'Unexpected packet type')\n      }\n      packet = packet as encoding.PskPacket\n\n      let isFulfillable = false\n      let errorCode = 'F99'\n      let errorMessage = ''\n\n      // Check if we can regenerate the correct fulfillment\n      let fulfillment: Buffer\n      try {\n        fulfillment = dataToFulfillment(sharedSecret, prepare.data)\n        const generatedCondition = fulfillmentToCondition(fulfillment)\n        if (generatedCondition.equals(prepare.executionCondition)) {\n          isFulfillable = true\n        } else {\n          isFulfillable = false\n          errorCode = 'F05'\n          errorMessage = 'Condition generated does not match prepare'\n          debug(`condition generated does not match. expected: ${prepare.executionCondition.toString('base64')}, actual: ${generatedCondition.toString('base64')}`)\n\n        }\n      } catch (err) {\n        isFulfillable = false\n        errorCode = 'F05'\n        errorMessage = 'Condition does not match prepare'\n        debug('unable to generate fulfillment from data:', err)\n      }\n\n      // Check if the amount we received is enough\n      if (packet.amount.greaterThan(prepare.amount)) {\n        isFulfillable = false\n        debug(`incoming transfer amount too low. actual: ${prepare.amount}, expected: ${packet.amount}`)\n      }\n\n      const { fulfill, responseData } = await callRequestHandler(requestHandler, isFulfillable, packet.requestId, prepare.amount, packet.data, keyId)\n      if (fulfill && isFulfillable) {\n        return IlpPacket.serializeIlpFulfill({\n          /* tslint:disable-next-line:no-unnecessary-type-assertion */\n          fulfillment: fulfillment!,\n          data: encoding.serializePskPacket(sharedSecret, {\n            type: encoding.Type.Response,\n            requestId: packet.requestId,\n            amount: new BigNumber(prepare.amount),\n            data: responseData\n          })\n        })\n      } else {\n        return this.reject(errorCode, errorMessage, encoding.serializePskPacket(sharedSecret, {\n          type: encoding.Type.Error,\n          requestId: packet.requestId,\n          amount: new BigNumber(prepare.amount),\n          data: responseData\n        }))\n      }\n    } else if (this.usingRequestHandlerApi && isLegacy) {\n      // Legacy packets (will be removed soon)\n      if (packet.type !== constants.TYPE_PSK2_CHUNK && packet.type !== constants.TYPE_PSK2_LAST_CHUNK) {\n        debug('got packet with unrecognized PSK type: ', packet)\n        // TODO should this be a different error?\n        return this.reject('F06', 'Unsupported type')\n      }\n\n      packet = packet as encoding.LegacyPskPacket\n\n      // Transfer amount too low\n      if (packet.chunkAmount.gt(prepare.amount)) {\n        debug(`incoming transfer amount too low. actual: ${prepare.amount}, expected: ${packet.chunkAmount.toString(10)}`)\n        return this.reject('F99', '', encoding.serializeLegacyPskPacket(sharedSecret, {\n          type: constants.TYPE_PSK2_REJECT,\n          paymentId: packet.paymentId,\n          sequence: packet.sequence,\n          chunkAmount: new BigNumber(prepare.amount),\n          paymentAmount: new BigNumber(0)\n        }))\n      }\n\n      // Check if we can regenerate the correct fulfillment\n      let fulfillment\n      try {\n        fulfillment = dataToFulfillment(sharedSecret, prepare.data)\n        const generatedCondition = fulfillmentToCondition(fulfillment)\n        assert(generatedCondition.equals(prepare.executionCondition), `condition generated does not match. expected: ${prepare.executionCondition.toString('base64')}, actual: ${generatedCondition.toString('base64')}`)\n      } catch (err) {\n        debug('error regenerating fulfillment:', err)\n        return this.reject('F05', 'Condition generated does not match prepare', encoding.serializeLegacyPskPacket(sharedSecret, {\n          type: constants.TYPE_PSK2_REJECT,\n          paymentId: packet.paymentId,\n          sequence: packet.sequence,\n          paymentAmount: new BigNumber(0),\n          chunkAmount: new BigNumber(prepare.amount),\n          applicationData: Buffer.alloc(0)\n        }))\n      }\n\n      const compatibilityData = Buffer.alloc(20)\n      packet.paymentId.copy(compatibilityData)\n      compatibilityData.writeUInt32BE(packet.sequence, 16)\n\n      const { fulfill } = await callRequestHandler(requestHandler, true, packet.sequence, prepare.amount, compatibilityData, keyId)\n      if (fulfill) {\n        return IlpPacket.serializeIlpFulfill({\n          fulfillment,\n          data: encoding.serializeLegacyPskPacket(sharedSecret, {\n            type: constants.TYPE_PSK2_FULFILLMENT,\n            paymentId: packet.paymentId,\n            sequence: packet.sequence,\n            paymentAmount: new BigNumber(0),\n            chunkAmount: new BigNumber(prepare.amount),\n            applicationData: Buffer.alloc(0)\n          })\n        })\n      } else {\n        return this.reject('F99', '', encoding.serializeLegacyPskPacket(sharedSecret, {\n          type: constants.TYPE_PSK2_REJECT,\n          paymentId: packet.paymentId,\n          sequence: packet.sequence,\n          paymentAmount: new BigNumber(0),\n          chunkAmount: new BigNumber(prepare.amount),\n          applicationData: Buffer.alloc(0)\n        }))\n      }\n    } else {\n      // Legacy PaymentHandler API (will be removed soon)\n      let request: encoding.LegacyPskPacket\n      try {\n        request = encoding.deserializeLegacyPskPacket(sharedSecret, prepare.data)\n      } catch (err) {\n        debug('error decrypting data:', err)\n        return this.reject('F06', 'Unable to parse data')\n      }\n\n      if ([constants.TYPE_PSK2_CHUNK, constants.TYPE_PSK2_LAST_CHUNK].indexOf(request.type) === -1) {\n        debug(`got unexpected request type: ${request.type}`)\n        // TODO should this be a different error code?\n        // (this might be a sign that they're using a different version of the protocol)\n        // TODO should this type of response be encrypted?\n        return this.reject('F06', 'Unexpected request type')\n      }\n\n      const paymentId = request.paymentId.toString('hex')\n      let record = this.payments[paymentId]\n      if (!record) {\n        record = {\n          // TODO buffer user data and keep track of sequence numbers\n          received: new BigNumber(0),\n          expected: new BigNumber(0),\n          finished: false,\n          finishedPromise: null,\n          acceptedByReceiver: null,\n          rejectionMessage: 'rejected by receiver',\n          chunksFulfilled: 0,\n          chunksRejected: 0 // doesn't include chunks we cannot parse\n        }\n        this.payments[paymentId] = record\n      }\n      record.expected = request.paymentAmount\n\n      const rejectTransfer = (message: string) => {\n        debug(`rejecting transfer ${request.sequence} of payment ${paymentId}: ${message}`)\n        record.chunksRejected += 1\n        const data = encoding.serializeLegacyPskPacket(sharedSecret, {\n          type: constants.TYPE_PSK2_REJECT,\n          paymentId: request.paymentId,\n          sequence: request.sequence,\n          paymentAmount: record.received,\n          chunkAmount: new BigNumber(prepare.amount)\n        })\n        return this.reject('F99', '', data)\n      }\n\n      // Transfer amount too low\n      if (request.chunkAmount.gt(prepare.amount)) {\n        return rejectTransfer(`incoming transfer amount too low. actual: ${prepare.amount}, expected: ${request.chunkAmount.toString(10)}`)\n      }\n\n      // Payment is already finished\n      if (record.finished) {\n        // TODO should this return an F99 or something else?\n        return rejectTransfer(`payment is already finished`)\n      }\n\n      // TODO should we reject an incoming chunk if it would put us too far over the expected amount?\n\n      // Check if we can regenerate the correct fulfillment\n      let fulfillment\n      try {\n        fulfillment = dataToFulfillment(sharedSecret, prepare.data)\n        const generatedCondition = fulfillmentToCondition(fulfillment)\n        assert(generatedCondition.equals(prepare.executionCondition), `condition generated does not match. expected: ${prepare.executionCondition.toString('base64')}, actual: ${generatedCondition.toString('base64')}`)\n      } catch (err) {\n        debug('error regenerating fulfillment:', err)\n        record.chunksRejected += 1\n        return this.reject('F05', 'condition generated does not match prepare')\n      }\n\n      // Check if the receiver wants to accept the payment\n      let chunkAccepted = !!record.acceptedByReceiver\n      let userCalledAcceptOrReject = false\n      if (record.acceptedByReceiver === null) {\n        // This promise resolves when the user has either accepted or rejected the payment\n        await new Promise(async (resolve, reject) => {\n          // Reject the payment if:\n          // a) the user explicity calls reject\n          // b) if they don't call accept\n          // c) if there is an error thrown in the payment handler\n          try {\n            await Promise.resolve(this.paymentHandler({\n              // TODO include first chunk data\n              id: request.paymentId,\n              expectedAmount: record.expected.toString(10),\n              accept: async (): Promise<PaymentReceived> => {\n                userCalledAcceptOrReject = true\n                // Resolve the above promise so that we actually fulfill the incoming chunk\n                record.acceptedByReceiver = true\n                chunkAccepted = true\n                resolve()\n\n                // The promise returned to the receiver will be fulfilled\n                // when the whole payment is finished\n                const payment = await new Promise((resolve, reject) => {\n                  record.finishedPromise = { resolve, reject }\n                  // TODO should the payment timeout after some time?\n                }) as PaymentReceived\n\n                return payment\n              },\n              reject: (message: string) => {\n                userCalledAcceptOrReject = true\n                debug('receiver rejected payment with message:', message)\n                record.acceptedByReceiver = false\n                record.rejectionMessage = message\n                record.finished = false\n                // TODO check that the message isn't too long\n              },\n              // TODO throw error if you've waited too long and it's expired\n              acceptSingleChunk: (): void => {\n                userCalledAcceptOrReject = true\n                chunkAccepted = true\n                record.acceptedByReceiver = null\n                resolve()\n              },\n              rejectSingleChunk: (message: string) => {\n                userCalledAcceptOrReject = true\n                chunkAccepted = false\n                record.acceptedByReceiver = null\n                record.rejectionMessage = message\n                resolve()\n                // TODO check that the message isn't too long\n              },\n              prepare\n            }))\n\n            // If the user didn't call the accept function, reject it\n            if (!userCalledAcceptOrReject) {\n              record.acceptedByReceiver = false\n              record.rejectionMessage = 'receiver did not accept the payment'\n              record.finished = true\n            }\n          } catch (err) {\n            debug('error thrown in payment handler:', err)\n            record.acceptedByReceiver = false\n            record.rejectionMessage = err && err.message\n          }\n          resolve()\n        })\n      }\n\n      // Reject the chunk if the receiver rejected the whole payment\n      if (record.acceptedByReceiver === false) {\n        debug(`rejecting chunk because payment ${paymentId} was rejected by receiver with message: ${record.rejectionMessage}`)\n        record.chunksRejected += 1\n        return this.reject('F99', record.rejectionMessage)\n      }\n\n      // Reject the chunk of the receiver rejected the specific chunk\n      if (!chunkAccepted) {\n        debug(`rejecting chunk ${request.sequence} of payment ${paymentId} because it was rejected by the receiver with the message: ${record.rejectionMessage}`)\n        record.chunksRejected += 1\n        return this.reject('F99', record.rejectionMessage)\n      }\n\n      // Update stats based on that chunk\n      record.chunksFulfilled += 1\n      record.received = record.received.plus(prepare.amount)\n      if (record.received.gte(record.expected) || request.type === constants.TYPE_PSK2_LAST_CHUNK) {\n        record.finished = true\n        record.finishedPromise && record.finishedPromise.resolve({\n          id: request.paymentId,\n          receivedAmount: record.received.toString(10),\n          expectedAmount: record.expected.toString(10),\n          chunksFulfilled: record.chunksFulfilled,\n          chunksRejected: record.chunksRejected\n          // TODO add data\n        })\n      }\n\n      debug(`got ${record.finished ? 'last ' : ''}chunk of amount ${prepare.amount} for payment: ${paymentId}. total received: ${record.received.toString(10)}`)\n\n      // Let the sender know how much has arrived\n      const response = encoding.serializeLegacyPskPacket(sharedSecret, {\n        type: constants.TYPE_PSK2_FULFILLMENT,\n        paymentId: request.paymentId,\n        sequence: request.sequence,\n        paymentAmount: record.received,\n        chunkAmount: new BigNumber(prepare.amount)\n      })\n\n      debug(`fulfilling transfer ${request.sequence} for payment ${paymentId} with fulfillment: ${fulfillment.toString('base64')}`)\n\n      return IlpPacket.serializeIlpFulfill({\n        fulfillment,\n        data: response\n      })\n    }\n  }\n}\n\n/**\n * Convenience function for instantiating and connecting a PSK2 [Receiver]{@link Receiver}.\n *\n * @example <caption>Creating a Receiver</caption>\n * ```typescript\n * import { createReceiver } from 'ilp-protocol-psk2'\n * const receiver = await createReceiver({\n *   plugin: myLedgerPlugin,\n *   requestHandler: async (params) => {\n *     params.accept()\n *     console.log(`Got payment for: ${params.amount}`)\n *   }\n * })\n *\n * const { destinationAccount, sharedSecret } = receiver.generateAddressAndSecret()\n * // Give these two values to a sender to enable them to send payments to this Receiver\n * ```\n */\nexport async function createReceiver (opts: ReceiverOpts): Promise<Receiver> {\n  const {\n    plugin,\n    paymentHandler,\n    requestHandler,\n    secret = crypto.randomBytes(32)\n  } = opts\n  const receiver = new Receiver(plugin, secret)\n  if (paymentHandler) {\n    receiver.registerPaymentHandler(paymentHandler)\n  }\n  if (requestHandler) {\n    receiver.registerRequestHandler(requestHandler)\n  }\n  await receiver.connect()\n  return receiver\n}\n\nasync function callRequestHandler (requestHandler: RequestHandler, isFulfillable: boolean, requestId: number, amount: string, data: Buffer, keyId?: Buffer): Promise<{ fulfill: boolean, responseData: Buffer }> {\n  let fulfill = false\n  let finalized = false\n  let responseData = Buffer.alloc(0)\n\n  // This promise resolves when the user has either accepted or rejected the payment\n  await new Promise(async (resolve, reject) => {\n    // Reject the payment if:\n    // a) the user explicity calls reject\n    // b) if they don't call accept\n    // c) if there is an error thrown in the request handler\n    try {\n      await Promise.resolve(requestHandler({\n        isFulfillable,\n        keyId,\n        amount: (isFulfillable ? new BigNumber(amount) : new BigNumber(0)),\n        data,\n        accept: (userResponse = Buffer.alloc(0)) => {\n          if (finalized) {\n            throw new Error(`Packet was already ${fulfill ? 'fulfilled' : 'rejected'}`)\n          }\n          if (!isFulfillable) {\n            throw new Error('Packet is unfulfillable')\n          }\n          finalized = true\n          fulfill = true\n          responseData = userResponse\n          debug(`user accepted packet with requestId ${requestId}${keyId ? ' for keyId: ' + base64url(keyId) : ''}`)\n          resolve()\n        },\n        reject: (userResponse = Buffer.alloc(0)) => {\n          if (finalized) {\n            throw new Error(`Packet was already ${fulfill ? 'fulfilled' : 'rejected'}`)\n          }\n          finalized = true\n          responseData = userResponse\n          debug(`user rejected packet with requestId: ${requestId}${keyId ? ' for keyId: ' + base64url(keyId) : ''}`)\n          resolve()\n        }\n      }))\n    } catch (err) {\n      debug('error in requestHandler, going to reject the packet:', err)\n    }\n    if (!finalized) {\n      finalized = true\n      debug('requestHandler returned without user calling accept or reject, rejecting the packet now')\n    }\n    resolve()\n  })\n\n  return {\n    fulfill,\n    responseData\n  }\n}\n\nfunction generateSharedSecret (secret: Buffer, token: Buffer): Buffer {\n  const sharedSecretGenerator = hmac(secret, Buffer.from(PSK_GENERATION_STRING, 'utf8'))\n  return hmac(sharedSecretGenerator, token).slice(0, SHARED_SECRET_LENGTH)\n}\n\nfunction hmac (key: Buffer, message: Buffer): Buffer {\n  const h = crypto.createHmac('sha256', key)\n  h.update(message)\n  return h.digest()\n}\n\nfunction base64url (buf: Buffer): string {\n  return buf.toString('base64')\n    .replace(/=+$/, '')\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n}\n"]}