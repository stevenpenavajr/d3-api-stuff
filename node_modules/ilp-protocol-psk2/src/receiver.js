'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const crypto = require("crypto");
const Debug = require("debug");
const debug = Debug('ilp-protocol-psk2:receiver');
const bignumber_js_1 = require("bignumber.js");
const ilp_compat_plugin_1 = require("ilp-compat-plugin");
const IlpPacket = require("ilp-packet");
const constants = require("./constants");
const encoding = require("./encoding");
const condition_1 = require("./condition");
const ILDCP = require("ilp-protocol-ildcp");
const PSK_GENERATION_STRING = 'ilp_psk2_generation';
const PSK_ADDRESS_FROM_SECRET_STRING = 'ilp_psk2_address_from_secret';
const TOKEN_LENGTH = 18;
const SHARED_SECRET_LENGTH = 32;
class Receiver {
    constructor(plugin, secret) {
        this.handleData = (data) => __awaiter(this, void 0, void 0, function* () {
            let prepare;
            let sharedSecret;
            let requestHandler;
            let keyId = undefined;
            try {
                prepare = IlpPacket.deserializeIlpPrepare(data);
            }
            catch (err) {
                debug('error parsing incoming prepare:', err);
                return this.reject('F06', 'Packet is not an IlpPrepare');
            }
            const localParts = prepare.destination.replace(this.address + '.', '').split('.');
            if (localParts.length === 0) {
                return this.reject('F02', 'Packet is not for this receiver');
            }
            if (this.specificRequestHandlers[localParts[0]]) {
                requestHandler = this.specificRequestHandlers[localParts[0]].requestHandler;
                sharedSecret = this.specificRequestHandlers[localParts[0]].sharedSecret;
            }
            else {
                const keygen = Buffer.from(localParts[0], 'base64');
                if (keygen.length > TOKEN_LENGTH) {
                    keyId = keygen.slice(TOKEN_LENGTH);
                }
                sharedSecret = generateSharedSecret(this.secret, keygen);
                requestHandler = this.requestHandler.bind(this);
            }
            let packet;
            let isLegacy;
            try {
                packet = encoding.deserializePskPacket(sharedSecret, prepare.data);
                isLegacy = false;
            }
            catch (err) {
                try {
                    packet = encoding.deserializeLegacyPskPacket(sharedSecret, prepare.data);
                    isLegacy = true;
                }
                catch (err) {
                    debug('unable to parse PSK packet, either because it is an unrecognized type or because the data has been tampered with:', JSON.stringify(prepare), err && err.message);
                    return this.reject('F06', 'Unable to parse data');
                }
            }
            if (this.usingRequestHandlerApi && !isLegacy) {
                if (packet.type !== encoding.Type.Request) {
                    debug('packet is not a PSK Request (should be type 4):', packet);
                    return this.reject('F06', 'Unexpected packet type');
                }
                packet = packet;
                let isFulfillable = false;
                let errorCode = 'F99';
                let errorMessage = '';
                let fulfillment;
                try {
                    fulfillment = condition_1.dataToFulfillment(sharedSecret, prepare.data);
                    const generatedCondition = condition_1.fulfillmentToCondition(fulfillment);
                    if (generatedCondition.equals(prepare.executionCondition)) {
                        isFulfillable = true;
                    }
                    else {
                        isFulfillable = false;
                        errorCode = 'F05';
                        errorMessage = 'Condition generated does not match prepare';
                        debug(`condition generated does not match. expected: ${prepare.executionCondition.toString('base64')}, actual: ${generatedCondition.toString('base64')}`);
                    }
                }
                catch (err) {
                    isFulfillable = false;
                    errorCode = 'F05';
                    errorMessage = 'Condition does not match prepare';
                    debug('unable to generate fulfillment from data:', err);
                }
                if (packet.amount.greaterThan(prepare.amount)) {
                    isFulfillable = false;
                    debug(`incoming transfer amount too low. actual: ${prepare.amount}, expected: ${packet.amount}`);
                }
                const { fulfill, responseData } = yield callRequestHandler(requestHandler, isFulfillable, packet.requestId, prepare.amount, packet.data, keyId);
                if (fulfill && isFulfillable) {
                    return IlpPacket.serializeIlpFulfill({
                        fulfillment: fulfillment,
                        data: encoding.serializePskPacket(sharedSecret, {
                            type: encoding.Type.Response,
                            requestId: packet.requestId,
                            amount: new bignumber_js_1.default(prepare.amount),
                            data: responseData
                        })
                    });
                }
                else {
                    return this.reject(errorCode, errorMessage, encoding.serializePskPacket(sharedSecret, {
                        type: encoding.Type.Error,
                        requestId: packet.requestId,
                        amount: new bignumber_js_1.default(prepare.amount),
                        data: responseData
                    }));
                }
            }
            else if (this.usingRequestHandlerApi && isLegacy) {
                if (packet.type !== constants.TYPE_PSK2_CHUNK && packet.type !== constants.TYPE_PSK2_LAST_CHUNK) {
                    debug('got packet with unrecognized PSK type: ', packet);
                    return this.reject('F06', 'Unsupported type');
                }
                packet = packet;
                if (packet.chunkAmount.gt(prepare.amount)) {
                    debug(`incoming transfer amount too low. actual: ${prepare.amount}, expected: ${packet.chunkAmount.toString(10)}`);
                    return this.reject('F99', '', encoding.serializeLegacyPskPacket(sharedSecret, {
                        type: constants.TYPE_PSK2_REJECT,
                        paymentId: packet.paymentId,
                        sequence: packet.sequence,
                        chunkAmount: new bignumber_js_1.default(prepare.amount),
                        paymentAmount: new bignumber_js_1.default(0)
                    }));
                }
                let fulfillment;
                try {
                    fulfillment = condition_1.dataToFulfillment(sharedSecret, prepare.data);
                    const generatedCondition = condition_1.fulfillmentToCondition(fulfillment);
                    assert(generatedCondition.equals(prepare.executionCondition), `condition generated does not match. expected: ${prepare.executionCondition.toString('base64')}, actual: ${generatedCondition.toString('base64')}`);
                }
                catch (err) {
                    debug('error regenerating fulfillment:', err);
                    return this.reject('F05', 'Condition generated does not match prepare', encoding.serializeLegacyPskPacket(sharedSecret, {
                        type: constants.TYPE_PSK2_REJECT,
                        paymentId: packet.paymentId,
                        sequence: packet.sequence,
                        paymentAmount: new bignumber_js_1.default(0),
                        chunkAmount: new bignumber_js_1.default(prepare.amount),
                        applicationData: Buffer.alloc(0)
                    }));
                }
                const compatibilityData = Buffer.alloc(20);
                packet.paymentId.copy(compatibilityData);
                compatibilityData.writeUInt32BE(packet.sequence, 16);
                const { fulfill } = yield callRequestHandler(requestHandler, true, packet.sequence, prepare.amount, compatibilityData, keyId);
                if (fulfill) {
                    return IlpPacket.serializeIlpFulfill({
                        fulfillment,
                        data: encoding.serializeLegacyPskPacket(sharedSecret, {
                            type: constants.TYPE_PSK2_FULFILLMENT,
                            paymentId: packet.paymentId,
                            sequence: packet.sequence,
                            paymentAmount: new bignumber_js_1.default(0),
                            chunkAmount: new bignumber_js_1.default(prepare.amount),
                            applicationData: Buffer.alloc(0)
                        })
                    });
                }
                else {
                    return this.reject('F99', '', encoding.serializeLegacyPskPacket(sharedSecret, {
                        type: constants.TYPE_PSK2_REJECT,
                        paymentId: packet.paymentId,
                        sequence: packet.sequence,
                        paymentAmount: new bignumber_js_1.default(0),
                        chunkAmount: new bignumber_js_1.default(prepare.amount),
                        applicationData: Buffer.alloc(0)
                    }));
                }
            }
            else {
                let request;
                try {
                    request = encoding.deserializeLegacyPskPacket(sharedSecret, prepare.data);
                }
                catch (err) {
                    debug('error decrypting data:', err);
                    return this.reject('F06', 'Unable to parse data');
                }
                if ([constants.TYPE_PSK2_CHUNK, constants.TYPE_PSK2_LAST_CHUNK].indexOf(request.type) === -1) {
                    debug(`got unexpected request type: ${request.type}`);
                    return this.reject('F06', 'Unexpected request type');
                }
                const paymentId = request.paymentId.toString('hex');
                let record = this.payments[paymentId];
                if (!record) {
                    record = {
                        received: new bignumber_js_1.default(0),
                        expected: new bignumber_js_1.default(0),
                        finished: false,
                        finishedPromise: null,
                        acceptedByReceiver: null,
                        rejectionMessage: 'rejected by receiver',
                        chunksFulfilled: 0,
                        chunksRejected: 0
                    };
                    this.payments[paymentId] = record;
                }
                record.expected = request.paymentAmount;
                const rejectTransfer = (message) => {
                    debug(`rejecting transfer ${request.sequence} of payment ${paymentId}: ${message}`);
                    record.chunksRejected += 1;
                    const data = encoding.serializeLegacyPskPacket(sharedSecret, {
                        type: constants.TYPE_PSK2_REJECT,
                        paymentId: request.paymentId,
                        sequence: request.sequence,
                        paymentAmount: record.received,
                        chunkAmount: new bignumber_js_1.default(prepare.amount)
                    });
                    return this.reject('F99', '', data);
                };
                if (request.chunkAmount.gt(prepare.amount)) {
                    return rejectTransfer(`incoming transfer amount too low. actual: ${prepare.amount}, expected: ${request.chunkAmount.toString(10)}`);
                }
                if (record.finished) {
                    return rejectTransfer(`payment is already finished`);
                }
                let fulfillment;
                try {
                    fulfillment = condition_1.dataToFulfillment(sharedSecret, prepare.data);
                    const generatedCondition = condition_1.fulfillmentToCondition(fulfillment);
                    assert(generatedCondition.equals(prepare.executionCondition), `condition generated does not match. expected: ${prepare.executionCondition.toString('base64')}, actual: ${generatedCondition.toString('base64')}`);
                }
                catch (err) {
                    debug('error regenerating fulfillment:', err);
                    record.chunksRejected += 1;
                    return this.reject('F05', 'condition generated does not match prepare');
                }
                let chunkAccepted = !!record.acceptedByReceiver;
                let userCalledAcceptOrReject = false;
                if (record.acceptedByReceiver === null) {
                    yield new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                        try {
                            yield Promise.resolve(this.paymentHandler({
                                id: request.paymentId,
                                expectedAmount: record.expected.toString(10),
                                accept: () => __awaiter(this, void 0, void 0, function* () {
                                    userCalledAcceptOrReject = true;
                                    record.acceptedByReceiver = true;
                                    chunkAccepted = true;
                                    resolve();
                                    const payment = yield new Promise((resolve, reject) => {
                                        record.finishedPromise = { resolve, reject };
                                    });
                                    return payment;
                                }),
                                reject: (message) => {
                                    userCalledAcceptOrReject = true;
                                    debug('receiver rejected payment with message:', message);
                                    record.acceptedByReceiver = false;
                                    record.rejectionMessage = message;
                                    record.finished = false;
                                },
                                acceptSingleChunk: () => {
                                    userCalledAcceptOrReject = true;
                                    chunkAccepted = true;
                                    record.acceptedByReceiver = null;
                                    resolve();
                                },
                                rejectSingleChunk: (message) => {
                                    userCalledAcceptOrReject = true;
                                    chunkAccepted = false;
                                    record.acceptedByReceiver = null;
                                    record.rejectionMessage = message;
                                    resolve();
                                },
                                prepare
                            }));
                            if (!userCalledAcceptOrReject) {
                                record.acceptedByReceiver = false;
                                record.rejectionMessage = 'receiver did not accept the payment';
                                record.finished = true;
                            }
                        }
                        catch (err) {
                            debug('error thrown in payment handler:', err);
                            record.acceptedByReceiver = false;
                            record.rejectionMessage = err && err.message;
                        }
                        resolve();
                    }));
                }
                if (record.acceptedByReceiver === false) {
                    debug(`rejecting chunk because payment ${paymentId} was rejected by receiver with message: ${record.rejectionMessage}`);
                    record.chunksRejected += 1;
                    return this.reject('F99', record.rejectionMessage);
                }
                if (!chunkAccepted) {
                    debug(`rejecting chunk ${request.sequence} of payment ${paymentId} because it was rejected by the receiver with the message: ${record.rejectionMessage}`);
                    record.chunksRejected += 1;
                    return this.reject('F99', record.rejectionMessage);
                }
                record.chunksFulfilled += 1;
                record.received = record.received.plus(prepare.amount);
                if (record.received.gte(record.expected) || request.type === constants.TYPE_PSK2_LAST_CHUNK) {
                    record.finished = true;
                    record.finishedPromise && record.finishedPromise.resolve({
                        id: request.paymentId,
                        receivedAmount: record.received.toString(10),
                        expectedAmount: record.expected.toString(10),
                        chunksFulfilled: record.chunksFulfilled,
                        chunksRejected: record.chunksRejected
                    });
                }
                debug(`got ${record.finished ? 'last ' : ''}chunk of amount ${prepare.amount} for payment: ${paymentId}. total received: ${record.received.toString(10)}`);
                const response = encoding.serializeLegacyPskPacket(sharedSecret, {
                    type: constants.TYPE_PSK2_FULFILLMENT,
                    paymentId: request.paymentId,
                    sequence: request.sequence,
                    paymentAmount: record.received,
                    chunkAmount: new bignumber_js_1.default(prepare.amount)
                });
                debug(`fulfilling transfer ${request.sequence} for payment ${paymentId} with fulfillment: ${fulfillment.toString('base64')}`);
                return IlpPacket.serializeIlpFulfill({
                    fulfillment,
                    data: response
                });
            }
        });
        this.plugin = ilp_compat_plugin_1.default(plugin);
        assert(secret.length >= 32, 'secret must be at least 32 bytes');
        this.secret = secret;
        this.paymentHandler = this.defaultPaymentHandler;
        this.address = '';
        this.payments = {};
        this.connected = false;
        this.requestHandler = this.defaultRequestHandler;
        this.usingRequestHandlerApi = false;
        this.specificRequestHandlers = {};
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            debug('connect called');
            yield this.plugin.connect();
            this.address = (yield ILDCP.fetch(this.plugin.sendData.bind(this.plugin))).clientAddress;
            this.plugin.registerDataHandler(this.handleData);
            this.connected = true;
            debug('connected');
        });
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            debug('disconnect called');
            this.connected = false;
            this.plugin.deregisterDataHandler();
            yield this.plugin.disconnect();
            debug('disconnected');
        });
    }
    isConnected() {
        this.connected = this.connected && this.plugin.isConnected();
        return this.connected;
    }
    registerRequestHandler(handler) {
        if (this.paymentHandler !== this.defaultPaymentHandler) {
            throw new Error('PaymentHandler and RequestHandler APIs cannot be used at the same time');
        }
        debug('registered request handler');
        this.usingRequestHandlerApi = true;
        this.requestHandler = handler;
    }
    deregisterRequestHandler() {
        this.requestHandler = this.defaultRequestHandler;
    }
    registerPaymentHandler(handler) {
        console.warn('DeprecationWarning: registerPaymentHandler is deprecated and will be removed in the next version. Use registerRequestHandler instead');
        if (this.usingRequestHandlerApi) {
            throw new Error('PaymentHandler and RequestHandler APIs cannot be used at the same time');
        }
        debug('registered payment handler');
        assert(typeof handler === 'function', 'payment handler must be a function');
        this.paymentHandler = handler;
    }
    deregisterPaymentHandler() {
        this.paymentHandler = this.defaultPaymentHandler;
    }
    generateAddressAndSecret(keyId) {
        assert(this.connected, 'Receiver must be connected');
        const token = crypto.randomBytes(TOKEN_LENGTH);
        const keygen = (keyId ? Buffer.concat([token, keyId]) : token);
        const sharedSecret = generateSharedSecret(this.secret, keygen);
        return {
            sharedSecret,
            destinationAccount: `${this.address}.${base64url(keygen)}`
        };
    }
    registerRequestHandlerForSecret(sharedSecret, handler) {
        if (this.paymentHandler !== this.defaultPaymentHandler) {
            throw new Error('PaymentHandler and RequestHandler APIs cannot be used at the same time');
        }
        this.usingRequestHandlerApi = true;
        const generator = hmac(this.secret, Buffer.from(PSK_ADDRESS_FROM_SECRET_STRING, 'utf8'));
        const addressSuffix = base64url(hmac(generator, sharedSecret).slice(0, TOKEN_LENGTH));
        if (this.specificRequestHandlers[addressSuffix]) {
            throw new Error('RequestHandler already registered for that sharedSecret. The old handler must be deregistered first before another one is added');
        }
        this.specificRequestHandlers[addressSuffix] = {
            sharedSecret,
            requestHandler: handler
        };
        debug(`added specific request handler for address suffix: ${addressSuffix}`);
        return {
            sharedSecret,
            destinationAccount: `${this.address}.${addressSuffix}`
        };
    }
    deregisterRequestHandlerForSecret(sharedSecret) {
        const generator = hmac(this.secret, Buffer.from(PSK_ADDRESS_FROM_SECRET_STRING, 'utf8'));
        const addressSuffix = base64url(hmac(generator, sharedSecret).slice(0, TOKEN_LENGTH));
        if (this.specificRequestHandlers[addressSuffix]) {
            delete this.specificRequestHandlers[addressSuffix];
            debug(`removed specific request handler for address suffix: ${addressSuffix}`);
        }
        else {
            debug(`tried to remove specific request handler for address suffix: ${addressSuffix}, but there was no handler registerd`);
        }
    }
    defaultPaymentHandler(params) {
        return __awaiter(this, void 0, void 0, function* () {
            debug(`Receiver has no handler registered, rejecting payment ${params.id.toString('hex')}`);
            return params.reject('Receiver has no payment handler registered');
        });
    }
    defaultRequestHandler(params) {
        return __awaiter(this, void 0, void 0, function* () {
            debug(`Receiver has no handler registered, rejecting request of amount: ${params.amount} with data: ${params.data.toString('hex')}`);
            return params.reject(Buffer.alloc(0));
        });
    }
    reject(code, message, data) {
        return IlpPacket.serializeIlpReject({
            code,
            message: message || '',
            data: data || Buffer.alloc(0),
            triggeredBy: this.address
        });
    }
}
exports.Receiver = Receiver;
function createReceiver(opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const { plugin, paymentHandler, requestHandler, secret = crypto.randomBytes(32) } = opts;
        const receiver = new Receiver(plugin, secret);
        if (paymentHandler) {
            receiver.registerPaymentHandler(paymentHandler);
        }
        if (requestHandler) {
            receiver.registerRequestHandler(requestHandler);
        }
        yield receiver.connect();
        return receiver;
    });
}
exports.createReceiver = createReceiver;
function callRequestHandler(requestHandler, isFulfillable, requestId, amount, data, keyId) {
    return __awaiter(this, void 0, void 0, function* () {
        let fulfill = false;
        let finalized = false;
        let responseData = Buffer.alloc(0);
        yield new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                yield Promise.resolve(requestHandler({
                    isFulfillable,
                    keyId,
                    amount: (isFulfillable ? new bignumber_js_1.default(amount) : new bignumber_js_1.default(0)),
                    data,
                    accept: (userResponse = Buffer.alloc(0)) => {
                        if (finalized) {
                            throw new Error(`Packet was already ${fulfill ? 'fulfilled' : 'rejected'}`);
                        }
                        if (!isFulfillable) {
                            throw new Error('Packet is unfulfillable');
                        }
                        finalized = true;
                        fulfill = true;
                        responseData = userResponse;
                        debug(`user accepted packet with requestId ${requestId}${keyId ? ' for keyId: ' + base64url(keyId) : ''}`);
                        resolve();
                    },
                    reject: (userResponse = Buffer.alloc(0)) => {
                        if (finalized) {
                            throw new Error(`Packet was already ${fulfill ? 'fulfilled' : 'rejected'}`);
                        }
                        finalized = true;
                        responseData = userResponse;
                        debug(`user rejected packet with requestId: ${requestId}${keyId ? ' for keyId: ' + base64url(keyId) : ''}`);
                        resolve();
                    }
                }));
            }
            catch (err) {
                debug('error in requestHandler, going to reject the packet:', err);
            }
            if (!finalized) {
                finalized = true;
                debug('requestHandler returned without user calling accept or reject, rejecting the packet now');
            }
            resolve();
        }));
        return {
            fulfill,
            responseData
        };
    });
}
function generateSharedSecret(secret, token) {
    const sharedSecretGenerator = hmac(secret, Buffer.from(PSK_GENERATION_STRING, 'utf8'));
    return hmac(sharedSecretGenerator, token).slice(0, SHARED_SECRET_LENGTH);
}
function hmac(key, message) {
    const h = crypto.createHmac('sha256', key);
    h.update(message);
    return h.digest();
}
function base64url(buf) {
    return buf.toString('base64')
        .replace(/=+$/, '')
        .replace(/\+/g, '-')
        .replace(/\//g, '_');
}
//# sourceMappingURL=receiver.js.map