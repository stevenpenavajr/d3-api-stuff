{"version":3,"file":"crypto.js","sourceRoot":"","sources":["crypto.ts"],"names":[],"mappings":"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","sourcesContent":["import * as crypto from 'crypto'\nimport * as assert from 'assert'\nrequire('source-map-support').install()\n\nconst HASH_ALGORITHM = 'sha256'\nconst ENCRYPTION_ALGORITHM = 'aes-256-gcm'\nconst ENCRYPTION_KEY_STRING = Buffer.from('ilp_stream_encryption', 'utf8')\nconst IV_LENGTH = 12\nconst AUTH_TAG_LENGTH = 16\nexport const ENCRYPTION_OVERHEAD = 28\n\nconst FULFILLMENT_GENERATION_STRING = Buffer.from('ilp_stream_fulfillment', 'utf8')\n\nconst TOKEN_LENGTH = 18\nconst SHARED_SECRET_GENERATION_STRING = Buffer.from('ilp_stream_shared_secret', 'utf8')\n\nexport function generateToken (): Buffer {\n  return crypto.randomBytes(TOKEN_LENGTH)\n}\n\nexport function generateTokenAndSharedSecret (seed: Buffer): { token: Buffer, sharedSecret: Buffer } {\n  const token = crypto.randomBytes(TOKEN_LENGTH)\n  const sharedSecret = generateSharedSecretFromToken(seed, token)\n  return { token, sharedSecret }\n}\n\nexport function generateSharedSecretFromToken (seed: Buffer, token: Buffer): Buffer {\n  const keygen = hmac(seed, SHARED_SECRET_GENERATION_STRING)\n  const sharedSecret = hmac(keygen, token)\n  return sharedSecret\n}\n\nexport function generateRandomCondition () {\n  return crypto.randomBytes(32)\n}\n\nexport function generateFulfillment (sharedSecret: Buffer, data: Buffer) {\n  const fulfillmentKey = hmac(sharedSecret, FULFILLMENT_GENERATION_STRING)\n  const fulfillment = hmac(fulfillmentKey, data)\n  return fulfillment\n}\n\nexport function hash (preimage: Buffer) {\n  const h = crypto.createHash(HASH_ALGORITHM)\n  h.update(preimage)\n  return h.digest()\n}\n\nexport function encrypt (sharedSecret: Buffer, ...buffers: Buffer[]): Buffer {\n  const iv = crypto.randomBytes(IV_LENGTH)\n  // TODO only generate the key once per connection\n  const pskEncryptionKey = hmac(sharedSecret, ENCRYPTION_KEY_STRING)\n  const cipher = crypto.createCipheriv(ENCRYPTION_ALGORITHM, pskEncryptionKey, iv)\n\n  const ciphertext = []\n  for (let buffer of buffers) {\n    ciphertext.push(cipher.update(buffer))\n  }\n  ciphertext.push(cipher.final())\n  const tag = cipher.getAuthTag()\n  ciphertext.unshift(iv, tag)\n  return Buffer.concat(ciphertext)\n}\n\nexport function decrypt (sharedSecret: Buffer, data: Buffer): Buffer {\n  assert(data.length > 0, 'cannot decrypt empty buffer')\n  // TODO only generate the key once per connection\n  const pskEncryptionKey = hmac(sharedSecret, ENCRYPTION_KEY_STRING)\n  const nonce = data.slice(0, IV_LENGTH)\n  const tag = data.slice(IV_LENGTH, IV_LENGTH + AUTH_TAG_LENGTH)\n  const encrypted = data.slice(IV_LENGTH + AUTH_TAG_LENGTH)\n  const decipher = crypto.createDecipheriv(ENCRYPTION_ALGORITHM, pskEncryptionKey, nonce)\n  decipher.setAuthTag(tag)\n\n  return Buffer.concat([\n    decipher.update(encrypted),\n    decipher.final()\n  ])\n}\n\nfunction hmac (key: Buffer, message: Buffer): Buffer {\n  const h = crypto.createHmac(HASH_ALGORITHM, key)\n  h.update(message)\n  return h.digest()\n}\n"]}