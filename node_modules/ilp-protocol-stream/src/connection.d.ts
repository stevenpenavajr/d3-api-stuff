/// <reference types="node" />
import { EventEmitter } from 'events';
import { DataAndMoneyStream } from './stream';
import * as IlpPacket from 'ilp-packet';
import { Packet, Frame, StreamCloseFrame, ErrorCode } from './packet';
import { Plugin } from './util/plugin-interface';
import BigNumber from 'bignumber.js';
export interface ConnectionOpts {
    plugin: Plugin;
    destinationAccount?: string;
    sourceAccount?: string;
    slippage?: BigNumber.Value;
    enablePadding?: boolean;
    connectionTag?: string;
    maxRemoteStreams?: number;
    connectionBufferSize?: number;
    minExchangeRatePrecision?: number;
    idleTimeout?: number;
}
export interface FullConnectionOpts extends ConnectionOpts {
    sourceAccount: string;
    assetCode: string;
    assetScale: number;
    isServer: boolean;
    sharedSecret: Buffer;
}
export declare class ConnectionError extends Error {
    streamErrorCode: ErrorCode;
    constructor(message: string, streamErrorCode?: ErrorCode);
}
export declare class Connection extends EventEmitter {
    readonly connectionTag?: string;
    protected plugin: Plugin;
    protected _sourceAccount: string;
    protected _sourceAssetCode: string;
    protected _sourceAssetScale: number;
    protected _destinationAccount?: string;
    protected _destinationAssetCode?: string;
    protected _destinationAssetScale?: number;
    protected sharedSecret: Buffer;
    protected isServer: boolean;
    protected slippage: BigNumber;
    protected allowableReceiveExtra: BigNumber;
    protected enablePadding: boolean;
    protected maxBufferedData: number;
    protected idleTimeout: number;
    protected lastActive: Date;
    protected idleTimer: NodeJS.Timer;
    protected nextPacketSequence: number;
    protected streams: Map<number, DataAndMoneyStream>;
    protected closedStreams: {
        [id: number]: boolean;
    };
    protected nextStreamId: number;
    protected maxStreamId: number;
    protected log: any;
    protected sending: boolean;
    protected testMaximumPacketAmount: BigNumber;
    protected maximumPacketAmount: BigNumber;
    protected minExchangeRatePrecision: number;
    protected closed: boolean;
    protected exchangeRate?: BigNumber;
    protected retryDelay: number;
    protected queuedFrames: Frame[];
    protected remoteClosed: boolean;
    protected remoteMaxStreamId: number;
    protected remoteKnowsOurAccount: boolean;
    protected remoteMaxOffset: number;
    protected _totalReceived: BigNumber;
    protected _totalSent: BigNumber;
    protected _totalDelivered: BigNumber;
    protected _lastPacketExchangeRate: BigNumber;
    constructor(opts: FullConnectionOpts);
    connect(): Promise<void>;
    end(): Promise<void>;
    destroy(err?: Error): Promise<void>;
    createStream(): DataAndMoneyStream;
    readonly destinationAccount: string | undefined;
    readonly destinationAssetScale: number | undefined;
    readonly destinationAssetCode: string | undefined;
    readonly sourceAccount: string;
    readonly sourceAssetScale: number;
    readonly sourceAssetCode: string;
    readonly minimumAcceptableExchangeRate: string;
    readonly lastPacketExchangeRate: string;
    readonly totalDelivered: string;
    readonly totalSent: string;
    readonly totalReceived: string;
    handlePrepare(prepare: IlpPacket.IlpPrepare): Promise<IlpPacket.IlpFulfill>;
    protected handleControlFrames(frames: Frame[]): void;
    protected handleConnect(): void;
    protected handleNewStream(streamId: number): void;
    protected handleStreamClose(frame: StreamCloseFrame): void;
    protected startSendLoop(): Promise<void>;
    protected loadAndSendPacket(): Promise<void>;
    protected sendTestPacketVolley(testPacketAmounts: number[]): Promise<any>;
    protected determineExchangeRate(): Promise<void>;
    protected sendTestPacket(amount: BigNumber, timeout?: number): Promise<Packet | IlpPacket.IlpReject | null>;
    protected sendConnectionClose(err?: ConnectionError | Error): Promise<void>;
    protected sendPacket(packet: Packet, sourceAmount: BigNumber, unfulfillable?: boolean): Promise<Packet | void>;
    protected undoRejectedPacket(requestPacket: Packet): void;
    protected handleConnectorError(reject: IlpPacket.IlpReject, amountSent: BigNumber): Promise<void>;
    protected safeEmit(event: string, ...args: any[]): void;
    protected getOutgoingOffsets(): {
        currentOffset: number;
        maxOffset: number;
    };
    protected getIncomingOffsets(): {
        current: number;
        max: number;
        maxAcceptable: number;
    };
    protected removeStreamRecord(stream: DataAndMoneyStream): void;
    private startIdleTimer;
    private testIdle;
    private bumpIdle;
}
