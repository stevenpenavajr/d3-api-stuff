"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto = require("crypto");
const assert = require("assert");
require('source-map-support').install();
const HASH_ALGORITHM = 'sha256';
const ENCRYPTION_ALGORITHM = 'aes-256-gcm';
const ENCRYPTION_KEY_STRING = Buffer.from('ilp_stream_encryption', 'utf8');
const IV_LENGTH = 12;
const AUTH_TAG_LENGTH = 16;
exports.ENCRYPTION_OVERHEAD = 28;
const FULFILLMENT_GENERATION_STRING = Buffer.from('ilp_stream_fulfillment', 'utf8');
const TOKEN_LENGTH = 18;
const SHARED_SECRET_GENERATION_STRING = Buffer.from('ilp_stream_shared_secret', 'utf8');
function generateToken() {
    return crypto.randomBytes(TOKEN_LENGTH);
}
exports.generateToken = generateToken;
function generateTokenAndSharedSecret(seed) {
    const token = crypto.randomBytes(TOKEN_LENGTH);
    const sharedSecret = generateSharedSecretFromToken(seed, token);
    return { token, sharedSecret };
}
exports.generateTokenAndSharedSecret = generateTokenAndSharedSecret;
function generateSharedSecretFromToken(seed, token) {
    const keygen = hmac(seed, SHARED_SECRET_GENERATION_STRING);
    const sharedSecret = hmac(keygen, token);
    return sharedSecret;
}
exports.generateSharedSecretFromToken = generateSharedSecretFromToken;
function generateRandomCondition() {
    return crypto.randomBytes(32);
}
exports.generateRandomCondition = generateRandomCondition;
function generateFulfillment(sharedSecret, data) {
    const fulfillmentKey = hmac(sharedSecret, FULFILLMENT_GENERATION_STRING);
    const fulfillment = hmac(fulfillmentKey, data);
    return fulfillment;
}
exports.generateFulfillment = generateFulfillment;
function hash(preimage) {
    const h = crypto.createHash(HASH_ALGORITHM);
    h.update(preimage);
    return h.digest();
}
exports.hash = hash;
function encrypt(sharedSecret, ...buffers) {
    const iv = crypto.randomBytes(IV_LENGTH);
    const pskEncryptionKey = hmac(sharedSecret, ENCRYPTION_KEY_STRING);
    const cipher = crypto.createCipheriv(ENCRYPTION_ALGORITHM, pskEncryptionKey, iv);
    const ciphertext = [];
    for (let buffer of buffers) {
        ciphertext.push(cipher.update(buffer));
    }
    ciphertext.push(cipher.final());
    const tag = cipher.getAuthTag();
    ciphertext.unshift(iv, tag);
    return Buffer.concat(ciphertext);
}
exports.encrypt = encrypt;
function decrypt(sharedSecret, data) {
    assert(data.length > 0, 'cannot decrypt empty buffer');
    const pskEncryptionKey = hmac(sharedSecret, ENCRYPTION_KEY_STRING);
    const nonce = data.slice(0, IV_LENGTH);
    const tag = data.slice(IV_LENGTH, IV_LENGTH + AUTH_TAG_LENGTH);
    const encrypted = data.slice(IV_LENGTH + AUTH_TAG_LENGTH);
    const decipher = crypto.createDecipheriv(ENCRYPTION_ALGORITHM, pskEncryptionKey, nonce);
    decipher.setAuthTag(tag);
    return Buffer.concat([
        decipher.update(encrypted),
        decipher.final()
    ]);
}
exports.decrypt = decrypt;
function hmac(key, message) {
    const h = crypto.createHmac(HASH_ALGORITHM, key);
    h.update(message);
    return h.digest();
}
//# sourceMappingURL=crypto.js.map