{"version":3,"file":"connection.js","sourceRoot":"","sources":["connection.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events'\nimport createLogger from 'ilp-logger'\nimport { DataAndMoneyStream } from './stream'\nimport * as IlpPacket from 'ilp-packet'\nimport * as cryptoHelper from './crypto'\nimport {\n  Packet,\n  Frame,\n  StreamMoneyFrame,\n  StreamCloseFrame,\n  StreamDataFrame,\n  StreamMaxMoneyFrame,\n  FrameType,\n  IlpPacketType,\n  ConnectionNewAddressFrame,\n  ConnectionAssetDetailsFrame,\n  ErrorCode,\n  ConnectionCloseFrame,\n  ConnectionStreamIdBlockedFrame,\n  ConnectionMaxStreamIdFrame,\n  StreamMaxDataFrame,\n  StreamDataBlockedFrame,\n  ConnectionMaxDataFrame,\n  ConnectionDataBlockedFrame,\n  StreamMoneyBlockedFrame\n} from './packet'\nimport { Reader } from 'oer-utils'\nimport { Plugin } from './util/plugin-interface'\nimport BigNumber from 'bignumber.js'\nrequire('source-map-support').install()\n\nconst RETRY_DELAY_START = 100\nconst RETRY_DELAY_MAX = 43200000 // 12 hours should be long enough\nconst RETRY_DELAY_INCREASE_FACTOR = 1.5\nconst DEFAULT_PACKET_TIMEOUT = 30000\nconst DEFAULT_IDLE_TIMEOUT = 60000 // 1 minute\nconst MAX_DATA_SIZE = 32767\nconst DEFAULT_MAX_REMOTE_STREAMS = 10\nconst DEFAULT_MINIMUM_EXCHANGE_RATE_PRECISION = 3\nconst TEST_PACKET_MAX_ATTEMPTS = 20\n\nexport interface ConnectionOpts {\n  /** Ledger plugin (V2) */\n  plugin: Plugin,\n  /** ILP Address of the remote entity */\n  destinationAccount?: string,\n  /** ILP Address of the plugin */\n  sourceAccount?: string,\n  /** Specifies how much worse than the initial test packet that the exchange rate is allowed to get before packets are rejected */\n  slippage?: BigNumber.Value,\n  /** Pad packets to the maximum size (data field of 32767 bytes). False by default */\n  enablePadding?: boolean,\n  /** User-specified connection identifier that was passed into [`generateAddressAndSecret`]{@link Server#generateAddressAndSecret} */\n  connectionTag?: string,\n  /** Maximum number of streams the other entity can have open at once. Defaults to 10 */\n  maxRemoteStreams?: number,\n  /** Number of bytes each connection can have in the buffer. Defaults to 65534 */\n  connectionBufferSize?: number\n  /** Minimum Precision to use when determining the exchange rate */\n  minExchangeRatePrecision?: number\n  /** Inactivity timeout (milliseconds) */\n  idleTimeout?: number\n}\n\nexport interface FullConnectionOpts extends ConnectionOpts {\n  sourceAccount: string,\n  assetCode: string,\n  assetScale: number,\n  isServer: boolean,\n  /** Shared secret generated by the server with [`generateAddressAndSecret`]{@link Server#generateAddressAndSecret} */\n  sharedSecret: Buffer\n}\n\nexport class ConnectionError extends Error {\n  streamErrorCode: ErrorCode\n\n  constructor (message: string, streamErrorCode?: ErrorCode) {\n    super(message)\n    this.streamErrorCode = streamErrorCode || ErrorCode.InternalError\n  }\n}\n\n/**\n * Class representing the connection between a [`Client`]{@link createConnection} and a [`Server`]{@link Server}.\n * A single connection can be used to send or receive on [Streams]{@link DataAndMoneyStream}.\n *\n * Streams are created using the [`createStream`]{@link createStream} method.\n * The `'stream'` event will be emitted whenever a new incoming stream is opened by the other party.\n */\nexport class Connection extends EventEmitter {\n  /** Application identifier for a certain connection */\n  readonly connectionTag?: string\n\n  protected plugin: Plugin\n  protected _sourceAccount: string\n  protected _sourceAssetCode: string\n  protected _sourceAssetScale: number\n  protected _destinationAccount?: string\n  protected _destinationAssetCode?: string\n  protected _destinationAssetScale?: number\n  protected sharedSecret: Buffer\n  protected isServer: boolean\n  protected slippage: BigNumber\n  protected allowableReceiveExtra: BigNumber\n  protected enablePadding: boolean\n  protected maxBufferedData: number\n\n  protected idleTimeout: number\n  protected lastActive: Date\n  protected idleTimer: NodeJS.Timer\n\n  protected nextPacketSequence: number\n  protected streams: Map<number, DataAndMoneyStream>\n  protected closedStreams: { [id: number]: boolean }\n  protected nextStreamId: number\n  protected maxStreamId: number\n  protected log: any\n  protected sending: boolean\n  /** Used to probe for the Maximum Packet Amount if the connectors don't tell us directly */\n  protected testMaximumPacketAmount: BigNumber\n  /** The path's Maximum Packet Amount, discovered through F08 errors */\n  protected maximumPacketAmount: BigNumber\n  protected minExchangeRatePrecision: number\n  protected closed: boolean\n  protected exchangeRate?: BigNumber\n  protected retryDelay: number\n  protected queuedFrames: Frame[]\n\n  protected remoteClosed: boolean\n  protected remoteMaxStreamId: number\n  protected remoteKnowsOurAccount: boolean\n\n  // TODO use bignumbers for byte offsets\n  protected remoteMaxOffset: number\n  protected _totalReceived: BigNumber\n  protected _totalSent: BigNumber\n  protected _totalDelivered: BigNumber\n  protected _lastPacketExchangeRate: BigNumber\n\n  constructor (opts: FullConnectionOpts) {\n    super()\n    this.plugin = opts.plugin\n    this._sourceAccount = opts.sourceAccount\n    this._sourceAssetCode = opts.assetCode\n    this._sourceAssetScale = opts.assetScale\n    this._destinationAccount = opts.destinationAccount\n    this.sharedSecret = opts.sharedSecret\n    this.isServer = opts.isServer\n    this.slippage = new BigNumber(opts.slippage || 0)\n    this.allowableReceiveExtra = new BigNumber(1.01)\n    this.enablePadding = !!opts.enablePadding\n    this.connectionTag = opts.connectionTag\n    this.maxStreamId = 2 * (opts.maxRemoteStreams || DEFAULT_MAX_REMOTE_STREAMS)\n    this.maxBufferedData = opts.connectionBufferSize || MAX_DATA_SIZE * 2\n    this.minExchangeRatePrecision = opts.minExchangeRatePrecision || DEFAULT_MINIMUM_EXCHANGE_RATE_PRECISION\n    this.idleTimeout = opts.idleTimeout || DEFAULT_IDLE_TIMEOUT\n    this.lastActive = new Date()\n\n    this.nextPacketSequence = 1\n    // TODO should streams be a Map or just an object?\n    this.streams = new Map()\n    this.closedStreams = {}\n    this.nextStreamId = (this.isServer ? 2 : 1)\n    this.log = createLogger(`ilp-protocol-stream:${this.isServer ? 'Server' : 'Client'}:Connection`)\n    this.sending = false\n    this.closed = true\n    this.queuedFrames = []\n\n    this.maximumPacketAmount = new BigNumber(Infinity)\n    this.testMaximumPacketAmount = new BigNumber(Infinity)\n    this.retryDelay = RETRY_DELAY_START\n\n    this.remoteClosed = false\n    this.remoteKnowsOurAccount = this.isServer\n    this.remoteMaxStreamId = DEFAULT_MAX_REMOTE_STREAMS * 2\n\n    this.remoteMaxOffset = this.maxBufferedData\n\n    this._totalReceived = new BigNumber(0)\n    this._totalSent = new BigNumber(0)\n    this._totalDelivered = new BigNumber(0)\n    this._lastPacketExchangeRate = new BigNumber(0)\n  }\n\n  /**\n   * New incoming stream event\n   * @event stream\n   * @type {DataAndMoneyStream}\n   */\n\n  /**\n   * Start sending or receiving.\n   * @fires stream\n   */\n  async connect (): Promise<void> {\n    if (!this.closed) {\n      return Promise.resolve()\n    }\n    /* tslint:disable-next-line:no-floating-promises */\n    this.startSendLoop()\n    await new Promise((resolve, reject) => {\n      const connectHandler = () => {\n        cleanup()\n        resolve()\n      }\n      const closeHandler = () => {\n        cleanup()\n        reject(new Error('Connection was closed before it was connected'))\n      }\n      const errorHandler = (error?: Error) => {\n        cleanup()\n        reject(new Error(`Error connecting${error ? ': ' + error.message : ''}`))\n      }\n      this.once('connect', connectHandler)\n      this.once('error', errorHandler)\n      this.once('close', closeHandler)\n      this.once('end', closeHandler)\n\n      const self = this\n      function cleanup () {\n        clearTimeout(self.idleTimer)\n        self.removeListener('connect', connectHandler)\n        self.removeListener('error', errorHandler)\n        self.removeListener('close', closeHandler)\n        self.removeListener('end', closeHandler)\n      }\n    })\n    this.closed = false\n    this.startIdleTimer()\n  }\n\n  /**\n   * Close the connection when all streams have finished sending their money and data\n   */\n  // TODO should this be sync or async?\n  async end (): Promise<void> {\n    this.log.info('closing connection')\n    // Create Promises on each stream that resolve on the 'end' event so\n    // we can wait for them all to be completed before closing the connection\n    let streamEndPromises: Promise<any>[] = []\n    for (let [_, stream] of this.streams) {\n      if (stream.isOpen()) {\n        streamEndPromises.push(new Promise((resolve, reject) => {\n          stream.on('end', resolve)\n        }))\n        stream.end()\n      }\n    }\n\n    await new Promise((resolve, reject) => {\n      this.once('_send_loop_finished', resolve)\n      this.once('error', reject)\n\n      /* tslint:disable-next-line:no-floating-promises */\n      this.startSendLoop()\n    })\n    // Wait for the send loop to finish & all the streams to end\n    // before marking the connection as closed so the streams\n    // can finish sending data or money.\n    await Promise.all(streamEndPromises)\n\n    this.closed = true\n    await this.sendConnectionClose()\n    this.safeEmit('end')\n    this.safeEmit('close')\n  }\n\n  /**\n   * Immediately close the connection and all streams\n   */\n  // TODO should this be sync or async?\n  async destroy (err?: Error): Promise<void> {\n    this.log.error('destroying connection with error:', err)\n    if (err) {\n      this.safeEmit('error', err)\n    }\n    // Create Promises on each stream that resolve on the 'close' event so\n    // we can wait for them all to be completed before closing the connection\n    let streamClosePromises: Promise<any>[] = []\n    for (let [_, stream] of this.streams) {\n      streamClosePromises.push(new Promise((resolve, reject) => {\n        stream.on('close', resolve)\n      }))\n      // TODO should we pass the error to each stream?\n      stream.destroy()\n    }\n    await this.sendConnectionClose(err)\n    // wait for all the streams to be closed before emitting the connection 'close'\n    await Promise.all(streamClosePromises)\n    this.safeEmit('close')\n  }\n\n  /**\n   * Returns a new bidirectional [`DataAndMoneyStream`]{@link DataAndMoneyStream}\n   */\n  createStream (): DataAndMoneyStream {\n    // Make sure we don't open more streams than the remote will allow\n    if (this.remoteMaxStreamId < this.nextStreamId) {\n      this.log.debug(`cannot create another stream. nextStreamId: ${this.nextStreamId}, remote maxStreamId: ${this.remoteMaxStreamId}`)\n      this.queuedFrames.push(new ConnectionStreamIdBlockedFrame(this.nextStreamId))\n      throw new Error(`Creating another stream would exceed the remote connection's maximum number of open streams`)\n    }\n\n    // TODO should this inform the other side?\n    const stream = new DataAndMoneyStream({\n      id: this.nextStreamId,\n      isServer: this.isServer\n    })\n    this.streams.set(this.nextStreamId, stream)\n    this.log.debug(`created stream: ${this.nextStreamId}`)\n    this.nextStreamId += 2\n\n    stream.on('_maybe_start_send_loop', this.startSendLoop.bind(this))\n    stream.once('close', () => this.removeStreamRecord(stream))\n\n    return stream\n  }\n\n  /**\n   * ILP Address of the remote party to this connection.\n   */\n  get destinationAccount (): string | undefined {\n    return this._destinationAccount\n  }\n\n  /**\n   * Scale of the asset used by the remote party to this connection\n   */\n  get destinationAssetScale (): number | undefined {\n    return this._destinationAssetScale\n  }\n\n  /**\n   * Code of the asset used by the remote party to this connection\n   */\n  get destinationAssetCode (): string | undefined {\n    return this._destinationAssetCode\n  }\n\n  /**\n   * ILP Address of the plugin passed to this connection.\n   */\n  get sourceAccount (): string {\n    return this._sourceAccount\n  }\n\n  /**\n   * Scale of the asset used by the plugin passed to this connection\n   */\n  get sourceAssetScale (): number {\n    return this._sourceAssetScale\n  }\n\n  /**\n   * Code of the asset used by the plugin passed to this connection\n   */\n  get sourceAssetCode (): string {\n    return this._sourceAssetCode\n  }\n\n  /**\n   * Connections minimum exchange rate with slippage included, if not set '0' is returned.\n   */\n  get minimumAcceptableExchangeRate (): string {\n    if (this.exchangeRate) {\n      const minimumExchangeWithSlippage = this.exchangeRate\n         .times(new BigNumber(1).minus(this.slippage))\n      return minimumExchangeWithSlippage.toString()\n    }\n    return '0'\n  }\n\n /**\n  * Calculates the last exchange rate based on last packet successfully sent.\n  */\n  get lastPacketExchangeRate (): string {\n    return this._lastPacketExchangeRate.toString()\n  }\n\n  /**\n   * Total delivered so far, denominated in the connection plugin's units.\n   */\n  get totalDelivered (): string {\n    return this._totalDelivered.toString()\n  }\n\n  /**\n   * Total sent so far, denominated in the connection plugin's units.\n   */\n  get totalSent (): string {\n    return this._totalSent.toString()\n  }\n\n  /**\n   * Total received so far by the local side, denominated in the connection plugin's units.\n   */\n  get totalReceived (): string {\n    return this._totalReceived.toString()\n  }\n\n  /**\n   * (Internal) Handle incoming ILP Prepare packets.\n   * This will automatically fulfill all valid and expected Prepare packets.\n   * It passes the incoming money and/or data to the relevant streams.\n   * @private\n   */\n  async handlePrepare (prepare: IlpPacket.IlpPrepare): Promise<IlpPacket.IlpFulfill> {\n    // Parse packet\n    let requestPacket: Packet\n    try {\n      requestPacket = Packet.decryptAndDeserialize(this.sharedSecret, prepare.data)\n    } catch (err) {\n      this.log.error(`error parsing frames:`, err)\n      throw new IlpPacket.Errors.UnexpectedPaymentError('')\n    }\n    this.log.trace('handling packet:', JSON.stringify(requestPacket))\n\n    if (requestPacket.ilpPacketType.valueOf() !== IlpPacket.Type.TYPE_ILP_PREPARE) {\n      this.log.error(`prepare packet contains a frame that says it should be something other than a prepare: ${requestPacket.ilpPacketType}`)\n      throw new IlpPacket.Errors.UnexpectedPaymentError('')\n    }\n    this.bumpIdle()\n\n    let responseFrames: Frame[] = []\n\n    // Tell peer how much data connection can receive\n    responseFrames.push(new ConnectionMaxDataFrame(this.getIncomingOffsets().maxAcceptable))\n\n    const throwFinalApplicationError = () => {\n      responseFrames = responseFrames.concat(this.queuedFrames)\n      this.queuedFrames = []\n      const responsePacket = new Packet(requestPacket.sequence, IlpPacketType.Reject, prepare.amount, responseFrames)\n      this.log.trace(`rejecting packet ${requestPacket.sequence}: ${JSON.stringify(responsePacket)}`)\n      throw new IlpPacket.Errors.FinalApplicationError('', responsePacket.serializeAndEncrypt(this.sharedSecret, (this.enablePadding ? MAX_DATA_SIZE : undefined)))\n    }\n\n    // Handle new streams\n    for (let frame of requestPacket.frames) {\n      if (frame.type === FrameType.StreamMoney\n        || frame.type === FrameType.StreamData\n        // TODO should frames that set the max values open the stream?\n        || frame.type === FrameType.StreamMaxMoney\n        || frame.type === FrameType.StreamMaxData) {\n        const streamId = frame.streamId.toNumber()\n\n        // Check if the stream was already closed\n        if (this.closedStreams[streamId]) {\n          this.log.trace(`got packet with frame for stream ${streamId}, which was already closed`)\n\n          // Don't bother sending an error frame back unless they've actually sent money or data\n          if (frame.type !== FrameType.StreamMoney && frame.type !== FrameType.StreamData) {\n            continue\n          }\n\n          // Respond with a StreamClose frame (unless there is already one queued)\n          const framesToSend = responseFrames.concat(this.queuedFrames)\n          const includesStreamClose = framesToSend.find((frame) => frame.type === FrameType.StreamClose && frame.streamId.isEqualTo(streamId))\n          if (!includesStreamClose) {\n            responseFrames.push(new StreamCloseFrame(streamId, ErrorCode.StreamStateError, 'Stream is already closed'))\n          }\n          throwFinalApplicationError()\n        }\n\n        try {\n          // Note this will throw if the stream was already closed\n          this.handleNewStream(frame.streamId.toNumber())\n        } catch (err) {\n          this.log.debug(`error handling new stream ${frame.streamId}:`, err && err.message)\n          throwFinalApplicationError()\n        }\n      }\n    }\n\n    // TODO don't throw errors in expected cases -- they are slower than just returning a value\n    try {\n      this.handleControlFrames(requestPacket.frames)\n    } catch (err) {\n      this.log.debug('error handling frames:', err && err.message)\n      throwFinalApplicationError()\n    }\n\n    // TODO keep a running total of the offsets so we don't need to recalculate each time\n    const incomingOffsets = this.getIncomingOffsets()\n    if (incomingOffsets.max > incomingOffsets.maxAcceptable) {\n      /* tslint:disable-next-line:no-floating-promises */\n      this.destroy(new ConnectionError(`Exceeded flow control limits. Max connection byte offset: ${incomingOffsets.maxAcceptable}, received: ${incomingOffsets.max}`, ErrorCode.FlowControlError))\n      throwFinalApplicationError()\n    }\n\n    if (requestPacket.prepareAmount.isGreaterThan(prepare.amount)) {\n      this.log.debug(`received less than minimum destination amount. actual: ${prepare.amount}, expected: ${requestPacket.prepareAmount}`)\n      throwFinalApplicationError()\n    }\n\n    // Ensure we can generate correct fulfillment\n    const fulfillment = cryptoHelper.generateFulfillment(this.sharedSecret, prepare.data)\n    const generatedCondition = cryptoHelper.hash(fulfillment)\n    if (!generatedCondition.equals(prepare.executionCondition)) {\n      this.log.debug(`got unfulfillable prepare for amount: ${prepare.amount}. generated condition: ${generatedCondition.toString('hex')}, prepare condition: ${prepare.executionCondition.toString('hex')}`)\n      throwFinalApplicationError()\n    }\n\n    // Determine amount to receive on each frame\n    const amountsToReceive: { stream: DataAndMoneyStream, amount: BigNumber }[] = []\n    const totalMoneyShares = requestPacket.frames.reduce((sum: BigNumber, frame: Frame) => {\n      if (frame instanceof StreamMoneyFrame) {\n        return sum.plus(frame.shares)\n      }\n      return sum\n    }, new BigNumber(0))\n    for (let frame of requestPacket.frames) {\n      if (!(frame instanceof StreamMoneyFrame)) {\n        continue\n      }\n      const streamId = frame.streamId.toNumber()\n      const streamAmount = new BigNumber(prepare.amount)\n        .times(frame.shares)\n        .dividedBy(totalMoneyShares)\n        // TODO make sure we don't lose any because of rounding issues\n        .integerValue(BigNumber.ROUND_FLOOR)\n      const stream = this.streams.get(streamId)!\n      amountsToReceive.push({\n        stream,\n        amount: streamAmount\n      })\n\n      // Ensure that this amount isn't more than the stream can receive\n      const maxStreamCanReceive = stream._getAmountStreamCanReceive()\n        .times(this.allowableReceiveExtra)\n        .integerValue(BigNumber.ROUND_CEIL)\n      if (maxStreamCanReceive.isLessThan(streamAmount)) {\n        // TODO should this be distributed to other streams if it can be?\n        this.log.debug(`peer sent too much for stream: ${streamId}. got: ${streamAmount}, max receivable: ${maxStreamCanReceive}`)\n        // Tell peer how much the streams they sent for can receive\n        responseFrames.push(new StreamMaxMoneyFrame(streamId, stream.receiveMax, stream.totalReceived))\n\n        // TODO include error frame\n        throwFinalApplicationError()\n      }\n\n      // Reject the packet if any of the streams is already closed\n      if (!stream.isOpen()) {\n        this.log.debug(`peer sent money for stream that was already closed: ${streamId}`)\n        responseFrames.push(new StreamCloseFrame(streamId, ErrorCode.StreamStateError, 'Stream is already closed'))\n\n        throwFinalApplicationError()\n      }\n    }\n\n    // Add incoming amounts to each stream\n    for (let { stream, amount } of amountsToReceive) {\n      stream._addToIncoming(amount)\n    }\n\n    // Tell peer about closed streams and how much each stream can receive\n    if (!this.closed && !this.remoteClosed) {\n      for (let [_, stream] of this.streams) {\n        if (!stream.isOpen() && !stream._remoteClosed) {\n          this.log.trace(`telling other side that stream ${stream.id} is closed`)\n          if (stream._errorMessage) {\n            responseFrames.push(new StreamCloseFrame(stream.id, ErrorCode.ApplicationError, stream._errorMessage))\n          } else {\n            responseFrames.push(new StreamCloseFrame(stream.id, ErrorCode.NoError, ''))\n          }\n          // TODO confirm that they get this\n          stream._remoteClosed = true\n        } else {\n          this.log.trace(`telling other side that stream ${stream.id} can receive ${stream.receiveMax}`)\n          responseFrames.push(new StreamMaxMoneyFrame(stream.id, stream.receiveMax, stream.totalReceived))\n\n          // TODO only send these frames when we need to\n          responseFrames.push(new StreamMaxDataFrame(stream.id, stream._getIncomingOffsets().maxAcceptable))\n        }\n      }\n    }\n\n    // TODO make sure the queued frames aren't too big\n    responseFrames = responseFrames.concat(this.queuedFrames)\n    this.queuedFrames = []\n\n    // Return fulfillment and response packet\n    const responsePacket = new Packet(requestPacket.sequence, IlpPacketType.Fulfill, prepare.amount, responseFrames)\n    this._totalReceived = this._totalReceived.plus(prepare.amount)\n    this.log.trace(`fulfilling prepare with fulfillment: ${fulfillment.toString('hex')} and response packet: ${JSON.stringify(responsePacket)}`)\n    return {\n      fulfillment,\n      data: responsePacket.serializeAndEncrypt(this.sharedSecret, (this.enablePadding ? MAX_DATA_SIZE : undefined))\n    }\n  }\n\n  /**\n   * Parse the frames from the incoming packet and apply all effects\n   * except for passing money to the streams\n   */\n  protected handleControlFrames (frames: Frame[]): void {\n    for (let frame of frames) {\n      let stream\n      switch (frame.type) {\n        case FrameType.ConnectionNewAddress:\n          this.log.trace(`peer notified us of their account: ${frame.sourceAccount}`)\n          const firstConnection = this._destinationAccount === undefined\n          this._destinationAccount = frame.sourceAccount\n          if (firstConnection) {\n            this.handleConnect()\n          }\n          // TODO reset the exchange rate and send a test packet to make sure they haven't spoofed the address\n          break\n        case FrameType.ConnectionAssetDetails:\n          this.log.trace(`peer notified us of their asset details: code=${frame.sourceAssetCode}, scale=${frame.sourceAssetScale}`)\n          this._destinationAssetCode = frame.sourceAssetCode\n          this._destinationAssetScale = frame.sourceAssetScale\n          break\n        case FrameType.ConnectionClose:\n          // TODO end the connection in some other way\n          this.sending = false\n          this.closed = true\n          this.remoteClosed = true\n          if (frame.errorCode === ErrorCode.NoError) {\n            this.log.info(`remote closed connection`)\n            /* tslint:disable-next-line:no-floating-promises */\n            this.end()\n          } else {\n            this.log.error(`remote connection error. code: ${ErrorCode[frame.errorCode]}, message: ${frame.errorMessage}`)\n            /* tslint:disable-next-line:no-floating-promises */\n            this.destroy(new Error(`Remote connection error. Code: ${ErrorCode[frame.errorCode]}, message: ${frame.errorMessage}`))\n          }\n          break\n        case FrameType.ConnectionMaxData:\n          const outgoingOffsets = this.getOutgoingOffsets()\n          this.log.trace(`remote connection max byte offset is: ${frame.maxOffset}, we've sent: ${outgoingOffsets.currentOffset}, we want to send up to: ${outgoingOffsets.maxOffset}`)\n          if (frame.maxOffset.isGreaterThan(MAX_DATA_SIZE * 2)) {\n            this.remoteMaxOffset = Math.max(frame.maxOffset.toNumber(), this.remoteMaxOffset)\n          } else {\n            // We assumed their size was 64kb but it turned out to be less\n            this.remoteMaxOffset = frame.maxOffset.toNumber()\n          }\n          break\n        case FrameType.ConnectionDataBlocked:\n          this.log.trace(`remote wants to send more data but we are blocking them. current max incoming offset: ${this.getIncomingOffsets()}, remote max offset: ${frame.maxOffset}`)\n          break\n        case FrameType.ConnectionMaxStreamId:\n          // TODO make sure the number isn't lowered\n          this.log.trace(`remote set max stream id to ${frame.maxStreamId}`)\n          this.remoteMaxStreamId = frame.maxStreamId.toNumber()\n          break\n        case FrameType.ConnectionStreamIdBlocked:\n          this.log.trace(`remote wants to open more streams but we are blocking them`)\n          break\n        case FrameType.StreamClose:\n          this.handleStreamClose(frame)\n          break\n        case FrameType.StreamMaxMoney:\n          this.log.trace(`peer told us that stream ${frame.streamId} can receive up to: ${frame.receiveMax} and has received: ${frame.totalReceived} so far`)\n          stream = this.streams.get(frame.streamId.toNumber())\n          if (!stream) {\n            break\n          }\n          stream._remoteReceived = BigNumber.maximum(stream._remoteReceived, frame.totalReceived)\n          if (stream._remoteReceiveMax.isFinite()) {\n            stream._remoteReceiveMax = BigNumber.maximum(stream._remoteReceiveMax, frame.receiveMax)\n          } else {\n            stream._remoteReceiveMax = frame.receiveMax\n          }\n          if (stream._remoteReceiveMax.isGreaterThan(stream._remoteReceived)\n            && stream._getAmountAvailableToSend().isGreaterThan(0)) {\n            /* tslint:disable-next-line:no-floating-promises */\n            this.startSendLoop()\n          }\n          break\n        case FrameType.StreamMoneyBlocked:\n          this.log.debug(`peer told us that they want to send more money on stream ${frame.streamId} but we are blocking them. they have sent: ${frame.totalSent} so far and want to send: ${frame.sendMax}`)\n          break\n        case FrameType.StreamData:\n          this.log.trace(`got data for stream ${frame.streamId}`)\n\n          stream = this.streams.get(frame.streamId.toNumber())\n          if (!stream) {\n            break\n          }\n          stream._pushIncomingData(frame.data, frame.offset.toNumber())\n\n          // Make sure the peer hasn't exceeded the flow control limits\n          const incomingOffsets = stream._getIncomingOffsets()\n          if (incomingOffsets.max > incomingOffsets.maxAcceptable) {\n            /* tslint:disable-next-line:no-floating-promises */\n            this.destroy(new ConnectionError(`Exceeded flow control limits. Stream ${stream.id} can accept up to offset: ${incomingOffsets.maxAcceptable} but got bytes up to offset: ${incomingOffsets.max}`, ErrorCode.FlowControlError))\n          }\n          break\n        case FrameType.StreamMaxData:\n          stream = this.streams.get(frame.streamId.toNumber())\n          if (!stream) {\n            break\n          }\n          const oldOffset = stream._remoteMaxOffset\n          const newOffset = frame.maxOffset.toNumber()\n          if (newOffset > oldOffset) {\n            this.log.trace(`peer told us that stream ${frame.streamId} can receive up to byte offset: ${frame.maxOffset} (we've sent up to offset: ${stream._getOutgoingOffsets().current})`)\n            stream._remoteMaxOffset = newOffset\n            /* tslint:disable-next-line:no-floating-promises */\n            this.startSendLoop()\n          } else {\n            this.log.trace(`peer told us that stream ${frame.streamId} can receive up to byte offset: ${oldOffset}; ignoring new offset: ${newOffset}`)\n          }\n          break\n        case FrameType.StreamDataBlocked:\n          stream = this.streams.get(frame.streamId.toNumber())\n          if (!stream) {\n            break\n          }\n          this.log.debug(`peer told us that stream ${frame.streamId} is blocked. they want to send up to offset: ${frame.maxOffset}, but we are only allowing up to: ${stream._getIncomingOffsets().maxAcceptable}`)\n          break\n        default:\n          continue\n      }\n    }\n  }\n\n  /**\n   * Handle the initial connection from the other side\n   */\n  protected handleConnect () {\n    this.closed = false\n    this.log.info('connected')\n    this.safeEmit('connect')\n\n    // Tell the other side our max stream id and asset details\n    this.queuedFrames.push(\n      new ConnectionMaxStreamIdFrame(this.maxStreamId),\n      new ConnectionAssetDetailsFrame(this.sourceAssetCode, this.sourceAssetScale)\n    )\n  }\n\n  /**\n   * Ensure that the new stream is valid and does not exceed our limits\n   * and if it looks good, emit the 'stream' event\n   */\n  protected handleNewStream (streamId: number): void {\n    if (this.streams.has(streamId) || this.closedStreams[streamId]) {\n      return\n    }\n\n    // Validate stream ID\n    if (this.isServer && streamId % 2 === 0) {\n      this.log.error(`got invalid stream ID ${streamId} from peer (should be odd)`)\n      this.queuedFrames.push(new ConnectionCloseFrame(ErrorCode.ProtocolViolation, `Invalid Stream ID: ${streamId}. Client-initiated streams must have odd-numbered IDs`))\n      // TODO this should probably call this.destroy\n      const err = new Error(`Invalid Stream ID: ${streamId}. Client-initiated streams must have odd-numbered IDs`)\n      this.safeEmit('error', err)\n      throw err\n    } else if (!this.isServer && streamId % 2 === 1) {\n      this.log.error(`got invalid stream ID ${streamId} from peer (should be even)`)\n      this.queuedFrames.push(new ConnectionCloseFrame(ErrorCode.ProtocolViolation, `Invalid Stream ID: ${streamId}. Server-initiated streams must have even-numbered IDs`))\n      const err = new Error(`Invalid Stream ID: ${streamId}. Server-initiated streams must have even-numbered IDs`)\n      this.safeEmit('error', err)\n      throw err\n    }\n\n    // Make sure there aren't too many open streams\n    if (streamId > this.maxStreamId) {\n      this.log.debug(`peer opened too many streams. got stream: ${streamId}, but max stream id is: ${this.maxStreamId}. closing connection`)\n      this.queuedFrames.push(new ConnectionCloseFrame(ErrorCode.StreamIdError, `Maximum number of open streams exceeded. Got stream: ${streamId}, current max stream ID: ${this.maxStreamId}`))\n      const err = new Error(`Maximum number of open streams exceeded. Got stream: ${streamId}, current max stream ID: ${this.maxStreamId}`)\n      this.safeEmit('error', err)\n      throw err\n    }\n\n    // Let the other side know if they're getting close to the number of streams\n    if (this.maxStreamId * .75 < streamId) {\n      this.log.trace(`informing peer that our max stream id is: ${this.maxStreamId}`)\n      this.queuedFrames.push(new ConnectionMaxStreamIdFrame(this.maxStreamId))\n    }\n\n    this.log.info(`got new stream: ${streamId}`)\n    const stream = new DataAndMoneyStream({\n      id: streamId,\n      isServer: this.isServer\n    })\n    this.streams.set(streamId, stream)\n\n    stream.on('_maybe_start_send_loop', () => this.startSendLoop())\n    stream.once('close', () => this.removeStreamRecord(stream))\n\n    this.safeEmit('stream', stream)\n  }\n\n  /**\n   * Mark the stream as closed\n   */\n  protected handleStreamClose (frame: StreamCloseFrame) {\n    const streamId = frame.streamId.toNumber()\n    const stream = this.streams.get(streamId)\n    if (!stream) {\n      this.log.error(`remote error on stream ${streamId}, but we don't have a record of that stream`)\n      return\n    }\n\n    if (!stream.isOpen() || stream._remoteSentEnd) {\n      return\n    }\n\n    this.log.error(`peer closed stream ${stream.id} with error code: ${ErrorCode[frame.errorCode]} and message: ${frame.errorMessage}`)\n    // TODO should we confirm with the other side that we closed it?\n    stream._sentEnd = true\n    let err\n    if (frame.errorMessage) {\n      err = new Error(frame.errorMessage)\n      err.name = ErrorCode[frame.errorCode]\n    }\n    stream._remoteEnded(err)\n\n    // TODO make sure we don't send more than one of these frames per packet\n    this.maxStreamId += 2\n    this.log.trace(`raising maxStreamId to ${this.maxStreamId}`)\n    this.queuedFrames.push(new ConnectionMaxStreamIdFrame(this.maxStreamId))\n    // Start send loop to make sure this frame is sent\n    /* tslint:disable-next-line:no-floating-promises */\n    this.startSendLoop()\n  }\n\n  /**\n   * (Internal) Start sending packets with money and/or data, as necessary.\n   * @private\n   */\n  protected async startSendLoop () {\n    if (this.sending) {\n      return\n    }\n    if (this.remoteClosed) {\n      this.log.debug('remote connection is already closed, not starting another loop')\n      this.safeEmit('_send_loop_finished')\n      return\n    }\n    if (!this._destinationAccount) {\n      this.log.debug('not sending because we do not know the client\\'s address')\n      return\n    }\n\n    this.sending = true\n    this.log.debug('starting send loop')\n\n    try {\n      while (this.sending) {\n        // Send a test packet first to determine the exchange rate\n        if (!this.exchangeRate) {\n          this.log.trace('determining exchange rate')\n          await this.determineExchangeRate()\n\n          if (this.exchangeRate) {\n            this.safeEmit('connect')\n            this.log.trace('connected')\n          } else {\n            this.log.error('unable to determine exchange rate')\n          }\n        } else {\n          // TODO Send multiple packets at the same time (don't await promise)\n          // TODO Figure out if we need to wait before sending the next one\n          await this.loadAndSendPacket()\n        }\n      }\n    } catch (err) {\n      // TODO should a connection error be an error on all of the streams?\n      return this.destroy(err)\n    }\n    this.log.debug('finished sending')\n    this.safeEmit('_send_loop_finished')\n    for (let [_, stream] of this.streams) {\n      stream.emit('_send_loop_finished')\n    }\n  }\n\n  /**\n   * Load up a packet money and/or data, send it to the other party, and handle the result.\n   * @private\n   */\n  protected async loadAndSendPacket (): Promise<void> {\n    // Actually send on the next tick of the event loop in case multiple streams\n    // have their limits raised at the same time\n    await new Promise((resolve, reject) => setImmediate(resolve))\n\n    this.log.trace('loadAndSendPacket')\n    let amountToSend = new BigNumber(0)\n\n    // Set packet number to correlate response with request\n    const requestPacket = new Packet(this.nextPacketSequence++, IlpPacketType.Prepare)\n\n    // TODO make sure these aren't too big\n    requestPacket.frames = this.queuedFrames\n    this.queuedFrames = []\n\n    // Send control frames\n    // TODO only send the max amount when it changes\n    for (let [_, stream] of this.streams) {\n      if (stream.isOpen()) {\n        requestPacket.frames.push(new StreamMaxMoneyFrame(stream.id, stream.receiveMax, stream.totalReceived))\n        requestPacket.frames.push(new StreamMaxDataFrame(stream.id, stream._getIncomingOffsets().maxAcceptable))\n      }\n    }\n    if (this.closed && !this.remoteClosed) {\n      // TODO how do we know if there was an error?\n      this.log.trace('sending connection close frame')\n      requestPacket.frames.push(new ConnectionCloseFrame(ErrorCode.NoError, ''))\n      // TODO don't put any more frames because the connection is closed\n      // TODO only mark this as closed once we confirm that with the receiver\n      this.remoteClosed = true\n    }\n\n    // Determine how much to send based on amount frames and path maximum packet amount\n    let maxAmountFromNextStream = this.testMaximumPacketAmount\n    const streamsSentFrom = []\n    for (let [_, stream] of this.streams) {\n      if (stream._sentEnd) {\n        // TODO just remove closed streams?\n        continue\n      }\n      // Determine how much to send from this stream based on how much it has available\n      // and how much the receiver side of this stream can receive\n      let amountToSendFromStream = BigNumber.minimum(stream._getAmountAvailableToSend(), maxAmountFromNextStream)\n      if (this.exchangeRate) {\n        const maxDestinationAmount = stream._remoteReceiveMax.minus(stream._remoteReceived)\n        const maxSourceAmount = maxDestinationAmount.dividedBy(this.exchangeRate).integerValue(BigNumber.ROUND_CEIL)\n        if (maxSourceAmount.isLessThan(amountToSendFromStream)) {\n          this.log.trace(`stream ${stream.id} could send ${amountToSendFromStream} but that would be more than the receiver says they can receive, so we'll send ${maxSourceAmount} instead`)\n          amountToSendFromStream = maxSourceAmount\n        }\n      }\n      this.log.trace(`amount to send from stream ${stream.id}: ${amountToSendFromStream}, exchange rate: ${this.exchangeRate}, remote total received: ${stream._remoteReceived}, remote receive max: ${stream._remoteReceiveMax}`)\n\n      // Hold the money and add a frame to the packet\n      if (amountToSendFromStream.isGreaterThan(0)) {\n        stream._holdOutgoing(requestPacket.sequence.toString(), amountToSendFromStream)\n        // TODO make sure the length of the frames doesn't exceed packet data limit\n        requestPacket.frames.push(new StreamMoneyFrame(stream.id, amountToSendFromStream))\n        amountToSend = amountToSend.plus(amountToSendFromStream)\n        maxAmountFromNextStream = maxAmountFromNextStream.minus(amountToSendFromStream)\n        streamsSentFrom.push(stream)\n      }\n\n      // Tell peer if they're blocking us from sending money\n      const amountLeftStreamWantsToSend = new BigNumber(stream.sendMax).minus(stream.totalSent).minus(amountToSendFromStream)\n      /* tslint:disable-next-line:no-unnecessary-type-assertion */\n      if (amountLeftStreamWantsToSend.times(this.exchangeRate!).isGreaterThan(stream._remoteReceiveMax.minus(stream._remoteReceived))) {\n        requestPacket.frames.push(new StreamMoneyBlockedFrame(stream.id, stream.sendMax, stream.totalSent))\n      }\n\n      if (maxAmountFromNextStream.isEqualTo(0)) {\n        // TODO make sure that we start with those later frames the next time around\n        break\n      }\n    }\n\n    let bytesLeftInPacket = MAX_DATA_SIZE - requestPacket.byteLength()\n\n    // Respect connection-level flow control\n    const maxBytesRemoteConnectionCanReceive = this.remoteMaxOffset - this.getOutgoingOffsets().currentOffset\n    if (bytesLeftInPacket > maxBytesRemoteConnectionCanReceive) {\n      const outgoingMaxOffset = this.getOutgoingOffsets().maxOffset\n      this.log.debug(`peer is blocking us from sending more data. they will only accept up to offset: ${this.remoteMaxOffset}, but we want to send up to: ${outgoingMaxOffset}`)\n      requestPacket.frames.push(new ConnectionDataBlockedFrame(outgoingMaxOffset))\n      bytesLeftInPacket = maxBytesRemoteConnectionCanReceive\n    }\n\n    for (let [_, stream] of this.streams) {\n      // TODO use a sensible estimate for the StreamDataFrame overhead\n      if (bytesLeftInPacket - 20 <= 0) {\n        // Never pass a negative offset to _getAmountAvailableToSend.\n        break\n      }\n      const { data, offset } = stream._getAvailableDataToSend(bytesLeftInPacket - 20)\n      if (data && data.length > 0) {\n        const streamDataFrame = new StreamDataFrame(stream.id, offset, data)\n        this.log.trace(`sending ${data.length} bytes from stream ${stream.id}`)\n        bytesLeftInPacket -= streamDataFrame.byteLength()\n        requestPacket.frames.push(streamDataFrame)\n      }\n\n      // Inform remote which streams are blocked\n      const maxOutgoingOffset = stream._isDataBlocked()\n      if (maxOutgoingOffset) {\n        this.log.trace(`telling remote that stream ${stream.id} is blocked and has more data to send`)\n        requestPacket.frames.push(new StreamDataBlockedFrame(stream.id, maxOutgoingOffset))\n      }\n    }\n\n    // Check if we can stop sending\n    if (amountToSend.isEqualTo(0)) {\n      if (requestPacket.frames.length === 0) {\n        this.sending = false\n        return\n      } else {\n        // Check if any Close, Data, or Money Frames are present in the packet.\n        // If any of those are do not sent sending to false so the send loop\n        // has an opportunity to retry if those packets are rejected.\n        if (!requestPacket.frames.find(frame =>\n            ((frame.type === FrameType.StreamClose)\n            || (frame.type === FrameType.StreamData)\n            || (frame.type === FrameType.StreamMoney)))) {\n          this.sending = false\n        }\n      }\n    }\n\n    // Set minimum destination amount\n    if (this.exchangeRate) {\n      const minimumDestinationAmount = amountToSend.times(this.exchangeRate)\n        .times(new BigNumber(1).minus(this.slippage))\n        .integerValue(BigNumber.ROUND_FLOOR)\n      if (minimumDestinationAmount.isGreaterThan(0)) {\n        requestPacket.prepareAmount = minimumDestinationAmount\n      }\n    }\n\n    const responsePacket = await this.sendPacket(requestPacket, amountToSend, false)\n\n    if (responsePacket) {\n      this.handleControlFrames(responsePacket.frames)\n\n      // Track the exchange rate for the last packet (whether it was fulfilled or rejected)\n      if (amountToSend.isGreaterThan(0)) {\n        this._lastPacketExchangeRate = responsePacket.prepareAmount.dividedBy(amountToSend)\n      }\n\n      if (responsePacket.ilpPacketType === IlpPacketType.Fulfill) {\n        for (let stream of streamsSentFrom) {\n          stream._executeHold(requestPacket.sequence.toString())\n        }\n\n        // Update stats based on amount sent\n        this._totalDelivered = this._totalDelivered.plus(responsePacket.prepareAmount)\n        this._totalSent = this._totalSent.plus(amountToSend)\n\n        // If we're trying to pinpoint the Maximum Packet Amount, raise\n        // the limit because we know that the testMaximumPacketAmount works\n        if (amountToSend.isEqualTo(this.testMaximumPacketAmount)\n            && this.testMaximumPacketAmount.isLessThan(this.maximumPacketAmount)) {\n          let newTestMax\n          if (this.maximumPacketAmount.isFinite()) {\n            // Take the max packet amount / 10 and then add it to the last test packet amount for an additive increase\n            const additiveIncrease = this.maximumPacketAmount.dividedToIntegerBy(10)\n            newTestMax = BigNumber.min(this.testMaximumPacketAmount.plus(additiveIncrease), this.maximumPacketAmount)\n            this.log.trace(`last packet amount was successful (max packet amount: ${this.maximumPacketAmount}), raising packet amount from ${this.testMaximumPacketAmount} to: ${newTestMax}`)\n          } else {\n            // Increase by 2 times in this case since we do not know the max packet amount\n            newTestMax = this.testMaximumPacketAmount.times(2)\n            this.log.trace(`last packet amount was successful, unknown max packet amount, raising packet amount from: ${this.testMaximumPacketAmount} to: ${newTestMax}`)\n          }\n          this.testMaximumPacketAmount = newTestMax\n        }\n\n        // Reset the retry delay\n        this.retryDelay = RETRY_DELAY_START\n      }\n    }\n  }\n  /**\n   * (Internal) Send volly of test packests to find the exchange rate, its precision, and potential other amounts to try.\n   * @private\n   */\n  protected async sendTestPacketVolley (testPacketAmounts: number[]): Promise<any> {\n    const results = await Promise.all(testPacketAmounts.map(async (amount) => {\n      try {\n        return this.sendTestPacket(new BigNumber(amount))\n      } catch (err) {\n        this.log.error(`Error sending test packet for amount ${amount}:`, err)\n        return null\n      }\n    }))\n\n    // parse F08 packets and get the max packet amounts from them\n    const maxPacketAmounts = testPacketAmounts.map((sourceAmount, index) => {\n      if (results[index] && (results[index] as IlpPacket.IlpReject).code === 'F08') {\n        try {\n          const reader = Reader.from((results[index] as IlpPacket.IlpReject).data)\n          const receivedAmount = reader.readUInt64BigNum()\n          const maximumAmount = reader.readUInt64BigNum()\n          const maximumPacketAmount = new BigNumber(sourceAmount)\n            .times(maximumAmount)\n            .dividedToIntegerBy(receivedAmount)\n          this.log.debug(`sending test packet of ${testPacketAmounts[index]} resulted in F08 error that told us maximum packet amount is ${maximumPacketAmount}`)\n          return maximumPacketAmount\n        } catch (err) {\n          return new BigNumber(Infinity)\n        }\n      }\n      return new BigNumber(Infinity)\n    })\n\n    // Figure out which test packet discovered the exchange rate with the most precision and gather packet error codes\n    const { maxDigits, exchangeRate, packetErrors } = results.reduce<any>(({ maxDigits, exchangeRate, packetErrors }, result, index) => {\n      if (result && (result as IlpPacket.IlpReject).code) {\n        packetErrors.push((result as IlpPacket.IlpReject).code)\n      }\n      if (result && (result as Packet).prepareAmount) {\n        const prepareAmount = (result as Packet).prepareAmount\n        const exchangeRate = prepareAmount.dividedBy(testPacketAmounts[index])\n        this.log.debug(`sending test packet of ${testPacketAmounts[index]} delivered ${prepareAmount} (exchange rate: ${exchangeRate})`)\n        if (prepareAmount.precision(true) >= maxDigits) {\n          return {\n            maxDigits: prepareAmount.precision(true),\n            exchangeRate,\n            packetErrors\n          }\n        }\n      }\n      return { maxDigits, exchangeRate, packetErrors }\n    }, { maxDigits: 0, exchangeRate: new BigNumber(0), packetErrors: [] })\n    return { maxDigits, exchangeRate, maxPacketAmounts, packetErrors }\n  }\n\n  /**\n   * (Internal) Probe using test packets to find the exchange rate.\n   * @private\n   */\n  protected async determineExchangeRate (): Promise<void> {\n    this.log.trace('determineExchangeRate')\n    if (!this._destinationAccount) {\n      throw new Error('Cannot determine exchange rate. Destination account is unknown')\n    }\n\n    let retryDelay = RETRY_DELAY_START\n    let testPacketAmounts = [1, 1000, 1000000, 1000000000, 1000000000000] // 1, 10^3, 10^6, 10^9, 10^12\n    let attempts = 0\n\n    // set a max attempts in case F08 & TXX errors keep occurring\n    while (!this.exchangeRate && testPacketAmounts.length > 0 && attempts < TEST_PACKET_MAX_ATTEMPTS) {\n      attempts++\n      const { maxDigits, exchangeRate, maxPacketAmounts, packetErrors } = await this.sendTestPacketVolley(testPacketAmounts)\n\n      this.maximumPacketAmount = BigNumber.minimum(...maxPacketAmounts.concat(this.maximumPacketAmount))\n      this.testMaximumPacketAmount = this.maximumPacketAmount\n      if (this.maximumPacketAmount.isEqualTo(0)) {\n        this.log.error(`cannot send anything through this path. the maximum packet amount is 0`)\n        throw new Error('Cannot send. Path has a Maximum Packet Amount of 0')\n      }\n\n      if (maxDigits >= this.minExchangeRatePrecision) {\n        this.log.debug(`determined exchange rate to be ${exchangeRate} with ${maxDigits} digits precision`)\n        this.exchangeRate = exchangeRate\n        return\n      }\n\n      // Find the smallest packet amount we tried in case we ran into Txx errors\n      const smallestPacketAmount = testPacketAmounts.reduce((min: any, amount: any) => BigNumber.min(min, new BigNumber(amount)), new BigNumber(Infinity))\n      // If we get here the first volley failed, try new volley using all unique packet amounts based on the max packets\n      testPacketAmounts = maxPacketAmounts\n        .filter((amount: any) => !amount.isEqualTo(new BigNumber(Infinity)))\n        .reduce((acc: any, curr: any) => [...new Set([...acc, curr.toString()])], [])\n\n      // Check for any Txx Errors\n      if (packetErrors.some((code: string) => code[0] === 'T')) {\n        const reducedPacketAmount = smallestPacketAmount.minus(smallestPacketAmount.dividedToIntegerBy(3))\n        this.log.debug(`got Txx error(s), waiting ${retryDelay}ms and reducing packet amount to ${reducedPacketAmount} before sending another test packet`)\n        testPacketAmounts = [...testPacketAmounts, reducedPacketAmount]\n        await new Promise((resolve, reject) => setTimeout(resolve, retryDelay))\n        retryDelay *= RETRY_DELAY_INCREASE_FACTOR\n      }\n\n      this.log.debug(`retry with packet amounts ${testPacketAmounts}`)\n    }\n\n    throw new Error(`Unable to establish connection, no packets meeting the minimum exchange precision of ${this.minExchangeRatePrecision} digits made it through the path.`)\n  }\n\n  /**\n   * (Internal) Send an unfulfillable test packet. Primarily used for determining the path exchange rate.\n   * @private\n   */\n  protected async sendTestPacket (amount: BigNumber, timeout = DEFAULT_PACKET_TIMEOUT): Promise<Packet | IlpPacket.IlpReject | null> {\n    // Set packet number to correlate response with request\n    const requestPacket = new Packet(this.nextPacketSequence++, IlpPacketType.Prepare)\n\n    this.log.trace(`sending test packet ${requestPacket.sequence} for amount: ${amount}. timeout: ${timeout}`)\n\n    if (!this.remoteKnowsOurAccount) {\n      // TODO attach a token to the account?\n      requestPacket.frames.push(new ConnectionNewAddressFrame(this._sourceAccount))\n      requestPacket.frames.push(new ConnectionAssetDetailsFrame(this._sourceAssetCode, this._sourceAssetScale))\n    }\n\n    const prepare = {\n      destination: this._destinationAccount!,\n      amount: amount.toString(),\n      data: requestPacket.serializeAndEncrypt(this.sharedSecret),\n      executionCondition: cryptoHelper.generateRandomCondition(),\n      expiresAt: new Date(Date.now() + timeout)\n    }\n\n    /* tslint:disable-next-line:no-unnecessary-type-assertion */\n    const responseData = await (new Promise(async (resolve, reject) => {\n      const timer = setTimeout(() => {\n        this.log.error(`test packet ${requestPacket.sequence} timed out before we got a response`)\n        resolve(null)\n      }, timeout)\n      const result = await this.plugin.sendData(IlpPacket.serializeIlpPrepare(prepare))\n      clearTimeout(timer)\n      resolve(result)\n    }) as Promise<Buffer | null>)\n\n    if (!responseData) {\n      return null\n    }\n    this.bumpIdle()\n\n    const ilpReject = IlpPacket.deserializeIlpReject(responseData)\n\n    // Return the receiver's response if there was one\n    let responsePacket\n    if (ilpReject.code === 'F99' && ilpReject.data.length > 0) {\n      responsePacket = Packet.decryptAndDeserialize(this.sharedSecret, ilpReject.data)\n\n      // Ensure the response corresponds to the request\n      if (!responsePacket.sequence.isEqualTo(requestPacket.sequence)) {\n        this.log.error(`response packet sequence does not match the request packet. expected sequence: ${requestPacket.sequence}, got response packet:`, JSON.stringify(responsePacket))\n        throw new Error(`Response packet sequence does not correspond to the request. Actual: ${responsePacket.sequence}, expected: ${requestPacket.sequence}`)\n      }\n      if (responsePacket.ilpPacketType !== responseData[0]) {\n        this.log.error(`response packet was on wrong ILP packet type. expected ILP packet type: ${responseData[0]}, got:`, JSON.stringify(responsePacket))\n        throw new Error(`Response says it should be on an ILP packet of type: ${responsePacket.ilpPacketType} but it was carried on an ILP packet of type: ${responseData[0]}`)\n      }\n    } else {\n      this.log.debug(`test packet ${requestPacket.sequence} was rejected with a ${ilpReject.code} triggered by ${ilpReject.triggeredBy} error${ilpReject.message ? ' with the message: \"' + ilpReject.message + '\"' : ''}`)\n    }\n\n    if (responsePacket) {\n      this.remoteKnowsOurAccount = true\n      this.handleControlFrames(responsePacket.frames)\n      return responsePacket\n    } else {\n      return ilpReject\n    }\n  }\n\n  /**\n   * Send a ConnectionClose frame to the other side\n   */\n  protected async sendConnectionClose (err?: ConnectionError | Error): Promise<void> {\n    if (this.remoteClosed) {\n      this.log.debug('not sending connection error because remote is already closed')\n      return\n    }\n\n    let errorCode: ErrorCode\n    let errorMessage\n    if (err && err instanceof ConnectionError) {\n      errorCode = err.streamErrorCode\n      errorMessage = err.message\n    } else if (err) {\n      errorCode = ErrorCode.InternalError\n      errorMessage = err.message\n    } else {\n      errorCode = ErrorCode.NoError\n      errorMessage = ''\n    }\n\n    const packet = new Packet(this.nextPacketSequence, IlpPacketType.Prepare, 0, [\n      new ConnectionCloseFrame(errorCode, errorMessage)\n    ])\n\n    try {\n      const prepare = {\n        destination: this._destinationAccount!,\n        amount: '0',\n        data: packet.serializeAndEncrypt(this.sharedSecret),\n        executionCondition: cryptoHelper.generateRandomCondition(),\n        expiresAt: new Date(Date.now() + DEFAULT_PACKET_TIMEOUT)\n      }\n      await this.plugin.sendData(IlpPacket.serializeIlpPrepare(prepare))\n    } catch (err) {\n      this.log.error(`error while trying to inform peer that connection is closing, but closing anyway`, err)\n    }\n    this.remoteClosed = true\n  }\n\n  /**\n   * Helper function used to send all ILP Prepare packets.\n   * This automatically generates the condition and sets the packet expiry.\n   * It also ensures that responses are valid and match the outgoing request.\n   */\n  protected async sendPacket (packet: Packet, sourceAmount: BigNumber, unfulfillable = false): Promise<Packet | void> {\n    this.log.trace(`sending packet ${packet.sequence} with source amount: ${sourceAmount}: ${JSON.stringify(packet)})`)\n    const data = packet.serializeAndEncrypt(this.sharedSecret, (this.enablePadding ? MAX_DATA_SIZE : undefined))\n\n    let fulfillment: Buffer | undefined\n    let executionCondition: Buffer\n    if (unfulfillable) {\n      fulfillment = undefined\n      executionCondition = cryptoHelper.generateRandomCondition()\n    } else {\n      fulfillment = cryptoHelper.generateFulfillment(this.sharedSecret, data)\n      executionCondition = cryptoHelper.hash(fulfillment)\n    }\n    const prepare = {\n      destination: this._destinationAccount!,\n      amount: (sourceAmount).toString(),\n      data,\n      executionCondition,\n      expiresAt: new Date(Date.now() + DEFAULT_PACKET_TIMEOUT)\n    }\n\n    const responseData = await this.plugin.sendData(IlpPacket.serializeIlpPrepare(prepare))\n    this.bumpIdle()\n\n    let response: IlpPacket.IlpFulfill | IlpPacket.IlpReject\n    try {\n      if (responseData[0] === IlpPacket.Type.TYPE_ILP_FULFILL) {\n        response = IlpPacket.deserializeIlpFulfill(responseData)\n      } else if (responseData[0] === IlpPacket.Type.TYPE_ILP_REJECT) {\n        response = IlpPacket.deserializeIlpReject(responseData)\n      } else {\n        throw new Error(`Invalid response packet type: ${responseData[0]}`)\n      }\n    } catch (err) {\n      this.log.error(`got invalid response from sending packet ${packet.sequence}:`, err, responseData.toString('hex'))\n      throw new Error(`Invalid response when sending packet ${packet.sequence}: ${err.message}`)\n    }\n\n    // Handle fulfillment\n    if (fulfillment && isFulfill(response)) {\n      if (!cryptoHelper.hash(response.fulfillment).equals(executionCondition)) {\n        this.log.error(`got invalid fulfillment for packet ${packet.sequence}: ${response.fulfillment.toString('hex')}. expected: ${fulfillment.toString('hex')} for condition: ${executionCondition.toString('hex')}`)\n        throw new Error(`Got invalid fulfillment for packet ${packet.sequence}. Actual: ${response.fulfillment.toString('hex')}, expected: ${fulfillment.toString('hex')}`)\n      }\n    } else {\n      response = response as IlpPacket.IlpReject\n\n      this.undoRejectedPacket(packet)\n\n      if (response.code !== 'F99') {\n        return this.handleConnectorError(response, sourceAmount)\n      }\n    }\n\n    // TODO correctly handle fulfills that come back without data attached (this will be treated like a reject)\n    if (response.data.length === 0) {\n      return undefined\n    }\n\n    // Parse response data from receiver\n    let responsePacket: Packet\n    try {\n      responsePacket = Packet.decryptAndDeserialize(this.sharedSecret, response.data)\n    } catch (err) {\n      this.log.error(`unable to decrypt and parse response data:`, err, response.data.toString('hex'))\n      // TODO should we continue processing anyway? what if it was fulfilled?\n      throw new Error('Unable to decrypt and parse response data: ' + err.message)\n    }\n\n    // Ensure the response corresponds to the request\n    if (!responsePacket.sequence.isEqualTo(packet.sequence)) {\n      this.log.error(`response packet sequence does not match the request packet. expected sequence: ${packet.sequence}, got response packet:`, JSON.stringify(responsePacket))\n      throw new Error(`Response packet sequence does not correspond to the request. Actual: ${responsePacket.sequence}, expected: ${packet.sequence}`)\n    }\n    if (responsePacket.ilpPacketType !== responseData[0]) {\n      this.log.error(`response packet was on wrong ILP packet type. expected ILP packet type: ${responseData[0]}, got:`, JSON.stringify(responsePacket))\n      throw new Error(`Response says it should be on an ILP packet of type: ${responsePacket.ilpPacketType} but it was carried on an ILP packet of type: ${responseData[0]}`)\n    }\n\n    this.log.debug(`got response to packet: ${packet.sequence}: ${JSON.stringify(responsePacket)}`)\n\n    return responsePacket\n  }\n\n  /**\n   * Roll back the effects of an outgoing packet that was rejected\n   * @private\n   */\n  protected undoRejectedPacket (requestPacket: Packet) {\n    this.log.debug(`packet ${requestPacket.sequence} was rejected`)\n\n    // TODO resend control frames\n    for (let frame of requestPacket.frames) {\n      switch (frame.type) {\n        case FrameType.StreamMoney:\n          this.streams.get(frame.streamId.toNumber())!._cancelHold(requestPacket.sequence.toString())\n          break\n        case FrameType.StreamData:\n          this.streams.get(frame.streamId.toNumber())!._resendOutgoingData(frame.data, frame.offset.toNumber())\n          break\n        case FrameType.StreamClose:\n          this.queuedFrames.push(frame)\n          break\n        default:\n          continue\n      }\n    }\n  }\n\n  /**\n   * (Internal) Handle final and temporary errors that were not generated by the receiver.\n   * @private\n   */\n  protected async handleConnectorError (reject: IlpPacket.IlpReject, amountSent: BigNumber) {\n    this.log.debug(`handling reject triggered by: ${reject.triggeredBy} error: ${reject.code} message: ${reject.message} data: ${reject.data}`)\n    if (reject.code === 'F08') {\n      let receivedAmount\n      let maximumAmount\n      try {\n        const reader = Reader.from(reject.data)\n        receivedAmount = reader.readUInt64BigNum()\n        maximumAmount = reader.readUInt64BigNum()\n      } catch (err) {\n        receivedAmount = undefined\n        maximumAmount = undefined\n      }\n      if (receivedAmount && maximumAmount && receivedAmount.isGreaterThan(maximumAmount)) {\n        const newMaximum = amountSent\n          .times(maximumAmount)\n          .dividedToIntegerBy(receivedAmount)\n        this.log.trace(`reducing maximum packet amount from ${this.maximumPacketAmount} to ${newMaximum}`)\n        this.maximumPacketAmount = newMaximum\n        this.testMaximumPacketAmount = newMaximum\n      } else {\n        // Connector didn't include amounts\n        this.maximumPacketAmount = amountSent.minus(1)\n        this.testMaximumPacketAmount = this.maximumPacketAmount.dividedToIntegerBy(2)\n      }\n      if (this.maximumPacketAmount.isEqualTo(0)) {\n        this.log.error(`cannot send anything through this path. the maximum packet amount is 0`)\n        throw new Error('Cannot send. Path has a Maximum Packet Amount of 0')\n      }\n    } else if (reject.code[0] === 'T') {\n      if (reject.code === 'T04') {\n        // TODO add more sophisticated logic for handling bandwidth-related connector errors\n        // we should really be keeping track of the amount sent within a given window of time\n        // and figuring out the max amount per window. this logic is just a stand in to fix\n        // infinite retries when it runs into this type of error\n        const minPacketAmount = BigNumber.minimum(amountSent, this.testMaximumPacketAmount)\n        const newTestAmount = minPacketAmount.minus(minPacketAmount.dividedToIntegerBy(3))\n        this.testMaximumPacketAmount = BigNumber.maximum(2, newTestAmount) // don't let it go to zero, set to 2 so that the other side gets at least 1 after the exchange rate is taken into account\n        this.log.warn(`got T04: Insufficient Liquidity error triggered by: ${reject.triggeredBy}. reducing the packet amount to ${this.testMaximumPacketAmount}`)\n      }\n\n      // TODO should we reduce the packet amount on other TXX errors too?\n      this.log.warn(`got ${reject.code} temporary error triggered by: ${reject.triggeredBy}. waiting ${this.retryDelay}ms before trying again`)\n      const delay = this.retryDelay\n      this.retryDelay = Math.min(this.retryDelay * 2, RETRY_DELAY_MAX)\n      await new Promise((resolve, reject) => setTimeout(resolve, delay))\n    } else {\n      this.log.error(`unexpected error. code: ${reject.code}, triggered by: ${reject.triggeredBy}, message: ${reject.message}, data: ${reject.data.toString('hex')}`)\n      throw new Error(`Unexpected error while sending packet. Code: ${reject.code}, triggered by: ${reject.triggeredBy}, message: ${reject.message}`)\n    }\n  }\n\n  protected safeEmit (event: string, ...args: any[]) {\n    try {\n      args.unshift(event)\n      this.emit.apply(this, args)\n    } catch (err) {\n      this.log.debug(`error in ${event} handler:`, err)\n    }\n  }\n\n  protected getOutgoingOffsets (): { currentOffset: number, maxOffset: number } {\n    let currentOffset = 0\n    let maxOffset = 0\n\n    for (let [_, stream] of this.streams) {\n      const streamOffsets = stream._getOutgoingOffsets()\n      currentOffset += streamOffsets.current\n      maxOffset += streamOffsets.max\n    }\n    return {\n      currentOffset,\n      maxOffset\n    }\n  }\n\n  protected getIncomingOffsets (): { current: number, max: number, maxAcceptable: number } {\n    let totalMaxOffset = 0\n    let totalReadOffset = 0\n    let totalBufferedData = 0\n    for (let [_, stream] of this.streams) {\n      const { max, current } = stream._getIncomingOffsets()\n      totalMaxOffset += max\n      totalReadOffset += current\n      totalBufferedData += stream.readableLength\n    }\n\n    return {\n      current: totalReadOffset,\n      max: totalMaxOffset,\n      maxAcceptable: totalReadOffset - totalBufferedData + this.maxBufferedData\n    }\n  }\n\n  protected removeStreamRecord (stream: DataAndMoneyStream) {\n    this.log.debug(`removing record of stream ${stream.id}`)\n    this.streams.delete(stream.id)\n    this.closedStreams[stream.id] = true\n    if (!stream._sentEnd) {\n      stream._sentEnd = true\n      const streamEndFrame = (stream._errorMessage\n        ? new StreamCloseFrame(stream.id, ErrorCode.ApplicationError, stream._errorMessage)\n        : new StreamCloseFrame(stream.id, ErrorCode.NoError, ''))\n      this.queuedFrames.push(streamEndFrame)\n    }\n  }\n\n  private startIdleTimer (): void {\n    if (this.idleTimeout === 0) return\n    const idle = Date.now() - this.lastActive.getTime()\n    this.idleTimer = setTimeout(() => this.testIdle(), this.idleTimeout - idle)\n    // browser timers don't support unref\n    /* tslint:disable-next-line:strict-type-predicates */\n    if (typeof this.idleTimer.unref === 'function') {\n      this.idleTimer.unref()\n    }\n    this.log.trace(`(re)starting idle timeout for ${this.idleTimeout}ms from now`)\n  }\n\n  private testIdle (): void {\n    const idle = Date.now() - this.lastActive.getTime()\n    if (idle >= this.idleTimeout) {\n      this.log.error('Connection timed out due to inactivity, destroying connection')\n      /* tslint:disable-next-line:no-floating-promises */\n      this.destroy(new Error('Connection timed out due to inactivity'))\n    } else {\n      this.startIdleTimer()\n    }\n  }\n\n  private bumpIdle (): void { this.lastActive = new Date() }\n}\n\nfunction isFulfill (packet: IlpPacket.IlpFulfill | IlpPacket.IlpReject): packet is IlpPacket.IlpFulfill {\n  return packet.hasOwnProperty('fulfillment')\n}\n"]}