"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const ILDCP = require("ilp-protocol-ildcp");
const IlpPacket = require("ilp-packet");
const ilp_logger_1 = require("ilp-logger");
const cryptoHelper = require("./crypto");
const crypto_1 = require("crypto");
const connection_1 = require("./connection");
require('source-map-support').install();
const CONNECTION_ID_REGEX = /^[a-zA-Z0-9_-]+$/;
var connection_2 = require("./connection");
exports.Connection = connection_2.Connection;
var stream_1 = require("./stream");
exports.DataAndMoneyStream = stream_1.DataAndMoneyStream;
function createConnection(opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const plugin = opts.plugin;
        yield plugin.connect();
        const log = ilp_logger_1.default('ilp-protocol-stream:Client');
        const { clientAddress, assetCode, assetScale } = yield ILDCP.fetch(plugin.sendData.bind(plugin));
        const connection = new connection_1.Connection(Object.assign({}, opts, { sourceAccount: clientAddress, assetCode,
            assetScale, isServer: false, plugin }));
        plugin.registerDataHandler((data) => __awaiter(this, void 0, void 0, function* () {
            let prepare;
            try {
                prepare = IlpPacket.deserializeIlpPrepare(data);
            }
            catch (err) {
                log.error(`got data that is not an ILP Prepare packet: ${data.toString('hex')}`);
                return IlpPacket.serializeIlpReject({
                    code: 'F00',
                    message: `Expected an ILP Prepare packet (type 12), but got packet with type: ${data[0]}`,
                    data: Buffer.alloc(0),
                    triggeredBy: clientAddress
                });
            }
            try {
                const fulfill = yield connection.handlePrepare(prepare);
                return IlpPacket.serializeIlpFulfill(fulfill);
            }
            catch (err) {
                if (!err.ilpErrorCode) {
                    log.error('error handling prepare:', err);
                }
                return IlpPacket.serializeIlpReject({
                    code: err.ilpErrorCode || 'F00',
                    message: err.ilpErrorMessage || '',
                    data: err.ilpErrorData || Buffer.alloc(0),
                    triggeredBy: clientAddress
                });
            }
        }));
        connection.once('close', () => {
            plugin.deregisterDataHandler();
            plugin.disconnect()
                .then(() => log.info('plugin disconnected'))
                .catch((err) => log.error('error disconnecting plugin:', err));
        });
        yield connection.connect();
        return connection;
    });
}
exports.createConnection = createConnection;
class Server extends events_1.EventEmitter {
    constructor(opts) {
        super();
        this.serverSecret = opts.serverSecret || crypto_1.randomBytes(32);
        this.plugin = opts.plugin;
        this.log = ilp_logger_1.default('ilp-protocol-stream:Server');
        this.connections = {};
        this.closedConnections = {};
        this.connectionOpts = Object.assign({}, opts, {
            serverSecret: undefined
        });
        this.connected = false;
    }
    listen() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.connected && this.plugin.isConnected()) {
                return;
            }
            this.plugin.registerDataHandler(this.handleData.bind(this));
            yield this.plugin.connect();
            const { clientAddress, assetCode, assetScale } = yield ILDCP.fetch(this.plugin.sendData.bind(this.plugin));
            this.serverAccount = clientAddress;
            this.serverAssetCode = assetCode;
            this.serverAssetScale = assetScale;
            this.connected = true;
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            yield Promise.all(Object.keys(this.connections).map((id) => {
                return this.connections[id].end();
            }));
            this.plugin.deregisterDataHandler();
            yield this.plugin.disconnect();
            this.emit('_close');
            this.connected = false;
        });
    }
    acceptConnection() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.listen();
            return new Promise((resolve, reject) => {
                const done = (connection) => {
                    this.removeListener('connection', done);
                    this.removeListener('_close', done);
                    if (connection)
                        resolve(connection);
                    else
                        reject(new Error('server closed'));
                };
                this.once('connection', done);
                this.once('_close', done);
            });
        });
    }
    generateAddressAndSecret(connectionTag) {
        if (!this.connected) {
            throw new Error('Server must be connected to generate address and secret');
        }
        let token = base64url(cryptoHelper.generateToken());
        if (connectionTag) {
            if (!CONNECTION_ID_REGEX.test(connectionTag)) {
                throw new Error('connectionTag can only include ASCII characters a-z, A-Z, 0-9, "_", and "-"');
            }
            token = token + '~' + connectionTag;
        }
        const sharedSecret = cryptoHelper.generateSharedSecretFromToken(this.serverSecret, Buffer.from(token, 'ascii'));
        return {
            destinationAccount: `${this.serverAccount}.${token}`,
            sharedSecret
        };
    }
    get assetCode() {
        if (!this.connected) {
            throw new Error('Server must be connected to get asset code.');
        }
        return this.serverAssetCode;
    }
    get assetScale() {
        if (!this.connected) {
            throw new Error('Server must be connected to get asset scale.');
        }
        return this.serverAssetScale;
    }
    handleData(data) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let prepare;
                try {
                    prepare = IlpPacket.deserializeIlpPrepare(data);
                }
                catch (err) {
                    this.log.error(`got data that is not an ILP Prepare packet: ${data.toString('hex')}`);
                    return IlpPacket.serializeIlpReject({
                        code: 'F00',
                        message: `Expected an ILP Prepare packet (type 12), but got packet with type: ${data[0]}`,
                        data: Buffer.alloc(0),
                        triggeredBy: this.serverAccount
                    });
                }
                const localAddressParts = prepare.destination.replace(this.serverAccount + '.', '').split('.');
                if (localAddressParts.length === 0 || !localAddressParts[0]) {
                    this.log.error(`destination in ILP Prepare packet does not have a Connection ID: ${prepare.destination}`);
                    throw new IlpPacket.Errors.UnreachableError('');
                }
                const connectionId = localAddressParts[0];
                if (this.closedConnections[connectionId]) {
                    this.log.debug(`got packet for connection that was already closed: ${connectionId}`);
                    throw new IlpPacket.Errors.UnreachableError('');
                }
                if (!this.connections[connectionId]) {
                    let sharedSecret;
                    try {
                        const token = Buffer.from(connectionId, 'ascii');
                        sharedSecret = cryptoHelper.generateSharedSecretFromToken(this.serverSecret, token);
                        cryptoHelper.decrypt(sharedSecret, prepare.data);
                    }
                    catch (err) {
                        this.log.error(`got prepare for an address and token that we did not generate: ${prepare.destination}`);
                        throw new IlpPacket.Errors.UnreachableError('');
                    }
                    const connectionTag = (connectionId.indexOf('~') !== -1 ? connectionId.slice(connectionId.indexOf('~') + 1) : undefined);
                    const connection = new connection_1.Connection(Object.assign({}, this.connectionOpts, { sourceAccount: this.serverAccount, assetCode: this.serverAssetCode, assetScale: this.serverAssetScale, sharedSecret, isServer: true, connectionTag, plugin: this.plugin }));
                    this.connections[connectionId] = connection;
                    this.log.debug(`got incoming packet for new connection: ${connectionId}${(connectionTag ? ' (connectionTag: ' + connectionTag + ')' : '')}`);
                    try {
                        this.emit('connection', connection);
                    }
                    catch (err) {
                        this.log.error('error in connection event handler:', err);
                    }
                    connection.once('close', () => {
                        delete this.connections[connectionId];
                        this.closedConnections[connectionId] = true;
                    });
                    yield new Promise((resolve, reject) => setImmediate(resolve));
                }
                const fulfill = yield this.connections[connectionId].handlePrepare(prepare);
                return IlpPacket.serializeIlpFulfill(fulfill);
            }
            catch (err) {
                if (!err.ilpErrorCode) {
                    this.log.error('error handling prepare:', err);
                }
                return IlpPacket.serializeIlpReject({
                    code: err.ilpErrorCode || 'F00',
                    message: err.ilpErrorMessage || '',
                    data: err.ilpErrorData || Buffer.alloc(0),
                    triggeredBy: this.serverAccount || ''
                });
            }
        });
    }
}
exports.Server = Server;
function createServer(opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const server = new Server(opts);
        yield server.listen();
        return server;
    });
}
exports.createServer = createServer;
function base64url(buffer) {
    return buffer.toString('base64')
        .replace(/=+$/, '')
        .replace(/\+/g, '-')
        .replace(/\//g, '_');
}
//# sourceMappingURL=index.js.map