"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const oer_utils_1 = require("oer-utils");
const bignumber_js_1 = require("bignumber.js");
const crypto_1 = require("./crypto");
const assert = require("assert");
require('source-map-support').install();
const VERSION = 1;
const ZERO_BYTES = Buffer.alloc(32);
const MAX_UINT64 = new bignumber_js_1.default('18446744073709551615');
var IlpPacketType;
(function (IlpPacketType) {
    IlpPacketType[IlpPacketType["Prepare"] = 12] = "Prepare";
    IlpPacketType[IlpPacketType["Fulfill"] = 13] = "Fulfill";
    IlpPacketType[IlpPacketType["Reject"] = 14] = "Reject";
})(IlpPacketType = exports.IlpPacketType || (exports.IlpPacketType = {}));
var ErrorCode;
(function (ErrorCode) {
    ErrorCode[ErrorCode["NoError"] = 1] = "NoError";
    ErrorCode[ErrorCode["InternalError"] = 2] = "InternalError";
    ErrorCode[ErrorCode["EndpointBusy"] = 3] = "EndpointBusy";
    ErrorCode[ErrorCode["FlowControlError"] = 4] = "FlowControlError";
    ErrorCode[ErrorCode["StreamIdError"] = 5] = "StreamIdError";
    ErrorCode[ErrorCode["StreamStateError"] = 6] = "StreamStateError";
    ErrorCode[ErrorCode["FrameFormatError"] = 7] = "FrameFormatError";
    ErrorCode[ErrorCode["ProtocolViolation"] = 8] = "ProtocolViolation";
    ErrorCode[ErrorCode["ApplicationError"] = 9] = "ApplicationError";
})(ErrorCode = exports.ErrorCode || (exports.ErrorCode = {}));
var FrameType;
(function (FrameType) {
    FrameType[FrameType["ConnectionClose"] = 1] = "ConnectionClose";
    FrameType[FrameType["ConnectionNewAddress"] = 2] = "ConnectionNewAddress";
    FrameType[FrameType["ConnectionMaxData"] = 3] = "ConnectionMaxData";
    FrameType[FrameType["ConnectionDataBlocked"] = 4] = "ConnectionDataBlocked";
    FrameType[FrameType["ConnectionMaxStreamId"] = 5] = "ConnectionMaxStreamId";
    FrameType[FrameType["ConnectionStreamIdBlocked"] = 6] = "ConnectionStreamIdBlocked";
    FrameType[FrameType["ConnectionAssetDetails"] = 7] = "ConnectionAssetDetails";
    FrameType[FrameType["StreamClose"] = 16] = "StreamClose";
    FrameType[FrameType["StreamMoney"] = 17] = "StreamMoney";
    FrameType[FrameType["StreamMaxMoney"] = 18] = "StreamMaxMoney";
    FrameType[FrameType["StreamMoneyBlocked"] = 19] = "StreamMoneyBlocked";
    FrameType[FrameType["StreamData"] = 20] = "StreamData";
    FrameType[FrameType["StreamMaxData"] = 21] = "StreamMaxData";
    FrameType[FrameType["StreamDataBlocked"] = 22] = "StreamDataBlocked";
})(FrameType = exports.FrameType || (exports.FrameType = {}));
class Packet {
    constructor(sequence, ilpPacketType, packetAmount = 0, frames = []) {
        this.sequence = new bignumber_js_1.default(sequence);
        this.ilpPacketType = ilpPacketType;
        this.prepareAmount = new bignumber_js_1.default(packetAmount);
        this.frames = frames;
    }
    static decryptAndDeserialize(sharedSecret, buffer) {
        let decrypted;
        try {
            decrypted = crypto_1.decrypt(sharedSecret, buffer);
        }
        catch (err) {
            throw new Error(`Unable to decrypt packet. Data was corrupted or packet was encrypted with the wrong key`);
        }
        return Packet._deserializeUnencrypted(decrypted);
    }
    static _deserializeUnencrypted(buffer) {
        const reader = oer_utils_1.Reader.from(buffer);
        const version = reader.readUInt8BigNum();
        if (!version.isEqualTo(VERSION)) {
            throw new Error(`Unsupported protocol version: ${version}`);
        }
        const ilpPacketType = reader.readUInt8BigNum().toNumber();
        const sequence = reader.readVarUIntBigNum();
        const packetAmount = reader.readVarUIntBigNum();
        const numFrames = reader.readVarUIntBigNum().toNumber();
        const frames = [];
        for (let i = 0; i < numFrames; i++) {
            const frame = parseFrame(reader);
            if (frame) {
                frames.push(frame);
            }
        }
        return new Packet(sequence, ilpPacketType, packetAmount, frames);
    }
    serializeAndEncrypt(sharedSecret, padPacketToSize) {
        const serialized = this._serialize();
        if (padPacketToSize !== undefined) {
            const paddingSize = padPacketToSize - crypto_1.ENCRYPTION_OVERHEAD - serialized.length;
            const args = [sharedSecret, serialized];
            for (let i = 0; i < Math.floor(paddingSize / 32); i++) {
                args.push(ZERO_BYTES);
            }
            args.push(ZERO_BYTES.slice(0, paddingSize % 32));
            return crypto_1.encrypt.apply(null, args);
        }
        return crypto_1.encrypt(sharedSecret, serialized);
    }
    _serialize() {
        const writer = new oer_utils_1.Writer();
        this.writeTo(writer);
        return writer.getBuffer();
    }
    writeTo(writer) {
        writer.writeUInt8(VERSION);
        writer.writeUInt8(this.ilpPacketType);
        writer.writeVarUInt(this.sequence);
        writer.writeVarUInt(this.prepareAmount);
        writer.writeVarUInt(this.frames.length);
        for (let frame of this.frames) {
            frame.writeTo(writer);
        }
    }
    byteLength() {
        const predictor = new oer_utils_1.Predictor();
        this.writeTo(predictor);
        return predictor.getSize() + crypto_1.ENCRYPTION_OVERHEAD;
    }
}
exports.Packet = Packet;
class BaseFrame {
    constructor(name) {
        this.type = FrameType[name];
        this.name = name;
    }
    static fromContents(reader) {
        throw new Error(`class method "fromContents" is not implemented`);
    }
    writeTo(writer) {
        const properties = Object.getOwnPropertyNames(this).filter((propName) => propName !== 'type' && propName !== 'name');
        writer.writeUInt8(this.type);
        const contents = new oer_utils_1.Writer();
        for (let prop of properties) {
            if (typeof this[prop] === 'number') {
                contents.writeUInt8(this[prop]);
            }
            else if (typeof this[prop] === 'string') {
                contents.writeVarOctetString(Buffer.from(this[prop], 'utf8'));
            }
            else if (Buffer.isBuffer(this[prop])) {
                contents.writeVarOctetString(this[prop]);
            }
            else if (this[prop] instanceof bignumber_js_1.default) {
                contents.writeVarUInt(this[prop]);
            }
            else {
                throw new Error(`Unexpected property type for property "${prop}": ${typeof this[prop]}`);
            }
        }
        writer.writeVarOctetString(contents.getBuffer());
        return writer;
    }
    byteLength() {
        const predictor = new oer_utils_1.Predictor();
        this.writeTo(predictor);
        return predictor.getSize();
    }
}
exports.BaseFrame = BaseFrame;
class ConnectionCloseFrame extends BaseFrame {
    constructor(errorCode, errorMessage) {
        super('ConnectionClose');
        this.errorCode = errorCode;
        this.errorMessage = errorMessage;
    }
    static fromContents(reader) {
        const errorCode = reader.readUInt8BigNum().toNumber();
        const errorMessage = reader.readVarOctetString().toString();
        return new ConnectionCloseFrame(errorCode, errorMessage);
    }
}
exports.ConnectionCloseFrame = ConnectionCloseFrame;
class ConnectionNewAddressFrame extends BaseFrame {
    constructor(sourceAccount) {
        super('ConnectionNewAddress');
        this.sourceAccount = sourceAccount;
    }
    static fromContents(reader) {
        const sourceAccount = reader.readVarOctetString().toString('utf8');
        return new ConnectionNewAddressFrame(sourceAccount);
    }
}
exports.ConnectionNewAddressFrame = ConnectionNewAddressFrame;
class ConnectionAssetDetailsFrame extends BaseFrame {
    constructor(sourceAssetCode, sourceAssetScale) {
        super('ConnectionAssetDetails');
        this.sourceAssetCode = sourceAssetCode;
        this.sourceAssetScale = sourceAssetScale;
    }
    static fromContents(reader) {
        const sourceAssetCode = reader.readVarOctetString().toString('utf8');
        const sourceAssetScale = reader.readUInt8BigNum().toNumber();
        return new ConnectionAssetDetailsFrame(sourceAssetCode, sourceAssetScale);
    }
}
exports.ConnectionAssetDetailsFrame = ConnectionAssetDetailsFrame;
class ConnectionMaxDataFrame extends BaseFrame {
    constructor(maxOffset) {
        super('ConnectionMaxData');
        this.maxOffset = new bignumber_js_1.default(maxOffset);
    }
    static fromContents(reader) {
        const maxOffset = reader.readVarUIntBigNum();
        return new ConnectionMaxDataFrame(maxOffset);
    }
}
exports.ConnectionMaxDataFrame = ConnectionMaxDataFrame;
class ConnectionDataBlockedFrame extends BaseFrame {
    constructor(maxOffset) {
        super('ConnectionDataBlocked');
        this.maxOffset = new bignumber_js_1.default(maxOffset);
    }
    static fromContents(reader) {
        const maxOffset = reader.readVarUIntBigNum();
        return new ConnectionDataBlockedFrame(maxOffset);
    }
}
exports.ConnectionDataBlockedFrame = ConnectionDataBlockedFrame;
class ConnectionMaxStreamIdFrame extends BaseFrame {
    constructor(maxStreamId) {
        super('ConnectionMaxStreamId');
        this.maxStreamId = new bignumber_js_1.default(maxStreamId);
    }
    static fromContents(reader) {
        const maxStreamId = reader.readVarUIntBigNum();
        return new ConnectionMaxStreamIdFrame(maxStreamId);
    }
}
exports.ConnectionMaxStreamIdFrame = ConnectionMaxStreamIdFrame;
class ConnectionStreamIdBlockedFrame extends BaseFrame {
    constructor(maxStreamId) {
        super('ConnectionStreamIdBlocked');
        this.maxStreamId = new bignumber_js_1.default(maxStreamId);
    }
    static fromContents(reader) {
        const maxStreamId = reader.readVarUIntBigNum();
        return new ConnectionStreamIdBlockedFrame(maxStreamId);
    }
}
exports.ConnectionStreamIdBlockedFrame = ConnectionStreamIdBlockedFrame;
class StreamCloseFrame extends BaseFrame {
    constructor(streamId, errorCode, errorMessage) {
        super('StreamClose');
        this.streamId = new bignumber_js_1.default(streamId);
        this.errorCode = errorCode;
        this.errorMessage = errorMessage;
    }
    static fromContents(reader) {
        const streamId = reader.readVarUIntBigNum();
        const errorCode = reader.readUInt8BigNum().toNumber();
        const errorMessage = reader.readVarOctetString().toString('utf8');
        return new StreamCloseFrame(streamId, errorCode, errorMessage);
    }
}
exports.StreamCloseFrame = StreamCloseFrame;
class StreamMoneyFrame extends BaseFrame {
    constructor(streamId, shares) {
        super('StreamMoney');
        this.streamId = new bignumber_js_1.default(streamId);
        this.shares = new bignumber_js_1.default(shares);
        assert(this.shares.isInteger() && this.shares.isPositive(), `shares must be a positive integer: ${shares}`);
    }
    static fromContents(reader) {
        const streamId = reader.readVarUIntBigNum();
        const amount = reader.readVarUIntBigNum();
        return new StreamMoneyFrame(streamId, amount);
    }
}
exports.StreamMoneyFrame = StreamMoneyFrame;
class StreamMaxMoneyFrame extends BaseFrame {
    constructor(streamId, receiveMax, totalReceived) {
        super('StreamMaxMoney');
        this.streamId = new bignumber_js_1.default(streamId);
        this.receiveMax = new bignumber_js_1.default(receiveMax);
        this.totalReceived = new bignumber_js_1.default(totalReceived);
        if (!this.receiveMax.isFinite()) {
            this.receiveMax = MAX_UINT64;
        }
        assert(this.receiveMax.isInteger() && this.receiveMax.isPositive(), `receiveMax must be a positive integer. got: ${receiveMax}`);
        assert(this.totalReceived.isInteger() && this.totalReceived.isPositive(), `totalReceived must be a positive integer. got: ${totalReceived}`);
    }
    static fromContents(reader) {
        const streamId = reader.readVarUIntBigNum();
        const receiveMax = reader.readVarUIntBigNum();
        const totalReceived = reader.readVarUIntBigNum();
        return new StreamMaxMoneyFrame(streamId, receiveMax, totalReceived);
    }
}
exports.StreamMaxMoneyFrame = StreamMaxMoneyFrame;
class StreamMoneyBlockedFrame extends BaseFrame {
    constructor(streamId, sendMax, totalSent) {
        super('StreamMoneyBlocked');
        this.streamId = new bignumber_js_1.default(streamId);
        this.sendMax = new bignumber_js_1.default(sendMax);
        this.totalSent = new bignumber_js_1.default(totalSent);
        assert(this.sendMax.isInteger() && this.sendMax.isPositive(), `sendMax must be a positive integer. got: ${sendMax}`);
        assert(this.totalSent.isInteger() && this.totalSent.isPositive(), `totalSent must be a positive integer. got: ${totalSent}`);
    }
    static fromContents(reader) {
        const streamId = reader.readVarUIntBigNum();
        const sendMax = reader.readVarUIntBigNum();
        const totalSent = reader.readVarUIntBigNum();
        return new StreamMoneyBlockedFrame(streamId, sendMax, totalSent);
    }
}
exports.StreamMoneyBlockedFrame = StreamMoneyBlockedFrame;
class StreamDataFrame extends BaseFrame {
    constructor(streamId, offset, data) {
        super('StreamData');
        this.streamId = new bignumber_js_1.default(streamId);
        this.offset = new bignumber_js_1.default(offset);
        this.data = data;
    }
    static fromContents(reader) {
        const streamId = reader.readVarUIntBigNum();
        const offset = reader.readVarUIntBigNum();
        const data = reader.readVarOctetString();
        return new StreamDataFrame(streamId, offset, data);
    }
    toJSON() {
        return {
            type: this.type,
            name: this.name,
            streamId: this.streamId,
            offset: this.offset,
            dataLength: this.data.length
        };
    }
}
exports.StreamDataFrame = StreamDataFrame;
class StreamMaxDataFrame extends BaseFrame {
    constructor(streamId, maxOffset) {
        super('StreamMaxData');
        this.streamId = new bignumber_js_1.default(streamId);
        this.maxOffset = new bignumber_js_1.default(maxOffset);
    }
    static fromContents(reader) {
        const streamId = reader.readVarUIntBigNum();
        const maxOffset = reader.readVarUIntBigNum();
        return new StreamMaxDataFrame(streamId, maxOffset);
    }
}
exports.StreamMaxDataFrame = StreamMaxDataFrame;
class StreamDataBlockedFrame extends BaseFrame {
    constructor(streamId, maxOffset) {
        super('StreamDataBlocked');
        this.streamId = new bignumber_js_1.default(streamId);
        this.maxOffset = new bignumber_js_1.default(maxOffset);
    }
    static fromContents(reader) {
        const streamId = reader.readVarUIntBigNum();
        const maxOffset = reader.readVarUIntBigNum();
        return new StreamDataBlockedFrame(streamId, maxOffset);
    }
}
exports.StreamDataBlockedFrame = StreamDataBlockedFrame;
function parseFrame(reader) {
    const type = reader.readUInt8BigNum().toNumber();
    const contents = oer_utils_1.Reader.from(reader.readVarOctetString());
    switch (type) {
        case FrameType.ConnectionClose:
            return ConnectionCloseFrame.fromContents(contents);
        case FrameType.ConnectionNewAddress:
            return ConnectionNewAddressFrame.fromContents(contents);
        case FrameType.ConnectionAssetDetails:
            return ConnectionAssetDetailsFrame.fromContents(contents);
        case FrameType.ConnectionMaxData:
            return ConnectionMaxDataFrame.fromContents(contents);
        case FrameType.ConnectionDataBlocked:
            return ConnectionDataBlockedFrame.fromContents(contents);
        case FrameType.ConnectionMaxStreamId:
            return ConnectionMaxStreamIdFrame.fromContents(contents);
        case FrameType.ConnectionStreamIdBlocked:
            return ConnectionStreamIdBlockedFrame.fromContents(contents);
        case FrameType.StreamClose:
            return StreamCloseFrame.fromContents(contents);
        case FrameType.StreamMoney:
            return StreamMoneyFrame.fromContents(contents);
        case FrameType.StreamMaxMoney:
            return StreamMaxMoneyFrame.fromContents(contents);
        case FrameType.StreamMoneyBlocked:
            return StreamMoneyBlockedFrame.fromContents(contents);
        case FrameType.StreamData:
            return StreamDataFrame.fromContents(contents);
        case FrameType.StreamMaxData:
            return StreamMaxDataFrame.fromContents(contents);
        case FrameType.StreamDataBlocked:
            return StreamDataBlockedFrame.fromContents(contents);
        default:
            return undefined;
    }
}
//# sourceMappingURL=packet.js.map