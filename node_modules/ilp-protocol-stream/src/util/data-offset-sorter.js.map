{"version":3,"file":"data-offset-sorter.js","sourceRoot":"","sources":["data-offset-sorter.ts"],"names":[],"mappings":";;AAGA,MAAa,eAAe;IAI1B,YAAa,IAAY,EAAE,MAAc,EAAE,IAAsB;QAC/D,IAAI,CAAC,IAAI,GAAG,IAAI,CAAA;QAChB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAA;QACpB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAA;IAClB,CAAC;CACF;AATD,0CASC;AAGD,MAAa,YAAY;IAIvB;QACE,IAAI,CAAC,UAAU,GAAG,CAAC,CAAA;QACnB,IAAI,CAAC,SAAS,GAAG,CAAC,CAAA;IACpB,CAAC;IAED,IAAI,CAAE,IAAY,EAAE,MAAc;QAChC,MAAM,KAAK,GAAG,IAAI,eAAe,CAAC,IAAI,EAAE,MAAM,CAAC,CAAA;QAE/C,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,SAAS,CAAC,CAAA;QAE/D,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;YACd,IAAI,CAAC,IAAI,GAAG,KAAK,CAAA;SAClB;aAAM,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,MAAM,EAAE;YACpC,KAAK,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAA;YACtB,IAAI,CAAC,IAAI,GAAG,KAAK,CAAA;SAClB;aAAM;YACL,IAAI,IAAI,GAAG,IAAI,CAAC,IAAI,CAAA;YACpB,OAAO,IAAI,EAAE;gBACX,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;oBACd,IAAI,CAAC,IAAI,GAAG,KAAK,CAAA;oBACjB,MAAK;iBACN;gBACD,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,MAAM,EAAE;oBAC7B,KAAK,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAA;oBACtB,IAAI,CAAC,IAAI,GAAG,KAAK,CAAA;oBACjB,MAAK;iBACN;gBACD,IAAI,GAAG,IAAI,CAAC,IAAI,CAAA;aACjB;SACF;IACH,CAAC;IAED,IAAI;QACF,IAAI,IAAI,CAAA;QACR,IAAI,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,UAAU,KAAK,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;YACrD,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAA;YACrB,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAA;YAC7D,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAA;SAC3B;QACD,OAAO,IAAI,CAAA;IACb,CAAC;IAGD,UAAU;QACR,IAAI,MAAM,GAAG,CAAC,CAAA;QACd,IAAI,KAAK,GAAG,IAAI,CAAC,IAAI,CAAA;QACrB,IAAI,MAAM,GAAG,IAAI,CAAC,UAAU,CAAA;QAC5B,OAAO,KAAK,IAAI,KAAK,CAAC,MAAM,KAAK,MAAM,EAAE;YACvC,MAAM,IAAI,KAAK,CAAC,IAAI,CAAC,MAAM,CAAA;YAC3B,MAAM,IAAI,KAAK,CAAC,IAAI,CAAC,MAAM,CAAA;YAC3B,KAAK,GAAG,KAAK,CAAC,IAAI,CAAA;SACnB;QACD,OAAO,MAAM,CAAA;IACf,CAAC;CACF;AA1DD,oCA0DC","sourcesContent":["// Inspired by https://github.com/toajs/quic/blob/master/src/stream.ts\n\n/** @private */\nexport class OffsetDataEntry {\n  data: Buffer\n  offset: number\n  next?: OffsetDataEntry\n  constructor (data: Buffer, offset: number, next?: OffsetDataEntry) {\n    this.data = data\n    this.offset = offset\n    this.next = next\n  }\n}\n\n/** @private */\nexport class OffsetSorter {\n  head?: OffsetDataEntry\n  readOffset: number\n  maxOffset: number\n  constructor () {\n    this.readOffset = 0\n    this.maxOffset = 0\n  }\n\n  push (data: Buffer, offset: number) {\n    const entry = new OffsetDataEntry(data, offset)\n\n    this.maxOffset = Math.max(offset + data.length, this.maxOffset)\n\n    if (!this.head) {\n      this.head = entry\n    } else if (this.head.offset > offset) {\n      entry.next = this.head\n      this.head = entry\n    } else {\n      let prev = this.head\n      while (true) {\n        if (!prev.next) {\n          prev.next = entry\n          break\n        }\n        if (prev.next.offset > offset) {\n          entry.next = prev.next\n          prev.next = entry\n          break\n        }\n        prev = prev.next\n      }\n    }\n  }\n\n  read (): Buffer | undefined {\n    let data\n    if (this.head && this.readOffset === this.head.offset) {\n      data = this.head.data\n      this.readOffset = this.head.offset + (data ? data.length : 0)\n      this.head = this.head.next\n    }\n    return data\n  }\n\n  // Only returns contiguous data\n  byteLength (): number {\n    let length = 0\n    let entry = this.head\n    let offset = this.readOffset\n    while (entry && entry.offset === offset) {\n      length += entry.data.length\n      offset += entry.data.length\n      entry = entry.next\n    }\n    return length\n  }\n}\n"]}