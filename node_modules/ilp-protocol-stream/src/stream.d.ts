/// <reference types="node" />
import BigNumber from 'bignumber.js';
import { Duplex } from 'stream';
import { DataQueue } from './util/data-queue';
import { OffsetSorter } from './util/data-offset-sorter';
export interface StreamOpts {
    id: number;
    isServer: boolean;
}
export interface SendOpts {
    timeout?: number;
}
export interface ReceiveOpts {
    timeout?: number;
}
export declare class DataAndMoneyStream extends Duplex {
    readonly id: number;
    _errorMessage?: string;
    _remoteClosed: boolean;
    _remoteReceiveMax: BigNumber;
    _remoteReceived: BigNumber;
    _remoteMaxOffset: number;
    _sentEnd: boolean;
    _remoteSentEnd: boolean;
    protected log: any;
    protected isServer: boolean;
    protected _totalSent: BigNumber;
    protected _totalReceived: BigNumber;
    protected _sendMax: BigNumber;
    protected _receiveMax: BigNumber;
    protected _outgoingHeldAmount: BigNumber;
    protected closed: boolean;
    protected holds: {
        [id: string]: BigNumber;
    };
    protected _incomingData: OffsetSorter;
    protected _outgoingData: DataQueue;
    protected _outgoingDataToRetry: {
        data: Buffer;
        offset: number;
    }[];
    protected outgoingOffset: number;
    protected emittedEnd: boolean;
    protected emittedClose: boolean;
    constructor(opts: StreamOpts);
    readonly totalSent: string;
    readonly totalReceived: string;
    readonly sendMax: string;
    readonly receiveMax: string;
    readonly readableLength: number;
    readonly writableLength: number;
    readonly readableHighWaterMark: number;
    readonly writableHighWaterMark: number;
    isOpen(): boolean;
    setSendMax(limit: BigNumber.Value): void;
    setReceiveMax(limit: BigNumber.Value): void;
    sendTotal(limit: BigNumber.Value, opts?: SendOpts): Promise<void>;
    receiveTotal(limit: BigNumber.Value, opts?: ReceiveOpts): Promise<void>;
    _getAmountStreamCanReceive(): BigNumber;
    _addToIncoming(amount: BigNumber): void;
    _getAmountAvailableToSend(): BigNumber;
    _holdOutgoing(holdId: string, maxAmount?: BigNumber): BigNumber;
    _executeHold(holdId: string): void;
    _cancelHold(holdId: string): void;
    _final(callback: (...args: any[]) => void): void;
    _destroy(error: Error | undefined | null, callback: (...args: any[]) => void): void;
    _write(chunk: Buffer, encoding: string, callback: (...args: any[]) => void): void;
    _writev(chunks: {
        chunk: Buffer;
        encoding: string;
    }[], callback: (...args: any[]) => void): void;
    _read(size: number): void;
    _hasDataToSend(): boolean;
    _getAvailableDataToSend(size: number): {
        data: Buffer | undefined;
        offset: number;
    };
    _resendOutgoingData(data: Buffer, offset: number): void;
    _isDataBlocked(): number | undefined;
    _getOutgoingOffsets(): {
        current: number;
        max: number;
    };
    _getIncomingOffsets(): {
        max: number;
        current: number;
        maxAcceptable: number;
    };
    _pushIncomingData(data: Buffer, offset: number): void;
    _remoteEnded(err?: Error): void;
    protected safeEmit(event: string, ...args: any[]): void;
}
