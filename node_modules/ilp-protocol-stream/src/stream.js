"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ilp_logger_1 = require("ilp-logger");
const bignumber_js_1 = require("bignumber.js");
const stream_1 = require("stream");
const data_queue_1 = require("./util/data-queue");
const data_offset_sorter_1 = require("./util/data-offset-sorter");
require('source-map-support').install();
const DEFAULT_TIMEOUT = 60000;
class DataAndMoneyStream extends stream_1.Duplex {
    constructor(opts) {
        super({ allowHalfOpen: false });
        this.id = opts.id;
        this.isServer = opts.isServer;
        this.log = ilp_logger_1.default(`ilp-protocol-stream:${this.isServer ? 'Server' : 'Client'}:Stream:${this.id}`);
        this.log.info('new stream created');
        this._totalSent = new bignumber_js_1.default(0);
        this._totalReceived = new bignumber_js_1.default(0);
        this._sendMax = new bignumber_js_1.default(0);
        this._receiveMax = new bignumber_js_1.default(0);
        this._outgoingHeldAmount = new bignumber_js_1.default(0);
        this._sentEnd = false;
        this._remoteSentEnd = false;
        this.closed = false;
        this.holds = {};
        this._incomingData = new data_offset_sorter_1.OffsetSorter();
        this._outgoingData = new data_queue_1.DataQueue();
        this._outgoingDataToRetry = [];
        this.outgoingOffset = 0;
        this._remoteClosed = false;
        this._remoteReceived = new bignumber_js_1.default(0);
        this._remoteReceiveMax = new bignumber_js_1.default(Infinity);
        this._remoteMaxOffset = 16384;
        this.emittedEnd = false;
        this.emittedClose = false;
        this.once('end', () => {
            this.emittedEnd = true;
        });
        this.once('close', () => {
            this.emittedClose = true;
        });
    }
    get totalSent() {
        return this._totalSent.toString();
    }
    get totalReceived() {
        return this._totalReceived.toString();
    }
    get sendMax() {
        return this._sendMax.toString();
    }
    get receiveMax() {
        return this._receiveMax.toString();
    }
    get readableLength() {
        const readableLength = super.readableLength || (this['_readableState'] && this['_readableState'].length) || 0;
        return readableLength + this._incomingData.byteLength();
    }
    get writableLength() {
        const writableLength = super.writableLength || (this['_writableState'] && this['_writableState'].length) || 0;
        return writableLength;
    }
    get readableHighWaterMark() {
        if (typeof super.readableHighWaterMark === 'number') {
            return super.readableHighWaterMark;
        }
        else {
            return this['_readableState'].highWaterMark;
        }
    }
    get writableHighWaterMark() {
        if (typeof super.writableHighWaterMark === 'number') {
            return super.writableHighWaterMark;
        }
        else {
            return this['_writableState'].highWaterMark;
        }
    }
    isOpen() {
        return !this.closed;
    }
    setSendMax(limit) {
        if (this.closed) {
            throw new Error('Stream already closed');
        }
        const sendMax = new bignumber_js_1.default(limit);
        if (this._totalSent.isGreaterThan(sendMax)) {
            this.log.debug(`cannot set sendMax to ${sendMax} because we have already sent: ${this._totalSent}`);
            throw new Error(`Cannot set sendMax lower than the totalSent`);
        }
        if (!sendMax.isFinite()) {
            throw new Error('sendMax must be finite');
        }
        this.log.debug(`setting sendMax to ${sendMax}`);
        this._sendMax = sendMax;
        this.emit('_maybe_start_send_loop');
    }
    setReceiveMax(limit) {
        if (this.closed) {
            throw new Error('Stream already closed');
        }
        if (this._totalReceived.isGreaterThan(limit)) {
            this.log.debug(`cannot set receiveMax to ${limit} because we have already received: ${this._totalReceived}`);
            throw new Error('Cannot set receiveMax lower than the totalReceived');
        }
        if (this._receiveMax.isGreaterThan(limit)) {
            this.log.debug(`cannot set receiveMax to ${limit} because the current limit is: ${this._receiveMax}`);
            throw new Error('Cannot decrease the receiveMax');
        }
        this.log.debug(`setting receiveMax to ${limit}`);
        this._receiveMax = new bignumber_js_1.default(limit);
        this.emit('_maybe_start_send_loop');
    }
    sendTotal(limit, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const timeout = (opts && opts.timeout) || DEFAULT_TIMEOUT;
            if (this._totalSent.isGreaterThanOrEqualTo(limit)) {
                this.log.debug(`already sent ${this._totalSent}, not sending any more`);
                return Promise.resolve();
            }
            this.setSendMax(limit);
            yield new Promise((resolve, reject) => {
                const self = this;
                function outgoingHandler() {
                    if (self._totalSent.isGreaterThanOrEqualTo(limit)) {
                        cleanup();
                        resolve();
                    }
                }
                function endHandler() {
                    setImmediate(cleanup);
                    if ((self._totalSent.isGreaterThanOrEqualTo(limit))) {
                        resolve();
                    }
                    else {
                        self.log.debug(`Stream was closed before the desired amount was sent (target: ${limit}, totalSent: ${self._totalSent})`);
                        reject(new Error(`Stream was closed before the desired amount was sent (target: ${limit}, totalSent: ${self._totalSent})`));
                    }
                }
                function errorHandler(err) {
                    self.log.debug('error waiting for stream to stabilize:', err);
                    cleanup();
                    reject(new Error(`Stream encountered an error before the desired amount was sent (target: ${limit}, totalSent: ${self._totalSent}): ${err}`));
                }
                const timer = setTimeout(() => {
                    cleanup();
                    reject(new Error(`Timed out before the desired amount was sent (target: ${limit}, totalSent: ${self._totalSent})`));
                }, timeout);
                function cleanup() {
                    clearTimeout(timer);
                    self.removeListener('outgoing_money', outgoingHandler);
                    self.removeListener('error', errorHandler);
                    self.removeListener('end', endHandler);
                }
                this.on('outgoing_money', outgoingHandler);
                this.on('error', errorHandler);
                this.on('end', endHandler);
            });
        });
    }
    receiveTotal(limit, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const timeout = (opts && opts.timeout) || DEFAULT_TIMEOUT;
            if (this._totalReceived.isGreaterThanOrEqualTo(limit)) {
                this.log.debug(`already received ${this._totalReceived}, not waiting for more`);
                return Promise.resolve();
            }
            this.setReceiveMax(limit);
            yield new Promise((resolve, reject) => {
                const self = this;
                function moneyHandler() {
                    if (self._totalReceived.isGreaterThanOrEqualTo(limit)) {
                        cleanup();
                        resolve();
                    }
                }
                function endHandler() {
                    setImmediate(cleanup);
                    if (self._totalReceived.isGreaterThanOrEqualTo(limit)) {
                        resolve();
                    }
                    else {
                        self.log.debug(`Stream was closed before the desired amount was received (target: ${limit}, totalReceived: ${self._totalReceived})`);
                        reject(new Error(`Stream was closed before the desired amount was received (target: ${limit}, totalReceived: ${self._totalReceived})`));
                    }
                }
                function errorHandler(err) {
                    self.log.debug('error waiting for stream to stabilize:', err);
                    cleanup();
                    reject(new Error(`Stream encountered an error before the desired amount was received (target: ${limit}, totalReceived: ${self._totalReceived}): ${err}`));
                }
                const timer = setTimeout(() => {
                    cleanup();
                    reject(new Error(`Timed out before the desired amount was received (target: ${limit}, totalReceived: ${self._totalReceived})`));
                }, timeout);
                function cleanup() {
                    clearTimeout(timer);
                    self.removeListener('money', moneyHandler);
                    self.removeListener('error', errorHandler);
                    self.removeListener('end', endHandler);
                }
                this.on('money', moneyHandler);
                this.on('error', errorHandler);
                this.on('end', endHandler);
            });
        });
    }
    _getAmountStreamCanReceive() {
        return this._receiveMax.minus(this._totalReceived);
    }
    _addToIncoming(amount) {
        this._totalReceived = this._totalReceived.plus(amount);
        this.log.trace(`received ${amount} (totalReceived: ${this._totalReceived})`);
        this.emit('money', amount.toString());
    }
    _getAmountAvailableToSend() {
        if (this.closed) {
            return new bignumber_js_1.default(0);
        }
        const amountAvailable = this._sendMax.minus(this._totalSent).minus(this._outgoingHeldAmount);
        return bignumber_js_1.default.maximum(amountAvailable, 0);
    }
    _holdOutgoing(holdId, maxAmount) {
        const amountAvailable = this._getAmountAvailableToSend();
        const amountToHold = (maxAmount ? bignumber_js_1.default.minimum(amountAvailable, maxAmount) : amountAvailable);
        if (amountToHold.isGreaterThan(0)) {
            this._outgoingHeldAmount = this._outgoingHeldAmount.plus(amountToHold);
            this.holds[holdId] = amountToHold;
            this.log.trace(`holding outgoing balance. holdId: ${holdId}, amount: ${amountToHold}`);
        }
        return amountToHold;
    }
    _executeHold(holdId) {
        if (!this.holds[holdId]) {
            return;
        }
        const amount = this.holds[holdId];
        this._outgoingHeldAmount = this._outgoingHeldAmount.minus(amount);
        this._totalSent = this._totalSent.plus(amount);
        delete this.holds[holdId];
        this.log.trace(`executed holdId: ${holdId} for: ${amount}`);
        this.emit('outgoing_money', amount.toString());
        if (this._totalSent.isGreaterThanOrEqualTo(this._sendMax)) {
            this.log.debug('outgoing total sent');
            this.emit('outgoing_total_sent');
        }
    }
    _cancelHold(holdId) {
        if (!this.holds[holdId]) {
            return;
        }
        const amount = this.holds[holdId];
        this.log.trace(`cancelled holdId: ${holdId} for: ${amount}`);
        this._outgoingHeldAmount = this._outgoingHeldAmount.minus(amount);
        delete this.holds[holdId];
    }
    _final(callback) {
        this.log.info('stream is closing');
        if (!this._sentEnd && !this._remoteSentEnd) {
            this.log.trace('starting another send loop to tell the peer the stream was closed');
            this.emit('_maybe_start_send_loop');
        }
        const finish = (err) => {
            if (err) {
                this.log.debug(`error waiting for money to be sent:`, err);
            }
            this.log.info('stream ended');
            this.closed = true;
            setImmediate(() => {
                if (!this.emittedEnd) {
                    this.emittedEnd = true;
                    this.safeEmit('end');
                }
                if (!this.emittedClose) {
                    this.emittedClose = true;
                    this.safeEmit('close');
                }
            });
            callback(err);
        };
        if (this._remoteSentEnd || this._sendMax.isLessThanOrEqualTo(this._totalSent)) {
            finish();
        }
        else {
            this.log.info('waiting to finish sending money before ending stream');
            new Promise((resolve, reject) => {
                this.once('outgoing_total_sent', resolve);
                this.once('_send_loop_finished', resolve);
                this.once('error', (error) => reject(error));
            })
                .then(() => finish())
                .catch(finish);
        }
    }
    _destroy(error, callback) {
        this.log.error('destroying stream because of error:', error);
        this.closed = true;
        if (error) {
            this._errorMessage = error.message;
        }
        setImmediate(() => {
            if (!this.emittedEnd) {
                this.emittedEnd = true;
                this.safeEmit('end');
            }
            if (!this.emittedClose) {
                this.emittedClose = true;
                this.safeEmit('close');
            }
        });
        callback(error);
    }
    _write(chunk, encoding, callback) {
        this.log.trace(`${chunk.length} bytes written to the outgoing data queue`);
        this._outgoingData.push(chunk, callback);
        this.emit('_maybe_start_send_loop');
    }
    _writev(chunks, callback) {
        for (let i = 0; i < chunks.length; i++) {
            const chunk = chunks[i];
            this.log.trace(`${chunk.chunk.length} bytes written to the outgoing data queue`);
            if (i === chunks.length - 1) {
                this._outgoingData.push(chunk.chunk, callback);
            }
            else {
                this._outgoingData.push(chunk.chunk);
            }
        }
        this.emit('_maybe_start_send_loop');
    }
    _read(size) {
        const data = this._incomingData.read();
        if (!data) {
            if (this['readableFlowing'] !== true) {
                process.nextTick(() => this.emit('_maybe_start_send_loop'));
            }
            return;
        }
        this.push(data);
        if (data.length < size) {
            this._read(size - data.length);
        }
    }
    _hasDataToSend() {
        return !this._outgoingData.isEmpty() || this._outgoingDataToRetry.length > 0;
    }
    _getAvailableDataToSend(size) {
        if (this._outgoingDataToRetry.length > 0) {
            const toSend = this._outgoingDataToRetry[0];
            if (toSend.data.length > size) {
                const data = toSend.data.slice(0, size);
                const offset = toSend.offset;
                toSend.data = toSend.data.slice(size);
                toSend.offset = toSend.offset + size;
                return { data, offset };
            }
            else {
                return this._outgoingDataToRetry.shift();
            }
        }
        const maxBytes = Math.min(size, this._remoteMaxOffset - this.outgoingOffset);
        const offset = this.outgoingOffset;
        const data = this._outgoingData.read(maxBytes);
        if (data && data.length > 0) {
            this.outgoingOffset += data.length;
            this.log.trace(`${data.length} bytes taken from the outgoing data queue`);
        }
        return { data, offset };
    }
    _resendOutgoingData(data, offset) {
        this.log.trace(`re-queuing ${data.length} bytes of data starting at offset ${offset}`);
        this._outgoingDataToRetry.push({ data, offset });
    }
    _isDataBlocked() {
        if (this._remoteMaxOffset < this.outgoingOffset + this._outgoingData.byteLength()) {
            return this.outgoingOffset + this._outgoingData.byteLength();
        }
    }
    _getOutgoingOffsets() {
        return {
            current: this.outgoingOffset,
            max: this.outgoingOffset + this._outgoingData.byteLength()
        };
    }
    _getIncomingOffsets() {
        return {
            max: this._incomingData.maxOffset,
            current: this._incomingData.readOffset,
            maxAcceptable: this._incomingData.readOffset + this.readableHighWaterMark - this.readableLength
        };
    }
    _pushIncomingData(data, offset) {
        this._incomingData.push(data, offset);
        this._read(this.readableHighWaterMark - this.readableLength);
    }
    _remoteEnded(err) {
        this.log.info('remote closed stream');
        this._remoteSentEnd = true;
        this._remoteClosed = true;
        if (err) {
            this.destroy(err);
        }
        else {
            this.push(null);
            this.end();
        }
    }
    safeEmit(event, ...args) {
        try {
            args.unshift(event);
            this.emit.apply(this, args);
        }
        catch (err) {
            this.log.debug(`error in ${event} handler:`, err);
        }
    }
}
exports.DataAndMoneyStream = DataAndMoneyStream;
//# sourceMappingURL=stream.js.map