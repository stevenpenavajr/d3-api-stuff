"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const ilp_logger_1 = require("ilp-logger");
const stream_1 = require("./stream");
const IlpPacket = require("ilp-packet");
const cryptoHelper = require("./crypto");
const packet_1 = require("./packet");
const oer_utils_1 = require("oer-utils");
const bignumber_js_1 = require("bignumber.js");
require('source-map-support').install();
const RETRY_DELAY_START = 100;
const RETRY_DELAY_MAX = 43200000;
const RETRY_DELAY_INCREASE_FACTOR = 1.5;
const DEFAULT_PACKET_TIMEOUT = 30000;
const DEFAULT_IDLE_TIMEOUT = 60000;
const MAX_DATA_SIZE = 32767;
const DEFAULT_MAX_REMOTE_STREAMS = 10;
const DEFAULT_MINIMUM_EXCHANGE_RATE_PRECISION = 3;
const TEST_PACKET_MAX_ATTEMPTS = 20;
class ConnectionError extends Error {
    constructor(message, streamErrorCode) {
        super(message);
        this.streamErrorCode = streamErrorCode || packet_1.ErrorCode.InternalError;
    }
}
exports.ConnectionError = ConnectionError;
class Connection extends events_1.EventEmitter {
    constructor(opts) {
        super();
        this.plugin = opts.plugin;
        this._sourceAccount = opts.sourceAccount;
        this._sourceAssetCode = opts.assetCode;
        this._sourceAssetScale = opts.assetScale;
        this._destinationAccount = opts.destinationAccount;
        this.sharedSecret = opts.sharedSecret;
        this.isServer = opts.isServer;
        this.slippage = new bignumber_js_1.default(opts.slippage || 0);
        this.allowableReceiveExtra = new bignumber_js_1.default(1.01);
        this.enablePadding = !!opts.enablePadding;
        this.connectionTag = opts.connectionTag;
        this.maxStreamId = 2 * (opts.maxRemoteStreams || DEFAULT_MAX_REMOTE_STREAMS);
        this.maxBufferedData = opts.connectionBufferSize || MAX_DATA_SIZE * 2;
        this.minExchangeRatePrecision = opts.minExchangeRatePrecision || DEFAULT_MINIMUM_EXCHANGE_RATE_PRECISION;
        this.idleTimeout = opts.idleTimeout || DEFAULT_IDLE_TIMEOUT;
        this.lastActive = new Date();
        this.nextPacketSequence = 1;
        this.streams = new Map();
        this.closedStreams = {};
        this.nextStreamId = (this.isServer ? 2 : 1);
        this.log = ilp_logger_1.default(`ilp-protocol-stream:${this.isServer ? 'Server' : 'Client'}:Connection`);
        this.sending = false;
        this.closed = true;
        this.queuedFrames = [];
        this.maximumPacketAmount = new bignumber_js_1.default(Infinity);
        this.testMaximumPacketAmount = new bignumber_js_1.default(Infinity);
        this.retryDelay = RETRY_DELAY_START;
        this.remoteClosed = false;
        this.remoteKnowsOurAccount = this.isServer;
        this.remoteMaxStreamId = DEFAULT_MAX_REMOTE_STREAMS * 2;
        this.remoteMaxOffset = this.maxBufferedData;
        this._totalReceived = new bignumber_js_1.default(0);
        this._totalSent = new bignumber_js_1.default(0);
        this._totalDelivered = new bignumber_js_1.default(0);
        this._lastPacketExchangeRate = new bignumber_js_1.default(0);
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.closed) {
                return Promise.resolve();
            }
            this.startSendLoop();
            yield new Promise((resolve, reject) => {
                const connectHandler = () => {
                    cleanup();
                    resolve();
                };
                const closeHandler = () => {
                    cleanup();
                    reject(new Error('Connection was closed before it was connected'));
                };
                const errorHandler = (error) => {
                    cleanup();
                    reject(new Error(`Error connecting${error ? ': ' + error.message : ''}`));
                };
                this.once('connect', connectHandler);
                this.once('error', errorHandler);
                this.once('close', closeHandler);
                this.once('end', closeHandler);
                const self = this;
                function cleanup() {
                    clearTimeout(self.idleTimer);
                    self.removeListener('connect', connectHandler);
                    self.removeListener('error', errorHandler);
                    self.removeListener('close', closeHandler);
                    self.removeListener('end', closeHandler);
                }
            });
            this.closed = false;
            this.startIdleTimer();
        });
    }
    end() {
        return __awaiter(this, void 0, void 0, function* () {
            this.log.info('closing connection');
            let streamEndPromises = [];
            for (let [_, stream] of this.streams) {
                if (stream.isOpen()) {
                    streamEndPromises.push(new Promise((resolve, reject) => {
                        stream.on('end', resolve);
                    }));
                    stream.end();
                }
            }
            yield new Promise((resolve, reject) => {
                this.once('_send_loop_finished', resolve);
                this.once('error', reject);
                this.startSendLoop();
            });
            yield Promise.all(streamEndPromises);
            this.closed = true;
            yield this.sendConnectionClose();
            this.safeEmit('end');
            this.safeEmit('close');
        });
    }
    destroy(err) {
        return __awaiter(this, void 0, void 0, function* () {
            this.log.error('destroying connection with error:', err);
            if (err) {
                this.safeEmit('error', err);
            }
            let streamClosePromises = [];
            for (let [_, stream] of this.streams) {
                streamClosePromises.push(new Promise((resolve, reject) => {
                    stream.on('close', resolve);
                }));
                stream.destroy();
            }
            yield this.sendConnectionClose(err);
            yield Promise.all(streamClosePromises);
            this.safeEmit('close');
        });
    }
    createStream() {
        if (this.remoteMaxStreamId < this.nextStreamId) {
            this.log.debug(`cannot create another stream. nextStreamId: ${this.nextStreamId}, remote maxStreamId: ${this.remoteMaxStreamId}`);
            this.queuedFrames.push(new packet_1.ConnectionStreamIdBlockedFrame(this.nextStreamId));
            throw new Error(`Creating another stream would exceed the remote connection's maximum number of open streams`);
        }
        const stream = new stream_1.DataAndMoneyStream({
            id: this.nextStreamId,
            isServer: this.isServer
        });
        this.streams.set(this.nextStreamId, stream);
        this.log.debug(`created stream: ${this.nextStreamId}`);
        this.nextStreamId += 2;
        stream.on('_maybe_start_send_loop', this.startSendLoop.bind(this));
        stream.once('close', () => this.removeStreamRecord(stream));
        return stream;
    }
    get destinationAccount() {
        return this._destinationAccount;
    }
    get destinationAssetScale() {
        return this._destinationAssetScale;
    }
    get destinationAssetCode() {
        return this._destinationAssetCode;
    }
    get sourceAccount() {
        return this._sourceAccount;
    }
    get sourceAssetScale() {
        return this._sourceAssetScale;
    }
    get sourceAssetCode() {
        return this._sourceAssetCode;
    }
    get minimumAcceptableExchangeRate() {
        if (this.exchangeRate) {
            const minimumExchangeWithSlippage = this.exchangeRate
                .times(new bignumber_js_1.default(1).minus(this.slippage));
            return minimumExchangeWithSlippage.toString();
        }
        return '0';
    }
    get lastPacketExchangeRate() {
        return this._lastPacketExchangeRate.toString();
    }
    get totalDelivered() {
        return this._totalDelivered.toString();
    }
    get totalSent() {
        return this._totalSent.toString();
    }
    get totalReceived() {
        return this._totalReceived.toString();
    }
    handlePrepare(prepare) {
        return __awaiter(this, void 0, void 0, function* () {
            let requestPacket;
            try {
                requestPacket = packet_1.Packet.decryptAndDeserialize(this.sharedSecret, prepare.data);
            }
            catch (err) {
                this.log.error(`error parsing frames:`, err);
                throw new IlpPacket.Errors.UnexpectedPaymentError('');
            }
            this.log.trace('handling packet:', JSON.stringify(requestPacket));
            if (requestPacket.ilpPacketType.valueOf() !== IlpPacket.Type.TYPE_ILP_PREPARE) {
                this.log.error(`prepare packet contains a frame that says it should be something other than a prepare: ${requestPacket.ilpPacketType}`);
                throw new IlpPacket.Errors.UnexpectedPaymentError('');
            }
            this.bumpIdle();
            let responseFrames = [];
            responseFrames.push(new packet_1.ConnectionMaxDataFrame(this.getIncomingOffsets().maxAcceptable));
            const throwFinalApplicationError = () => {
                responseFrames = responseFrames.concat(this.queuedFrames);
                this.queuedFrames = [];
                const responsePacket = new packet_1.Packet(requestPacket.sequence, packet_1.IlpPacketType.Reject, prepare.amount, responseFrames);
                this.log.trace(`rejecting packet ${requestPacket.sequence}: ${JSON.stringify(responsePacket)}`);
                throw new IlpPacket.Errors.FinalApplicationError('', responsePacket.serializeAndEncrypt(this.sharedSecret, (this.enablePadding ? MAX_DATA_SIZE : undefined)));
            };
            for (let frame of requestPacket.frames) {
                if (frame.type === packet_1.FrameType.StreamMoney
                    || frame.type === packet_1.FrameType.StreamData
                    || frame.type === packet_1.FrameType.StreamMaxMoney
                    || frame.type === packet_1.FrameType.StreamMaxData) {
                    const streamId = frame.streamId.toNumber();
                    if (this.closedStreams[streamId]) {
                        this.log.trace(`got packet with frame for stream ${streamId}, which was already closed`);
                        if (frame.type !== packet_1.FrameType.StreamMoney && frame.type !== packet_1.FrameType.StreamData) {
                            continue;
                        }
                        const framesToSend = responseFrames.concat(this.queuedFrames);
                        const includesStreamClose = framesToSend.find((frame) => frame.type === packet_1.FrameType.StreamClose && frame.streamId.isEqualTo(streamId));
                        if (!includesStreamClose) {
                            responseFrames.push(new packet_1.StreamCloseFrame(streamId, packet_1.ErrorCode.StreamStateError, 'Stream is already closed'));
                        }
                        throwFinalApplicationError();
                    }
                    try {
                        this.handleNewStream(frame.streamId.toNumber());
                    }
                    catch (err) {
                        this.log.debug(`error handling new stream ${frame.streamId}:`, err && err.message);
                        throwFinalApplicationError();
                    }
                }
            }
            try {
                this.handleControlFrames(requestPacket.frames);
            }
            catch (err) {
                this.log.debug('error handling frames:', err && err.message);
                throwFinalApplicationError();
            }
            const incomingOffsets = this.getIncomingOffsets();
            if (incomingOffsets.max > incomingOffsets.maxAcceptable) {
                this.destroy(new ConnectionError(`Exceeded flow control limits. Max connection byte offset: ${incomingOffsets.maxAcceptable}, received: ${incomingOffsets.max}`, packet_1.ErrorCode.FlowControlError));
                throwFinalApplicationError();
            }
            if (requestPacket.prepareAmount.isGreaterThan(prepare.amount)) {
                this.log.debug(`received less than minimum destination amount. actual: ${prepare.amount}, expected: ${requestPacket.prepareAmount}`);
                throwFinalApplicationError();
            }
            const fulfillment = cryptoHelper.generateFulfillment(this.sharedSecret, prepare.data);
            const generatedCondition = cryptoHelper.hash(fulfillment);
            if (!generatedCondition.equals(prepare.executionCondition)) {
                this.log.debug(`got unfulfillable prepare for amount: ${prepare.amount}. generated condition: ${generatedCondition.toString('hex')}, prepare condition: ${prepare.executionCondition.toString('hex')}`);
                throwFinalApplicationError();
            }
            const amountsToReceive = [];
            const totalMoneyShares = requestPacket.frames.reduce((sum, frame) => {
                if (frame instanceof packet_1.StreamMoneyFrame) {
                    return sum.plus(frame.shares);
                }
                return sum;
            }, new bignumber_js_1.default(0));
            for (let frame of requestPacket.frames) {
                if (!(frame instanceof packet_1.StreamMoneyFrame)) {
                    continue;
                }
                const streamId = frame.streamId.toNumber();
                const streamAmount = new bignumber_js_1.default(prepare.amount)
                    .times(frame.shares)
                    .dividedBy(totalMoneyShares)
                    .integerValue(bignumber_js_1.default.ROUND_FLOOR);
                const stream = this.streams.get(streamId);
                amountsToReceive.push({
                    stream,
                    amount: streamAmount
                });
                const maxStreamCanReceive = stream._getAmountStreamCanReceive()
                    .times(this.allowableReceiveExtra)
                    .integerValue(bignumber_js_1.default.ROUND_CEIL);
                if (maxStreamCanReceive.isLessThan(streamAmount)) {
                    this.log.debug(`peer sent too much for stream: ${streamId}. got: ${streamAmount}, max receivable: ${maxStreamCanReceive}`);
                    responseFrames.push(new packet_1.StreamMaxMoneyFrame(streamId, stream.receiveMax, stream.totalReceived));
                    throwFinalApplicationError();
                }
                if (!stream.isOpen()) {
                    this.log.debug(`peer sent money for stream that was already closed: ${streamId}`);
                    responseFrames.push(new packet_1.StreamCloseFrame(streamId, packet_1.ErrorCode.StreamStateError, 'Stream is already closed'));
                    throwFinalApplicationError();
                }
            }
            for (let { stream, amount } of amountsToReceive) {
                stream._addToIncoming(amount);
            }
            if (!this.closed && !this.remoteClosed) {
                for (let [_, stream] of this.streams) {
                    if (!stream.isOpen() && !stream._remoteClosed) {
                        this.log.trace(`telling other side that stream ${stream.id} is closed`);
                        if (stream._errorMessage) {
                            responseFrames.push(new packet_1.StreamCloseFrame(stream.id, packet_1.ErrorCode.ApplicationError, stream._errorMessage));
                        }
                        else {
                            responseFrames.push(new packet_1.StreamCloseFrame(stream.id, packet_1.ErrorCode.NoError, ''));
                        }
                        stream._remoteClosed = true;
                    }
                    else {
                        this.log.trace(`telling other side that stream ${stream.id} can receive ${stream.receiveMax}`);
                        responseFrames.push(new packet_1.StreamMaxMoneyFrame(stream.id, stream.receiveMax, stream.totalReceived));
                        responseFrames.push(new packet_1.StreamMaxDataFrame(stream.id, stream._getIncomingOffsets().maxAcceptable));
                    }
                }
            }
            responseFrames = responseFrames.concat(this.queuedFrames);
            this.queuedFrames = [];
            const responsePacket = new packet_1.Packet(requestPacket.sequence, packet_1.IlpPacketType.Fulfill, prepare.amount, responseFrames);
            this._totalReceived = this._totalReceived.plus(prepare.amount);
            this.log.trace(`fulfilling prepare with fulfillment: ${fulfillment.toString('hex')} and response packet: ${JSON.stringify(responsePacket)}`);
            return {
                fulfillment,
                data: responsePacket.serializeAndEncrypt(this.sharedSecret, (this.enablePadding ? MAX_DATA_SIZE : undefined))
            };
        });
    }
    handleControlFrames(frames) {
        for (let frame of frames) {
            let stream;
            switch (frame.type) {
                case packet_1.FrameType.ConnectionNewAddress:
                    this.log.trace(`peer notified us of their account: ${frame.sourceAccount}`);
                    const firstConnection = this._destinationAccount === undefined;
                    this._destinationAccount = frame.sourceAccount;
                    if (firstConnection) {
                        this.handleConnect();
                    }
                    break;
                case packet_1.FrameType.ConnectionAssetDetails:
                    this.log.trace(`peer notified us of their asset details: code=${frame.sourceAssetCode}, scale=${frame.sourceAssetScale}`);
                    this._destinationAssetCode = frame.sourceAssetCode;
                    this._destinationAssetScale = frame.sourceAssetScale;
                    break;
                case packet_1.FrameType.ConnectionClose:
                    this.sending = false;
                    this.closed = true;
                    this.remoteClosed = true;
                    if (frame.errorCode === packet_1.ErrorCode.NoError) {
                        this.log.info(`remote closed connection`);
                        this.end();
                    }
                    else {
                        this.log.error(`remote connection error. code: ${packet_1.ErrorCode[frame.errorCode]}, message: ${frame.errorMessage}`);
                        this.destroy(new Error(`Remote connection error. Code: ${packet_1.ErrorCode[frame.errorCode]}, message: ${frame.errorMessage}`));
                    }
                    break;
                case packet_1.FrameType.ConnectionMaxData:
                    const outgoingOffsets = this.getOutgoingOffsets();
                    this.log.trace(`remote connection max byte offset is: ${frame.maxOffset}, we've sent: ${outgoingOffsets.currentOffset}, we want to send up to: ${outgoingOffsets.maxOffset}`);
                    if (frame.maxOffset.isGreaterThan(MAX_DATA_SIZE * 2)) {
                        this.remoteMaxOffset = Math.max(frame.maxOffset.toNumber(), this.remoteMaxOffset);
                    }
                    else {
                        this.remoteMaxOffset = frame.maxOffset.toNumber();
                    }
                    break;
                case packet_1.FrameType.ConnectionDataBlocked:
                    this.log.trace(`remote wants to send more data but we are blocking them. current max incoming offset: ${this.getIncomingOffsets()}, remote max offset: ${frame.maxOffset}`);
                    break;
                case packet_1.FrameType.ConnectionMaxStreamId:
                    this.log.trace(`remote set max stream id to ${frame.maxStreamId}`);
                    this.remoteMaxStreamId = frame.maxStreamId.toNumber();
                    break;
                case packet_1.FrameType.ConnectionStreamIdBlocked:
                    this.log.trace(`remote wants to open more streams but we are blocking them`);
                    break;
                case packet_1.FrameType.StreamClose:
                    this.handleStreamClose(frame);
                    break;
                case packet_1.FrameType.StreamMaxMoney:
                    this.log.trace(`peer told us that stream ${frame.streamId} can receive up to: ${frame.receiveMax} and has received: ${frame.totalReceived} so far`);
                    stream = this.streams.get(frame.streamId.toNumber());
                    if (!stream) {
                        break;
                    }
                    stream._remoteReceived = bignumber_js_1.default.maximum(stream._remoteReceived, frame.totalReceived);
                    if (stream._remoteReceiveMax.isFinite()) {
                        stream._remoteReceiveMax = bignumber_js_1.default.maximum(stream._remoteReceiveMax, frame.receiveMax);
                    }
                    else {
                        stream._remoteReceiveMax = frame.receiveMax;
                    }
                    if (stream._remoteReceiveMax.isGreaterThan(stream._remoteReceived)
                        && stream._getAmountAvailableToSend().isGreaterThan(0)) {
                        this.startSendLoop();
                    }
                    break;
                case packet_1.FrameType.StreamMoneyBlocked:
                    this.log.debug(`peer told us that they want to send more money on stream ${frame.streamId} but we are blocking them. they have sent: ${frame.totalSent} so far and want to send: ${frame.sendMax}`);
                    break;
                case packet_1.FrameType.StreamData:
                    this.log.trace(`got data for stream ${frame.streamId}`);
                    stream = this.streams.get(frame.streamId.toNumber());
                    if (!stream) {
                        break;
                    }
                    stream._pushIncomingData(frame.data, frame.offset.toNumber());
                    const incomingOffsets = stream._getIncomingOffsets();
                    if (incomingOffsets.max > incomingOffsets.maxAcceptable) {
                        this.destroy(new ConnectionError(`Exceeded flow control limits. Stream ${stream.id} can accept up to offset: ${incomingOffsets.maxAcceptable} but got bytes up to offset: ${incomingOffsets.max}`, packet_1.ErrorCode.FlowControlError));
                    }
                    break;
                case packet_1.FrameType.StreamMaxData:
                    stream = this.streams.get(frame.streamId.toNumber());
                    if (!stream) {
                        break;
                    }
                    const oldOffset = stream._remoteMaxOffset;
                    const newOffset = frame.maxOffset.toNumber();
                    if (newOffset > oldOffset) {
                        this.log.trace(`peer told us that stream ${frame.streamId} can receive up to byte offset: ${frame.maxOffset} (we've sent up to offset: ${stream._getOutgoingOffsets().current})`);
                        stream._remoteMaxOffset = newOffset;
                        this.startSendLoop();
                    }
                    else {
                        this.log.trace(`peer told us that stream ${frame.streamId} can receive up to byte offset: ${oldOffset}; ignoring new offset: ${newOffset}`);
                    }
                    break;
                case packet_1.FrameType.StreamDataBlocked:
                    stream = this.streams.get(frame.streamId.toNumber());
                    if (!stream) {
                        break;
                    }
                    this.log.debug(`peer told us that stream ${frame.streamId} is blocked. they want to send up to offset: ${frame.maxOffset}, but we are only allowing up to: ${stream._getIncomingOffsets().maxAcceptable}`);
                    break;
                default:
                    continue;
            }
        }
    }
    handleConnect() {
        this.closed = false;
        this.log.info('connected');
        this.safeEmit('connect');
        this.queuedFrames.push(new packet_1.ConnectionMaxStreamIdFrame(this.maxStreamId), new packet_1.ConnectionAssetDetailsFrame(this.sourceAssetCode, this.sourceAssetScale));
    }
    handleNewStream(streamId) {
        if (this.streams.has(streamId) || this.closedStreams[streamId]) {
            return;
        }
        if (this.isServer && streamId % 2 === 0) {
            this.log.error(`got invalid stream ID ${streamId} from peer (should be odd)`);
            this.queuedFrames.push(new packet_1.ConnectionCloseFrame(packet_1.ErrorCode.ProtocolViolation, `Invalid Stream ID: ${streamId}. Client-initiated streams must have odd-numbered IDs`));
            const err = new Error(`Invalid Stream ID: ${streamId}. Client-initiated streams must have odd-numbered IDs`);
            this.safeEmit('error', err);
            throw err;
        }
        else if (!this.isServer && streamId % 2 === 1) {
            this.log.error(`got invalid stream ID ${streamId} from peer (should be even)`);
            this.queuedFrames.push(new packet_1.ConnectionCloseFrame(packet_1.ErrorCode.ProtocolViolation, `Invalid Stream ID: ${streamId}. Server-initiated streams must have even-numbered IDs`));
            const err = new Error(`Invalid Stream ID: ${streamId}. Server-initiated streams must have even-numbered IDs`);
            this.safeEmit('error', err);
            throw err;
        }
        if (streamId > this.maxStreamId) {
            this.log.debug(`peer opened too many streams. got stream: ${streamId}, but max stream id is: ${this.maxStreamId}. closing connection`);
            this.queuedFrames.push(new packet_1.ConnectionCloseFrame(packet_1.ErrorCode.StreamIdError, `Maximum number of open streams exceeded. Got stream: ${streamId}, current max stream ID: ${this.maxStreamId}`));
            const err = new Error(`Maximum number of open streams exceeded. Got stream: ${streamId}, current max stream ID: ${this.maxStreamId}`);
            this.safeEmit('error', err);
            throw err;
        }
        if (this.maxStreamId * .75 < streamId) {
            this.log.trace(`informing peer that our max stream id is: ${this.maxStreamId}`);
            this.queuedFrames.push(new packet_1.ConnectionMaxStreamIdFrame(this.maxStreamId));
        }
        this.log.info(`got new stream: ${streamId}`);
        const stream = new stream_1.DataAndMoneyStream({
            id: streamId,
            isServer: this.isServer
        });
        this.streams.set(streamId, stream);
        stream.on('_maybe_start_send_loop', () => this.startSendLoop());
        stream.once('close', () => this.removeStreamRecord(stream));
        this.safeEmit('stream', stream);
    }
    handleStreamClose(frame) {
        const streamId = frame.streamId.toNumber();
        const stream = this.streams.get(streamId);
        if (!stream) {
            this.log.error(`remote error on stream ${streamId}, but we don't have a record of that stream`);
            return;
        }
        if (!stream.isOpen() || stream._remoteSentEnd) {
            return;
        }
        this.log.error(`peer closed stream ${stream.id} with error code: ${packet_1.ErrorCode[frame.errorCode]} and message: ${frame.errorMessage}`);
        stream._sentEnd = true;
        let err;
        if (frame.errorMessage) {
            err = new Error(frame.errorMessage);
            err.name = packet_1.ErrorCode[frame.errorCode];
        }
        stream._remoteEnded(err);
        this.maxStreamId += 2;
        this.log.trace(`raising maxStreamId to ${this.maxStreamId}`);
        this.queuedFrames.push(new packet_1.ConnectionMaxStreamIdFrame(this.maxStreamId));
        this.startSendLoop();
    }
    startSendLoop() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.sending) {
                return;
            }
            if (this.remoteClosed) {
                this.log.debug('remote connection is already closed, not starting another loop');
                this.safeEmit('_send_loop_finished');
                return;
            }
            if (!this._destinationAccount) {
                this.log.debug('not sending because we do not know the client\'s address');
                return;
            }
            this.sending = true;
            this.log.debug('starting send loop');
            try {
                while (this.sending) {
                    if (!this.exchangeRate) {
                        this.log.trace('determining exchange rate');
                        yield this.determineExchangeRate();
                        if (this.exchangeRate) {
                            this.safeEmit('connect');
                            this.log.trace('connected');
                        }
                        else {
                            this.log.error('unable to determine exchange rate');
                        }
                    }
                    else {
                        yield this.loadAndSendPacket();
                    }
                }
            }
            catch (err) {
                return this.destroy(err);
            }
            this.log.debug('finished sending');
            this.safeEmit('_send_loop_finished');
            for (let [_, stream] of this.streams) {
                stream.emit('_send_loop_finished');
            }
        });
    }
    loadAndSendPacket() {
        return __awaiter(this, void 0, void 0, function* () {
            yield new Promise((resolve, reject) => setImmediate(resolve));
            this.log.trace('loadAndSendPacket');
            let amountToSend = new bignumber_js_1.default(0);
            const requestPacket = new packet_1.Packet(this.nextPacketSequence++, packet_1.IlpPacketType.Prepare);
            requestPacket.frames = this.queuedFrames;
            this.queuedFrames = [];
            for (let [_, stream] of this.streams) {
                if (stream.isOpen()) {
                    requestPacket.frames.push(new packet_1.StreamMaxMoneyFrame(stream.id, stream.receiveMax, stream.totalReceived));
                    requestPacket.frames.push(new packet_1.StreamMaxDataFrame(stream.id, stream._getIncomingOffsets().maxAcceptable));
                }
            }
            if (this.closed && !this.remoteClosed) {
                this.log.trace('sending connection close frame');
                requestPacket.frames.push(new packet_1.ConnectionCloseFrame(packet_1.ErrorCode.NoError, ''));
                this.remoteClosed = true;
            }
            let maxAmountFromNextStream = this.testMaximumPacketAmount;
            const streamsSentFrom = [];
            for (let [_, stream] of this.streams) {
                if (stream._sentEnd) {
                    continue;
                }
                let amountToSendFromStream = bignumber_js_1.default.minimum(stream._getAmountAvailableToSend(), maxAmountFromNextStream);
                if (this.exchangeRate) {
                    const maxDestinationAmount = stream._remoteReceiveMax.minus(stream._remoteReceived);
                    const maxSourceAmount = maxDestinationAmount.dividedBy(this.exchangeRate).integerValue(bignumber_js_1.default.ROUND_CEIL);
                    if (maxSourceAmount.isLessThan(amountToSendFromStream)) {
                        this.log.trace(`stream ${stream.id} could send ${amountToSendFromStream} but that would be more than the receiver says they can receive, so we'll send ${maxSourceAmount} instead`);
                        amountToSendFromStream = maxSourceAmount;
                    }
                }
                this.log.trace(`amount to send from stream ${stream.id}: ${amountToSendFromStream}, exchange rate: ${this.exchangeRate}, remote total received: ${stream._remoteReceived}, remote receive max: ${stream._remoteReceiveMax}`);
                if (amountToSendFromStream.isGreaterThan(0)) {
                    stream._holdOutgoing(requestPacket.sequence.toString(), amountToSendFromStream);
                    requestPacket.frames.push(new packet_1.StreamMoneyFrame(stream.id, amountToSendFromStream));
                    amountToSend = amountToSend.plus(amountToSendFromStream);
                    maxAmountFromNextStream = maxAmountFromNextStream.minus(amountToSendFromStream);
                    streamsSentFrom.push(stream);
                }
                const amountLeftStreamWantsToSend = new bignumber_js_1.default(stream.sendMax).minus(stream.totalSent).minus(amountToSendFromStream);
                if (amountLeftStreamWantsToSend.times(this.exchangeRate).isGreaterThan(stream._remoteReceiveMax.minus(stream._remoteReceived))) {
                    requestPacket.frames.push(new packet_1.StreamMoneyBlockedFrame(stream.id, stream.sendMax, stream.totalSent));
                }
                if (maxAmountFromNextStream.isEqualTo(0)) {
                    break;
                }
            }
            let bytesLeftInPacket = MAX_DATA_SIZE - requestPacket.byteLength();
            const maxBytesRemoteConnectionCanReceive = this.remoteMaxOffset - this.getOutgoingOffsets().currentOffset;
            if (bytesLeftInPacket > maxBytesRemoteConnectionCanReceive) {
                const outgoingMaxOffset = this.getOutgoingOffsets().maxOffset;
                this.log.debug(`peer is blocking us from sending more data. they will only accept up to offset: ${this.remoteMaxOffset}, but we want to send up to: ${outgoingMaxOffset}`);
                requestPacket.frames.push(new packet_1.ConnectionDataBlockedFrame(outgoingMaxOffset));
                bytesLeftInPacket = maxBytesRemoteConnectionCanReceive;
            }
            for (let [_, stream] of this.streams) {
                if (bytesLeftInPacket - 20 <= 0) {
                    break;
                }
                const { data, offset } = stream._getAvailableDataToSend(bytesLeftInPacket - 20);
                if (data && data.length > 0) {
                    const streamDataFrame = new packet_1.StreamDataFrame(stream.id, offset, data);
                    this.log.trace(`sending ${data.length} bytes from stream ${stream.id}`);
                    bytesLeftInPacket -= streamDataFrame.byteLength();
                    requestPacket.frames.push(streamDataFrame);
                }
                const maxOutgoingOffset = stream._isDataBlocked();
                if (maxOutgoingOffset) {
                    this.log.trace(`telling remote that stream ${stream.id} is blocked and has more data to send`);
                    requestPacket.frames.push(new packet_1.StreamDataBlockedFrame(stream.id, maxOutgoingOffset));
                }
            }
            if (amountToSend.isEqualTo(0)) {
                if (requestPacket.frames.length === 0) {
                    this.sending = false;
                    return;
                }
                else {
                    if (!requestPacket.frames.find(frame => ((frame.type === packet_1.FrameType.StreamClose)
                        || (frame.type === packet_1.FrameType.StreamData)
                        || (frame.type === packet_1.FrameType.StreamMoney)))) {
                        this.sending = false;
                    }
                }
            }
            if (this.exchangeRate) {
                const minimumDestinationAmount = amountToSend.times(this.exchangeRate)
                    .times(new bignumber_js_1.default(1).minus(this.slippage))
                    .integerValue(bignumber_js_1.default.ROUND_FLOOR);
                if (minimumDestinationAmount.isGreaterThan(0)) {
                    requestPacket.prepareAmount = minimumDestinationAmount;
                }
            }
            const responsePacket = yield this.sendPacket(requestPacket, amountToSend, false);
            if (responsePacket) {
                this.handleControlFrames(responsePacket.frames);
                if (amountToSend.isGreaterThan(0)) {
                    this._lastPacketExchangeRate = responsePacket.prepareAmount.dividedBy(amountToSend);
                }
                if (responsePacket.ilpPacketType === packet_1.IlpPacketType.Fulfill) {
                    for (let stream of streamsSentFrom) {
                        stream._executeHold(requestPacket.sequence.toString());
                    }
                    this._totalDelivered = this._totalDelivered.plus(responsePacket.prepareAmount);
                    this._totalSent = this._totalSent.plus(amountToSend);
                    if (amountToSend.isEqualTo(this.testMaximumPacketAmount)
                        && this.testMaximumPacketAmount.isLessThan(this.maximumPacketAmount)) {
                        let newTestMax;
                        if (this.maximumPacketAmount.isFinite()) {
                            const additiveIncrease = this.maximumPacketAmount.dividedToIntegerBy(10);
                            newTestMax = bignumber_js_1.default.min(this.testMaximumPacketAmount.plus(additiveIncrease), this.maximumPacketAmount);
                            this.log.trace(`last packet amount was successful (max packet amount: ${this.maximumPacketAmount}), raising packet amount from ${this.testMaximumPacketAmount} to: ${newTestMax}`);
                        }
                        else {
                            newTestMax = this.testMaximumPacketAmount.times(2);
                            this.log.trace(`last packet amount was successful, unknown max packet amount, raising packet amount from: ${this.testMaximumPacketAmount} to: ${newTestMax}`);
                        }
                        this.testMaximumPacketAmount = newTestMax;
                    }
                    this.retryDelay = RETRY_DELAY_START;
                }
            }
        });
    }
    sendTestPacketVolley(testPacketAmounts) {
        return __awaiter(this, void 0, void 0, function* () {
            const results = yield Promise.all(testPacketAmounts.map((amount) => __awaiter(this, void 0, void 0, function* () {
                try {
                    return this.sendTestPacket(new bignumber_js_1.default(amount));
                }
                catch (err) {
                    this.log.error(`Error sending test packet for amount ${amount}:`, err);
                    return null;
                }
            })));
            const maxPacketAmounts = testPacketAmounts.map((sourceAmount, index) => {
                if (results[index] && results[index].code === 'F08') {
                    try {
                        const reader = oer_utils_1.Reader.from(results[index].data);
                        const receivedAmount = reader.readUInt64BigNum();
                        const maximumAmount = reader.readUInt64BigNum();
                        const maximumPacketAmount = new bignumber_js_1.default(sourceAmount)
                            .times(maximumAmount)
                            .dividedToIntegerBy(receivedAmount);
                        this.log.debug(`sending test packet of ${testPacketAmounts[index]} resulted in F08 error that told us maximum packet amount is ${maximumPacketAmount}`);
                        return maximumPacketAmount;
                    }
                    catch (err) {
                        return new bignumber_js_1.default(Infinity);
                    }
                }
                return new bignumber_js_1.default(Infinity);
            });
            const { maxDigits, exchangeRate, packetErrors } = results.reduce(({ maxDigits, exchangeRate, packetErrors }, result, index) => {
                if (result && result.code) {
                    packetErrors.push(result.code);
                }
                if (result && result.prepareAmount) {
                    const prepareAmount = result.prepareAmount;
                    const exchangeRate = prepareAmount.dividedBy(testPacketAmounts[index]);
                    this.log.debug(`sending test packet of ${testPacketAmounts[index]} delivered ${prepareAmount} (exchange rate: ${exchangeRate})`);
                    if (prepareAmount.precision(true) >= maxDigits) {
                        return {
                            maxDigits: prepareAmount.precision(true),
                            exchangeRate,
                            packetErrors
                        };
                    }
                }
                return { maxDigits, exchangeRate, packetErrors };
            }, { maxDigits: 0, exchangeRate: new bignumber_js_1.default(0), packetErrors: [] });
            return { maxDigits, exchangeRate, maxPacketAmounts, packetErrors };
        });
    }
    determineExchangeRate() {
        return __awaiter(this, void 0, void 0, function* () {
            this.log.trace('determineExchangeRate');
            if (!this._destinationAccount) {
                throw new Error('Cannot determine exchange rate. Destination account is unknown');
            }
            let retryDelay = RETRY_DELAY_START;
            let testPacketAmounts = [1, 1000, 1000000, 1000000000, 1000000000000];
            let attempts = 0;
            while (!this.exchangeRate && testPacketAmounts.length > 0 && attempts < TEST_PACKET_MAX_ATTEMPTS) {
                attempts++;
                const { maxDigits, exchangeRate, maxPacketAmounts, packetErrors } = yield this.sendTestPacketVolley(testPacketAmounts);
                this.maximumPacketAmount = bignumber_js_1.default.minimum(...maxPacketAmounts.concat(this.maximumPacketAmount));
                this.testMaximumPacketAmount = this.maximumPacketAmount;
                if (this.maximumPacketAmount.isEqualTo(0)) {
                    this.log.error(`cannot send anything through this path. the maximum packet amount is 0`);
                    throw new Error('Cannot send. Path has a Maximum Packet Amount of 0');
                }
                if (maxDigits >= this.minExchangeRatePrecision) {
                    this.log.debug(`determined exchange rate to be ${exchangeRate} with ${maxDigits} digits precision`);
                    this.exchangeRate = exchangeRate;
                    return;
                }
                const smallestPacketAmount = testPacketAmounts.reduce((min, amount) => bignumber_js_1.default.min(min, new bignumber_js_1.default(amount)), new bignumber_js_1.default(Infinity));
                testPacketAmounts = maxPacketAmounts
                    .filter((amount) => !amount.isEqualTo(new bignumber_js_1.default(Infinity)))
                    .reduce((acc, curr) => [...new Set([...acc, curr.toString()])], []);
                if (packetErrors.some((code) => code[0] === 'T')) {
                    const reducedPacketAmount = smallestPacketAmount.minus(smallestPacketAmount.dividedToIntegerBy(3));
                    this.log.debug(`got Txx error(s), waiting ${retryDelay}ms and reducing packet amount to ${reducedPacketAmount} before sending another test packet`);
                    testPacketAmounts = [...testPacketAmounts, reducedPacketAmount];
                    yield new Promise((resolve, reject) => setTimeout(resolve, retryDelay));
                    retryDelay *= RETRY_DELAY_INCREASE_FACTOR;
                }
                this.log.debug(`retry with packet amounts ${testPacketAmounts}`);
            }
            throw new Error(`Unable to establish connection, no packets meeting the minimum exchange precision of ${this.minExchangeRatePrecision} digits made it through the path.`);
        });
    }
    sendTestPacket(amount, timeout = DEFAULT_PACKET_TIMEOUT) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestPacket = new packet_1.Packet(this.nextPacketSequence++, packet_1.IlpPacketType.Prepare);
            this.log.trace(`sending test packet ${requestPacket.sequence} for amount: ${amount}. timeout: ${timeout}`);
            if (!this.remoteKnowsOurAccount) {
                requestPacket.frames.push(new packet_1.ConnectionNewAddressFrame(this._sourceAccount));
                requestPacket.frames.push(new packet_1.ConnectionAssetDetailsFrame(this._sourceAssetCode, this._sourceAssetScale));
            }
            const prepare = {
                destination: this._destinationAccount,
                amount: amount.toString(),
                data: requestPacket.serializeAndEncrypt(this.sharedSecret),
                executionCondition: cryptoHelper.generateRandomCondition(),
                expiresAt: new Date(Date.now() + timeout)
            };
            const responseData = yield new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                const timer = setTimeout(() => {
                    this.log.error(`test packet ${requestPacket.sequence} timed out before we got a response`);
                    resolve(null);
                }, timeout);
                const result = yield this.plugin.sendData(IlpPacket.serializeIlpPrepare(prepare));
                clearTimeout(timer);
                resolve(result);
            }));
            if (!responseData) {
                return null;
            }
            this.bumpIdle();
            const ilpReject = IlpPacket.deserializeIlpReject(responseData);
            let responsePacket;
            if (ilpReject.code === 'F99' && ilpReject.data.length > 0) {
                responsePacket = packet_1.Packet.decryptAndDeserialize(this.sharedSecret, ilpReject.data);
                if (!responsePacket.sequence.isEqualTo(requestPacket.sequence)) {
                    this.log.error(`response packet sequence does not match the request packet. expected sequence: ${requestPacket.sequence}, got response packet:`, JSON.stringify(responsePacket));
                    throw new Error(`Response packet sequence does not correspond to the request. Actual: ${responsePacket.sequence}, expected: ${requestPacket.sequence}`);
                }
                if (responsePacket.ilpPacketType !== responseData[0]) {
                    this.log.error(`response packet was on wrong ILP packet type. expected ILP packet type: ${responseData[0]}, got:`, JSON.stringify(responsePacket));
                    throw new Error(`Response says it should be on an ILP packet of type: ${responsePacket.ilpPacketType} but it was carried on an ILP packet of type: ${responseData[0]}`);
                }
            }
            else {
                this.log.debug(`test packet ${requestPacket.sequence} was rejected with a ${ilpReject.code} triggered by ${ilpReject.triggeredBy} error${ilpReject.message ? ' with the message: "' + ilpReject.message + '"' : ''}`);
            }
            if (responsePacket) {
                this.remoteKnowsOurAccount = true;
                this.handleControlFrames(responsePacket.frames);
                return responsePacket;
            }
            else {
                return ilpReject;
            }
        });
    }
    sendConnectionClose(err) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.remoteClosed) {
                this.log.debug('not sending connection error because remote is already closed');
                return;
            }
            let errorCode;
            let errorMessage;
            if (err && err instanceof ConnectionError) {
                errorCode = err.streamErrorCode;
                errorMessage = err.message;
            }
            else if (err) {
                errorCode = packet_1.ErrorCode.InternalError;
                errorMessage = err.message;
            }
            else {
                errorCode = packet_1.ErrorCode.NoError;
                errorMessage = '';
            }
            const packet = new packet_1.Packet(this.nextPacketSequence, packet_1.IlpPacketType.Prepare, 0, [
                new packet_1.ConnectionCloseFrame(errorCode, errorMessage)
            ]);
            try {
                const prepare = {
                    destination: this._destinationAccount,
                    amount: '0',
                    data: packet.serializeAndEncrypt(this.sharedSecret),
                    executionCondition: cryptoHelper.generateRandomCondition(),
                    expiresAt: new Date(Date.now() + DEFAULT_PACKET_TIMEOUT)
                };
                yield this.plugin.sendData(IlpPacket.serializeIlpPrepare(prepare));
            }
            catch (err) {
                this.log.error(`error while trying to inform peer that connection is closing, but closing anyway`, err);
            }
            this.remoteClosed = true;
        });
    }
    sendPacket(packet, sourceAmount, unfulfillable = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.log.trace(`sending packet ${packet.sequence} with source amount: ${sourceAmount}: ${JSON.stringify(packet)})`);
            const data = packet.serializeAndEncrypt(this.sharedSecret, (this.enablePadding ? MAX_DATA_SIZE : undefined));
            let fulfillment;
            let executionCondition;
            if (unfulfillable) {
                fulfillment = undefined;
                executionCondition = cryptoHelper.generateRandomCondition();
            }
            else {
                fulfillment = cryptoHelper.generateFulfillment(this.sharedSecret, data);
                executionCondition = cryptoHelper.hash(fulfillment);
            }
            const prepare = {
                destination: this._destinationAccount,
                amount: (sourceAmount).toString(),
                data,
                executionCondition,
                expiresAt: new Date(Date.now() + DEFAULT_PACKET_TIMEOUT)
            };
            const responseData = yield this.plugin.sendData(IlpPacket.serializeIlpPrepare(prepare));
            this.bumpIdle();
            let response;
            try {
                if (responseData[0] === IlpPacket.Type.TYPE_ILP_FULFILL) {
                    response = IlpPacket.deserializeIlpFulfill(responseData);
                }
                else if (responseData[0] === IlpPacket.Type.TYPE_ILP_REJECT) {
                    response = IlpPacket.deserializeIlpReject(responseData);
                }
                else {
                    throw new Error(`Invalid response packet type: ${responseData[0]}`);
                }
            }
            catch (err) {
                this.log.error(`got invalid response from sending packet ${packet.sequence}:`, err, responseData.toString('hex'));
                throw new Error(`Invalid response when sending packet ${packet.sequence}: ${err.message}`);
            }
            if (fulfillment && isFulfill(response)) {
                if (!cryptoHelper.hash(response.fulfillment).equals(executionCondition)) {
                    this.log.error(`got invalid fulfillment for packet ${packet.sequence}: ${response.fulfillment.toString('hex')}. expected: ${fulfillment.toString('hex')} for condition: ${executionCondition.toString('hex')}`);
                    throw new Error(`Got invalid fulfillment for packet ${packet.sequence}. Actual: ${response.fulfillment.toString('hex')}, expected: ${fulfillment.toString('hex')}`);
                }
            }
            else {
                response = response;
                this.undoRejectedPacket(packet);
                if (response.code !== 'F99') {
                    return this.handleConnectorError(response, sourceAmount);
                }
            }
            if (response.data.length === 0) {
                return undefined;
            }
            let responsePacket;
            try {
                responsePacket = packet_1.Packet.decryptAndDeserialize(this.sharedSecret, response.data);
            }
            catch (err) {
                this.log.error(`unable to decrypt and parse response data:`, err, response.data.toString('hex'));
                throw new Error('Unable to decrypt and parse response data: ' + err.message);
            }
            if (!responsePacket.sequence.isEqualTo(packet.sequence)) {
                this.log.error(`response packet sequence does not match the request packet. expected sequence: ${packet.sequence}, got response packet:`, JSON.stringify(responsePacket));
                throw new Error(`Response packet sequence does not correspond to the request. Actual: ${responsePacket.sequence}, expected: ${packet.sequence}`);
            }
            if (responsePacket.ilpPacketType !== responseData[0]) {
                this.log.error(`response packet was on wrong ILP packet type. expected ILP packet type: ${responseData[0]}, got:`, JSON.stringify(responsePacket));
                throw new Error(`Response says it should be on an ILP packet of type: ${responsePacket.ilpPacketType} but it was carried on an ILP packet of type: ${responseData[0]}`);
            }
            this.log.debug(`got response to packet: ${packet.sequence}: ${JSON.stringify(responsePacket)}`);
            return responsePacket;
        });
    }
    undoRejectedPacket(requestPacket) {
        this.log.debug(`packet ${requestPacket.sequence} was rejected`);
        for (let frame of requestPacket.frames) {
            switch (frame.type) {
                case packet_1.FrameType.StreamMoney:
                    this.streams.get(frame.streamId.toNumber())._cancelHold(requestPacket.sequence.toString());
                    break;
                case packet_1.FrameType.StreamData:
                    this.streams.get(frame.streamId.toNumber())._resendOutgoingData(frame.data, frame.offset.toNumber());
                    break;
                case packet_1.FrameType.StreamClose:
                    this.queuedFrames.push(frame);
                    break;
                default:
                    continue;
            }
        }
    }
    handleConnectorError(reject, amountSent) {
        return __awaiter(this, void 0, void 0, function* () {
            this.log.debug(`handling reject triggered by: ${reject.triggeredBy} error: ${reject.code} message: ${reject.message} data: ${reject.data}`);
            if (reject.code === 'F08') {
                let receivedAmount;
                let maximumAmount;
                try {
                    const reader = oer_utils_1.Reader.from(reject.data);
                    receivedAmount = reader.readUInt64BigNum();
                    maximumAmount = reader.readUInt64BigNum();
                }
                catch (err) {
                    receivedAmount = undefined;
                    maximumAmount = undefined;
                }
                if (receivedAmount && maximumAmount && receivedAmount.isGreaterThan(maximumAmount)) {
                    const newMaximum = amountSent
                        .times(maximumAmount)
                        .dividedToIntegerBy(receivedAmount);
                    this.log.trace(`reducing maximum packet amount from ${this.maximumPacketAmount} to ${newMaximum}`);
                    this.maximumPacketAmount = newMaximum;
                    this.testMaximumPacketAmount = newMaximum;
                }
                else {
                    this.maximumPacketAmount = amountSent.minus(1);
                    this.testMaximumPacketAmount = this.maximumPacketAmount.dividedToIntegerBy(2);
                }
                if (this.maximumPacketAmount.isEqualTo(0)) {
                    this.log.error(`cannot send anything through this path. the maximum packet amount is 0`);
                    throw new Error('Cannot send. Path has a Maximum Packet Amount of 0');
                }
            }
            else if (reject.code[0] === 'T') {
                if (reject.code === 'T04') {
                    const minPacketAmount = bignumber_js_1.default.minimum(amountSent, this.testMaximumPacketAmount);
                    const newTestAmount = minPacketAmount.minus(minPacketAmount.dividedToIntegerBy(3));
                    this.testMaximumPacketAmount = bignumber_js_1.default.maximum(2, newTestAmount);
                    this.log.warn(`got T04: Insufficient Liquidity error triggered by: ${reject.triggeredBy}. reducing the packet amount to ${this.testMaximumPacketAmount}`);
                }
                this.log.warn(`got ${reject.code} temporary error triggered by: ${reject.triggeredBy}. waiting ${this.retryDelay}ms before trying again`);
                const delay = this.retryDelay;
                this.retryDelay = Math.min(this.retryDelay * 2, RETRY_DELAY_MAX);
                yield new Promise((resolve, reject) => setTimeout(resolve, delay));
            }
            else {
                this.log.error(`unexpected error. code: ${reject.code}, triggered by: ${reject.triggeredBy}, message: ${reject.message}, data: ${reject.data.toString('hex')}`);
                throw new Error(`Unexpected error while sending packet. Code: ${reject.code}, triggered by: ${reject.triggeredBy}, message: ${reject.message}`);
            }
        });
    }
    safeEmit(event, ...args) {
        try {
            args.unshift(event);
            this.emit.apply(this, args);
        }
        catch (err) {
            this.log.debug(`error in ${event} handler:`, err);
        }
    }
    getOutgoingOffsets() {
        let currentOffset = 0;
        let maxOffset = 0;
        for (let [_, stream] of this.streams) {
            const streamOffsets = stream._getOutgoingOffsets();
            currentOffset += streamOffsets.current;
            maxOffset += streamOffsets.max;
        }
        return {
            currentOffset,
            maxOffset
        };
    }
    getIncomingOffsets() {
        let totalMaxOffset = 0;
        let totalReadOffset = 0;
        let totalBufferedData = 0;
        for (let [_, stream] of this.streams) {
            const { max, current } = stream._getIncomingOffsets();
            totalMaxOffset += max;
            totalReadOffset += current;
            totalBufferedData += stream.readableLength;
        }
        return {
            current: totalReadOffset,
            max: totalMaxOffset,
            maxAcceptable: totalReadOffset - totalBufferedData + this.maxBufferedData
        };
    }
    removeStreamRecord(stream) {
        this.log.debug(`removing record of stream ${stream.id}`);
        this.streams.delete(stream.id);
        this.closedStreams[stream.id] = true;
        if (!stream._sentEnd) {
            stream._sentEnd = true;
            const streamEndFrame = (stream._errorMessage
                ? new packet_1.StreamCloseFrame(stream.id, packet_1.ErrorCode.ApplicationError, stream._errorMessage)
                : new packet_1.StreamCloseFrame(stream.id, packet_1.ErrorCode.NoError, ''));
            this.queuedFrames.push(streamEndFrame);
        }
    }
    startIdleTimer() {
        if (this.idleTimeout === 0)
            return;
        const idle = Date.now() - this.lastActive.getTime();
        this.idleTimer = setTimeout(() => this.testIdle(), this.idleTimeout - idle);
        if (typeof this.idleTimer.unref === 'function') {
            this.idleTimer.unref();
        }
        this.log.trace(`(re)starting idle timeout for ${this.idleTimeout}ms from now`);
    }
    testIdle() {
        const idle = Date.now() - this.lastActive.getTime();
        if (idle >= this.idleTimeout) {
            this.log.error('Connection timed out due to inactivity, destroying connection');
            this.destroy(new Error('Connection timed out due to inactivity'));
        }
        else {
            this.startIdleTimer();
        }
    }
    bumpIdle() { this.lastActive = new Date(); }
}
exports.Connection = Connection;
function isFulfill(packet) {
    return packet.hasOwnProperty('fulfillment');
}
//# sourceMappingURL=connection.js.map