{"version":3,"file":"util.js","sourceRoot":"","sources":["../../../src/lib/util.ts"],"names":[],"mappings":";;AAAA,6CAAoC;AAKvB,QAAA,cAAc,GAAG,CAAC,CAAA;AAE/B,IAAM,aAAa,GAAG,YAAY,CAAA;AAClC,SAAgB,SAAS,CAAE,KAAU;IACnC,IAAI,sBAAS,CAAC,WAAW,CAAC,KAAK,CAAC,EAAE;QAChC,OAAO,KAAK,CAAC,QAAQ,EAAE;eAClB,KAAK,CAAC,SAAS,EAAE,CAAA;KACvB;SAAM,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;QACpC,OAAO,QAAQ,CAAC,KAAK,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,KAAK,CAAA;KACtD;SAAM,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;QACpC,OAAO,CAAC,CAAC,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;KACnC;SAAM;QACL,OAAO,KAAK,CAAA;KACb;AACH,CAAC;AAXD,8BAWC;AAED,SAAgB,iBAAiB,CAAE,MAAc;IAC/C,OAAO,MAAM,CAAC,MAAM,CAClB,UAAC,GAAG,EAAE,KAAK,IAAK,OAAA,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,EAA1B,CAA0B,EAC1C,IAAI,sBAAS,CAAC,CAAC,CAAC,CACjB,CAAA;AACH,CAAC;AALD,8CAKC;AAED,SAAgB,iBAAiB,CAAE,KAAgB,EAAE,MAAe;IAClE,IAAM,aAAa,GAAG,CAAC,MAAM,KAAK,SAAS,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAA;IAC/F,IAAM,MAAM,GAAG,MAAM,CAAC,KAAK,CAAC,aAAa,CAAC,CAAA;IAC1C,IAAI,GAAG,GAAG,KAAK,CAAA;IACf,KAAK,IAAI,CAAC,GAAG,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;QAC3C,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC,CAAA;QAChD,GAAG,GAAG,GAAG,CAAC,kBAAkB,CAAC,GAAG,CAAC,CAAA;KAClC;IACD,OAAO,MAAM,CAAA;AACf,CAAC;AATD,8CASC","sourcesContent":["import BigNumber from 'bignumber.js'\n\n// How many bytes are safe to decode as a JS number\n// MAX_SAFE_INTEGER = 2^53 - 1\n// 53 div 8 -> 6 bytes\nexport const MAX_SAFE_BYTES = 6\n\nconst INTEGER_REGEX = /^-?[0-9]+$/\nexport function isInteger (value: any) {\n  if (BigNumber.isBigNumber(value)) {\n    return value.isFinite()\n      && value.isInteger()\n  } else if (typeof value === 'number') {\n    return isFinite(value) && Math.floor(value) === value\n  } else if (typeof value === 'string') {\n    return !!INTEGER_REGEX.exec(value)\n  } else {\n    return false\n  }\n}\n\nexport function bufferToBigNumber (buffer: Buffer): BigNumber {\n  return buffer.reduce(\n    (sum, value) => sum.times(256).plus(value),\n    new BigNumber(0)\n  )\n}\n\nexport function bigNumberToBuffer (value: BigNumber, length?: number): Buffer {\n  const lengthOfValue = (length !== undefined ? length : Math.ceil(value.toString(2).length / 8))\n  const buffer = Buffer.alloc(lengthOfValue)\n  let big = value\n  for (let i = buffer.length - 1; i >= 0; i--) {\n    buffer.writeUInt8(big.modulo(256).toNumber(), i)\n    big = big.dividedToIntegerBy(256)\n  }\n  return buffer\n}\n"]}