"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var underflow_error_1 = require("../errors/underflow-error");
var parse_error_1 = require("../errors/parse-error");
var bignumber_js_1 = require("bignumber.js");
var util_1 = require("./util");
bignumber_js_1.default.config({
    EXPONENTIAL_AT: [-7, 50]
});
var Reader = (function () {
    function Reader(buffer) {
        this.buffer = buffer;
        this.cursor = 0;
        this.bookmarks = [];
    }
    Reader.from = function (source) {
        if (Buffer.isBuffer(source)) {
            return new Reader(source);
        }
        else if (source instanceof Reader) {
            return new Reader(source.buffer.slice(source.cursor));
        }
        else {
            throw new Error('Reader must be given a Buffer');
        }
    };
    Reader.prototype.bookmark = function () {
        this.bookmarks.push(this.cursor);
    };
    Reader.prototype.restore = function () {
        if (!this.bookmarks.length) {
            throw new Error('Cannot restore bookmark when no bookmark set');
        }
        this.cursor = this.bookmarks.pop();
    };
    Reader.prototype.ensureAvailable = function (bytes) {
        if (this.buffer.length < (this.cursor + bytes)) {
            throw new underflow_error_1.default('Tried to read ' + bytes + ' bytes, but only ' +
                (this.buffer.length - this.cursor) + ' bytes available');
        }
    };
    Reader.prototype.readUIntNumber = function (length) {
        if (length >= 1 && length <= util_1.MAX_SAFE_BYTES) {
            var value = this.buffer.readUIntBE(this.cursor, length);
            this.cursor += length;
            return value;
        }
        else {
            throw new Error('Value does not fit a JS number without sacrificing precision');
        }
    };
    Reader.prototype.readUIntBigNum = function (length) {
        var value = this.peekUIntBigNum(length);
        this.cursor += length;
        return value;
    };
    Reader.prototype.readUInt = function (length) {
        if (length >= 1 && length <= util_1.MAX_SAFE_BYTES) {
            return String(this.readUIntNumber(length));
        }
        else {
            return this.readUIntBigNum(length).toString();
        }
    };
    Reader.prototype.peekUIntNumber = function (length) {
        if (length >= 1 && length <= util_1.MAX_SAFE_BYTES) {
            return this.buffer.readUIntBE(this.cursor, length);
        }
        else {
            throw new Error('Value does not fit a JS number without sacrificing precision');
        }
    };
    Reader.prototype.peekUIntBigNum = function (length) {
        if (length === 0) {
            return new bignumber_js_1.default(0);
        }
        else if (length < 0) {
            throw new Error('Tried to read integer with negative length (provided: ' +
                length + ')');
        }
        else if (length > 8) {
            throw new Error('UInts longer than 8 bytes must be encoded as VarUInts');
        }
        return util_1.bufferToBigNumber(this.peek(length));
    };
    Reader.prototype.peekUInt = function (length) {
        if (length >= 1 && length <= util_1.MAX_SAFE_BYTES) {
            return String(this.peekUIntNumber(length));
        }
        else {
            return this.peekUIntBigNum(length).toString();
        }
    };
    Reader.prototype.skipUInt = function (length) {
        this.skip(length);
    };
    Reader.prototype.readIntNumber = function (length) {
        if (length >= 1 && length <= util_1.MAX_SAFE_BYTES) {
            var value = this.buffer.readIntBE(this.cursor, length);
            this.cursor += length;
            return value;
        }
        else {
            throw new Error('Value does not fit a JS number without sacrificing precision');
        }
    };
    Reader.prototype.readIntBigNum = function (length) {
        var value = this.peekIntBigNum(length);
        this.cursor += length;
        return value;
    };
    Reader.prototype.readInt = function (length) {
        if (length >= 1 && length <= util_1.MAX_SAFE_BYTES) {
            return String(this.readIntNumber(length));
        }
        else {
            return this.readIntBigNum(length).toString();
        }
    };
    Reader.prototype.peekIntNumber = function (length) {
        if (length >= 1 && length <= util_1.MAX_SAFE_BYTES) {
            return this.buffer.readIntBE(this.cursor, length);
        }
        else {
            throw new Error('Value does not fit a JS number without sacrificing precision');
        }
    };
    Reader.prototype.peekIntBigNum = function (length) {
        if (length === 0) {
            return new bignumber_js_1.default(0);
        }
        else if (length < 0) {
            throw new Error('Tried to read integer with negative length (provided: ' +
                length + ')');
        }
        else if (length > 8) {
            throw new Error('Ints longer than 8 bytes must be encoded as VarInts');
        }
        var value = util_1.bufferToBigNumber(this.peek(length));
        var maxValue = new bignumber_js_1.default(256).exponentiatedBy(length).minus(1);
        if (value.isLessThan(maxValue.dividedBy(2))) {
            return value;
        }
        else {
            return value.minus(maxValue).minus(1);
        }
    };
    Reader.prototype.peekInt = function (length) {
        if (length >= 1 && length <= util_1.MAX_SAFE_BYTES) {
            return String(this.peekIntNumber(length));
        }
        else {
            return this.peekIntBigNum(length).toString();
        }
    };
    Reader.prototype.skipInt = function (length) {
        this.skip(length);
    };
    Reader.prototype.readVarUIntNumber = function () {
        if (this.buffer[this.cursor] === 0) {
            throw new parse_error_1.default('UInt of length 0 is invalid');
        }
        if (this.buffer[this.cursor] <= util_1.MAX_SAFE_BYTES) {
            return this.readUIntNumber(this.buffer[this.cursor++]);
        }
        else {
            throw new Error('Value does not fit a JS number without sacrificing precision');
        }
    };
    Reader.prototype.readVarUIntBigNum = function () {
        var buffer = this.readVarOctetString();
        if (buffer.length === 0) {
            throw new parse_error_1.default('UInt of length 0 is invalid');
        }
        return util_1.bufferToBigNumber(buffer);
    };
    Reader.prototype.readVarUInt = function () {
        return this.readVarUIntBigNum().toString();
    };
    Reader.prototype.peekVarUIntNumber = function () {
        this.bookmark();
        var value = this.readVarUIntNumber();
        this.restore();
        return value;
    };
    Reader.prototype.peekVarUIntBigNum = function () {
        this.bookmark();
        var value = this.readVarUIntBigNum();
        this.restore();
        return value;
    };
    Reader.prototype.peekVarUInt = function () {
        return this.peekVarUIntBigNum().toString();
    };
    Reader.prototype.skipVarUInt = function () {
        this.skipVarOctetString();
    };
    Reader.prototype.readVarIntNumber = function () {
        if (this.buffer[this.cursor] === 0) {
            throw new parse_error_1.default('Int of length 0 is invalid');
        }
        if (this.buffer[this.cursor] <= util_1.MAX_SAFE_BYTES) {
            return this.readIntNumber(this.buffer[this.cursor++]);
        }
        else {
            throw new Error('Value does not fit a JS number without sacrificing precision');
        }
    };
    Reader.prototype.readVarIntBigNum = function () {
        var buffer = this.readVarOctetString();
        if (buffer.length === 0) {
            throw new parse_error_1.default('Int of length 0 is invalid');
        }
        var value = util_1.bufferToBigNumber(buffer);
        var maxValue = new bignumber_js_1.default(256).exponentiatedBy(buffer.length).minus(1);
        if (value.isLessThan(maxValue.dividedBy(2))) {
            return value;
        }
        else {
            return value.minus(maxValue).minus(1);
        }
    };
    Reader.prototype.readVarInt = function () {
        return this.readVarIntBigNum().toString();
    };
    Reader.prototype.peekVarIntNumber = function () {
        this.bookmark();
        var value = this.readVarIntNumber();
        this.restore();
        return value;
    };
    Reader.prototype.peekVarIntBigNum = function () {
        this.bookmark();
        var value = this.readVarIntBigNum();
        this.restore();
        return value;
    };
    Reader.prototype.peekVarInt = function () {
        return this.peekVarIntBigNum().toString();
    };
    Reader.prototype.skipVarInt = function () {
        this.skipVarOctetString();
    };
    Reader.prototype.readOctetString = function (length) {
        return this.read(length);
    };
    Reader.prototype.peekOctetString = function (length) {
        return this.peek(length);
    };
    Reader.prototype.skipOctetString = function (length) {
        return this.skip(length);
    };
    Reader.prototype.readLengthPrefix = function () {
        var length = this.readUInt8BigNum().toNumber();
        if (length & Reader.HIGH_BIT) {
            var lengthPrefixLength = length & Reader.LOWER_SEVEN_BITS;
            var actualLength = this.readUIntBigNum(lengthPrefixLength).toNumber();
            var minLength = Math.max(128, 1 << ((lengthPrefixLength - 1) * 8));
            if (actualLength < minLength) {
                throw new parse_error_1.default('Length prefix encoding is not canonical: ' +
                    actualLength + ' encoded in ' + lengthPrefixLength + ' bytes');
            }
            return actualLength;
        }
        return length;
    };
    Reader.prototype.readVarOctetString = function () {
        var length = this.readLengthPrefix();
        return this.read(length);
    };
    Reader.prototype.peekVarOctetString = function () {
        this.bookmark();
        var value = this.readVarOctetString();
        this.restore();
        return value;
    };
    Reader.prototype.skipVarOctetString = function () {
        var length = this.readLengthPrefix();
        this.skip(length);
    };
    Reader.prototype.read = function (bytes) {
        this.ensureAvailable(bytes);
        var value = this.buffer.slice(this.cursor, this.cursor + bytes);
        this.cursor += bytes;
        return value;
    };
    Reader.prototype.peek = function (bytes) {
        this.ensureAvailable(bytes);
        return this.buffer.slice(this.cursor, this.cursor + bytes);
    };
    Reader.prototype.skip = function (bytes) {
        this.ensureAvailable(bytes);
        this.cursor += bytes;
    };
    Reader.HIGH_BIT = 0x80;
    Reader.LOWER_SEVEN_BITS = 0x7F;
    return Reader;
}());
['read', 'peek', 'skip'].forEach(function (verb) {
    [1, 2, 4, 8].forEach(function (bytes) {
        Reader.prototype[verb + 'UInt' + bytes * 8] = function () {
            return this[verb + 'UInt'](bytes);
        };
        Reader.prototype[verb + 'Int' + bytes * 8] = function () {
            return this[verb + 'Int'](bytes);
        };
        if (verb !== 'skip') {
            Reader.prototype[verb + 'UInt' + bytes * 8 + 'Number'] = function () {
                return this[verb + 'UIntNumber'](bytes);
            };
            Reader.prototype[verb + 'Int' + bytes * 8 + 'Number'] = function () {
                return this[verb + 'IntNumber'](bytes);
            };
            Reader.prototype[verb + 'UInt' + bytes * 8 + 'BigNum'] = function () {
                return this[verb + 'UIntBigNum'](bytes);
            };
            Reader.prototype[verb + 'Int' + bytes * 8 + 'BigNum'] = function () {
                return this[verb + 'IntBigNum'](bytes);
            };
        }
    });
});
exports.default = Reader;
//# sourceMappingURL=reader.js.map